/*! Flocking 2.0.1, Copyright 2019 Colin Clark | flockingjs.org */


var fluid_3_0_0 = fluid_3_0_0 || {}, fluid = fluid || fluid_3_0_0;

!function(y, b) {
    "use strict";
    b.version = "Infusion 3.0.0", b.Error = Error, b.environment = {
        fluid: b
    }, b.global = b.global || "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}, 
    b.invokeLater = function(e) {
        return setTimeout(e, 1);
    }, b.defeatLogging = !0, b.activityTracing = !1, b.activityTrace = [];
    var s = /(%\w+)/g;
    function o(e, t, n, r) {
        for (var o = e[n], a = 0; a < r.length - 1; ++a) o = r[a + 1](o, n);
        t[n] = o;
    }
    b.renderOneActivity = function(e, t) {
        for (var n = !0 === t ? [] : [ "    while " ], r = e.message, o = s.lastIndex = 0; ;) {
            var a = s.exec(r);
            if (!a) break;
            var i = a[1].substring(1);
            n.push(r.substring(o, a.index)), n.push(e.args[i]), o = s.lastIndex;
        }
        return o < r.length && n.push(r.substring(o)), n;
    }, b.renderActivity = function(e, t) {
        return t = t || b.renderOneActivity, b.transform(e, t);
    }, b.singleThreadLocal = function(e) {
        var t = e();
        return function(e) {
            return void 0 === e ? t : t = e;
        };
    }, b.threadLocal = b.singleThreadLocal, b.globalThreadLocal = b.threadLocal(function() {
        return {};
    }), b.getActivityStack = function() {
        var e = b.globalThreadLocal();
        return e.activityStack || (e.activityStack = []), e.activityStack;
    }, b.describeActivity = b.getActivityStack, b.logActivity = function(e) {
        e = e || b.describeActivity();
        var t = b.renderActivity(e).reverse();
        0 < t.length && (b.log("Current activity: "), b.each(t, function(e) {
            b.log.apply(null, e);
        }));
    }, b.pushActivity = function(e, t, n) {
        var r = {
            type: e,
            message: t,
            args: n,
            time: new Date().getTime()
        };
        b.activityTracing && b.activityTrace.push(r), b.passLogLevel(b.logLevel.TRACE) && b.log.apply(null, b.renderOneActivity(r, !0)), 
        b.getActivityStack().push(r);
    }, b.popActivity = function(e) {
        e = e || 1, b.activityTracing && b.activityTrace.push({
            pop: e
        });
        var t = b.getActivityStack(), n = t.length - e;
        t.length = n < 0 ? 0 : n;
    }, b.FluidError = function() {
        var e = Error.apply(this, arguments);
        this.message = e.message;
        try {
            throw e;
        } catch (e) {
            this.stack = e.stack;
        }
        return this;
    }, b.FluidError.prototype = Object.create(Error.prototype), b.logFailure = function(e, t) {
        b.log.apply(null, [ b.logLevel.FAIL, "ASSERTION FAILED: " ].concat(e)), b.logActivity(t);
    }, b.renderLoggingArg = function(e) {
        return void 0 === e ? "undefined" : b.isPrimitive(e) || !b.isPlainObject(e) ? e : JSON.stringify(e);
    }, b.builtinFail = function(e) {
        var t = b.transform(e, b.renderLoggingArg).join("");
        throw new b.FluidError("Assertion failure - check console for more details: " + t);
    }, b.fail = function() {
        var e = b.makeArray(arguments), t = b.makeArray(b.describeActivity());
        b.popActivity(t.length), b.failureEvent ? b.failureEvent.fire(e, t) : (b.logFailure(e, t), 
        b.builtinFail(e, t));
    }, b.expect = function(t, n, e) {
        b.transform(b.makeArray(e), function(e) {
            void 0 === n[e] && b.fail(t + " missing required parameter " + e);
        });
    }, b.isLogging = function() {
        return n[0].priority > b.logLevel.IMPORTANT.priority;
    }, b.isLogLevel = function(e) {
        return b.isMarker(e) && void 0 !== e.priority;
    }, b.passLogLevel = function(e) {
        return e.priority <= n[0].priority;
    }, b.setLogging = function(e) {
        var t;
        "boolean" == typeof e ? t = b.logLevel[e ? "INFO" : "IMPORTANT"] : b.isLogLevel(e) ? t = e : b.fail("Unrecognised fluid logging level ", e), 
        n.unshift(t), b.defeatLogging = !b.isLogging();
    }, b.setLogLevel = b.setLogging, b.popLogging = function() {
        var e = 1 === n.length ? n[0] : n.shift();
        return b.defeatLogging = !b.isLogging(), e;
    }, b.doBrowserLog = function(e) {
        "undefined" != typeof console && (console.debug ? console.debug.apply(console, e) : "function" == typeof console.log && console.log.apply(console, e));
    }, b.log = function() {
        var e = b.makeArray(arguments), t = b.logLevel.INFO;
        b.isLogLevel(e[0]) && (t = e.shift()), b.passLogLevel(t) && b.loggingEvent.fire(e);
    }, b.isValue = function(e) {
        return null != e;
    }, b.isPrimitive = function(e) {
        var t = typeof e;
        return !e || "string" == t || "boolean" == t || "number" == t || "function" == t;
    }, b.isJQuery = function(e) {
        return Boolean(e && e.jquery && e.constructor && e.constructor.prototype && e.constructor.prototype.jquery);
    }, b.isArrayable = function(e) {
        return Boolean(e) && ("[object Array]" === Object.prototype.toString.call(e) || b.isJQuery(e));
    }, b.isPlainObject = function(e, t) {
        var n = Object.prototype.toString.call(e);
        return "[object Array]" === n ? !t : "[object Object]" === n && (!e.constructor || !e.constructor.prototype || Object.prototype.hasOwnProperty.call(e.constructor.prototype, "isPrototypeOf"));
    }, b.typeCode = function(e) {
        return b.isPrimitive(e) || !b.isPlainObject(e) ? "primitive" : b.isArrayable(e) ? "array" : "object";
    }, b.isIoCReference = function(e) {
        return "string" == typeof e && "{" === e.charAt(0) && 0 < e.indexOf("}");
    }, b.isDOMNode = function(e) {
        return e && "number" == typeof e.nodeType;
    }, b.isComponent = function(e) {
        return e && e.constructor === b.componentConstructor;
    }, b.isUncopyable = function(e) {
        return b.isPrimitive(e) || !b.isPlainObject(e);
    }, b.isApplicable = function(e) {
        return e.apply && "function" == typeof e.apply;
    }, b.identity = function(e) {
        return e;
    }, b.notImplemented = function() {
        b.fail("This operation is not implemented");
    }, b.firstDefined = function(e, t) {
        return void 0 === e ? t : e;
    }, b.freshContainer = function(e) {
        return b.isArrayable(e) ? [] : {};
    }, b.copyRecurse = function(e, r) {
        return r.length > b.strategyRecursionBailout && b.fail("Runaway recursion encountered in fluid.copy - reached path depth of " + b.strategyRecursionBailout + " via path of " + r.join(".") + "this object is probably circularly connected. Either adjust your object structure to remove the circularity or increase fluid.strategyRecursionBailout"), 
        b.isUncopyable(e) ? e : b.transform(e, function(e, t) {
            r.push(t);
            var n = b.copyRecurse(e, r);
            return r.pop(), n;
        });
    }, b.copy = function(e) {
        return b.copyRecurse(e, []);
    }, b.extend = y.extend, b.makeArray = function(e) {
        var t = [];
        if (null != e) if (b.isPrimitive(e) || b.isPlainObject(e, !0) || "number" != typeof e.length) t.push(e); else for (var n = 0; n < e.length; ++n) t[n] = e[n];
        return t;
    }, b.pushArray = function(e, t, n) {
        var r = e[t] ? e[t] : e[t] = [];
        b.isArrayable(n) ? r.push.apply(r, n) : r.push(n);
    }, b.transform = function(e) {
        if (b.isPrimitive(e)) return e;
        var t = b.freshContainer(e);
        if (b.isArrayable(e)) for (var n = 0; n < e.length; ++n) o(e, t, n, arguments); else for (var r in e) o(e, t, r, arguments);
        return t;
    }, b.each = function(e, t) {
        if (b.isArrayable(e)) for (var n = 0; n < e.length; ++n) t(e[n], n); else for (var r in e) t(e[r], r);
    }, b.make_find = function(i) {
        var s = !i && void 0;
        return function(e, t, n) {
            var r;
            if (b.isArrayable(e)) {
                for (var o = 0; o < e.length; ++o) if ((r = t(e[o], o)) !== s) return i ? e[o] : r;
            } else for (var a in e) if ((r = t(e[a], a)) !== s) return i ? e[a] : r;
            return n;
        };
    }, b.find = b.make_find(!1), b.find_if = b.make_find(!0), b.accumulate = function(e, t, n) {
        for (var r = 0; r < e.length; ++r) n = t(e[r], n, r);
        return n;
    }, b.add = function(e, t) {
        return e + t;
    }, b.remove_if = function(e, t, n) {
        if (b.isArrayable(e)) for (var r = e.length - 1; 0 <= r; --r) t(e[r], r) && (n && n.unshift(e[r]), 
        e.splice(r, 1)); else for (var o in e) t(e[o], o) && (n && (n[o] = e[o]), delete e[o]);
        return n || e;
    }, b.generate = function(e, t, n) {
        for (var r = [], o = 0; o < e; ++o) r[o] = n ? t(o) : t;
        return r;
    }, b.iota = function(e, t) {
        t = t || 0;
        for (var n = [], r = 0; r < e; ++r) n[n.length] = t++;
        return n;
    }, b.getMembers = function(e, t) {
        return b.transform(e, function(e) {
            return b.get(e, t);
        });
    }, b.filterKeys = function(e, n, r) {
        return b.remove_if(y.extend({}, e), function(e, t) {
            return r ^ -1 === n.indexOf(t);
        });
    }, b.censorKeys = function(e, t) {
        return b.filterKeys(e, t, !0);
    }, b.keys = function(e) {
        var t = [];
        for (var n in e) t.push(n);
        return t;
    }, b.values = function(e) {
        var t = [];
        for (var n in e) t.push(e[n]);
        return t;
    }, b.contains = function(e, t) {
        return e ? b.isArrayable(e) ? -1 !== e.indexOf(t) : b.find(e, function(e) {
            if (t === e) return !0;
        }) : void 0;
    }, b.keyForValue = function(e, n) {
        return b.find(e, function(e, t) {
            if (n === e) return t;
        });
    }, b.arrayToHash = function(e) {
        var t = {};
        return b.each(e, function(e) {
            t[e] = !0;
        }), t;
    }, b.stableSort = function(e, t) {
        for (var n = 0; n < e.length; n++) {
            var r, o = e[n];
            for (r = n; 0 < r && t(o, e[r - 1]) < 0; r--) e[r] = e[r - 1];
            e[r] = o;
        }
    }, b.hashToArray = function(e, r, o) {
        var a = [];
        return b.each(e, function(e, t) {
            var n = {};
            n[r] = t, o ? n = o(n, e, t) || n : y.extend(!0, n, e), a.push(n);
        }), a;
    }, b.flatten = function(e) {
        var t = [];
        return b.each(e, function(e) {
            b.isArrayable(e) ? t = t.concat(e) : t.push(e);
        }), t;
    }, b.clear = function(e) {
        if (b.isArrayable(e)) e.length = 0; else for (var t in e) delete e[t];
    }, b.compareStringLength = function(e) {
        return e ? function(e, t) {
            return e.length - t.length;
        } : function(e, t) {
            return t.length - e.length;
        };
    }, b.parseInteger = function(e) {
        return isFinite(e) && e % 1 == 0 ? Number(e) : NaN;
    }, b.roundToDecimal = function(e, t, n) {
        return t = t && 0 <= t ? Math.round(t) : 0, "ceil" === n || "floor" === n ? Number(Math[n](e + "e" + t) + "e-" + t) : Number((0 <= e ? 1 : -1) * (Math.round(Math.abs(e) + "e" + t) + "e-" + t));
    }, b.debounce = function(r, o, a) {
        var i, s;
        return function() {
            var e = this, t = arguments, n = a && !i;
            return clearTimeout(i), i = setTimeout(function() {
                i = null, a || (s = r.apply(e, t));
            }, o), n && (s = r.apply(e, t)), s;
        };
    }, b.freezeRecursive = function(e) {
        return b.isPlainObject(e) ? (b.each(e, function(e) {
            b.freezeRecursive(e);
        }), Object.freeze(e)) : e;
    }, b.marker = function() {}, b.makeMarker = function(e, t) {
        var n = Object.create(b.marker.prototype);
        return n.value = e, y.extend(n, t), Object.freeze(n);
    }, b.VALUE = b.makeMarker("VALUE"), b.NO_VALUE = b.makeMarker("NO_VALUE"), b.EXPAND = b.makeMarker("EXPAND"), 
    b.isMarker = function(e, t) {
        return e instanceof b.marker && (!t || e.value === t.value);
    }, b.logLevelsSpec = {
        FATAL: 0,
        FAIL: 5,
        WARN: 10,
        IMPORTANT: 12,
        INFO: 15,
        TRACE: 20
    }, b.logLevel = b.transform(b.logLevelsSpec, function(e, t) {
        return b.makeMarker(t, {
            priority: e
        });
    });
    var n = [ b.logLevel.IMPORTANT ];
    b.model = {}, b.model.copyModel = function(e, t) {
        b.clear(e), y.extend(!0, e, t);
    }, b.model.parseEL = function(e) {
        return "" === e ? [] : String(e).split(".");
    }, b.model.composePath = function(e, t) {
        return "" === e ? t : "" === t ? e : e + "." + t;
    }, b.model.composeSegments = function() {
        return b.makeArray(arguments).join(".");
    }, b.lastDotIndex = function(e) {
        return e.lastIndexOf(".");
    }, b.model.getToTailPath = function(e) {
        var t = b.lastDotIndex(e);
        return -1 === t ? "" : e.substring(0, t);
    }, b.model.getTailPath = function(e) {
        var t = b.lastDotIndex(e);
        return e.substring(t + 1);
    }, b.path = b.model.composeSegments, b.composePath = b.model.composePath, b.requireDataBinding = function() {
        b.fail("Please include DataBinding.js in order to operate complex model accessor configuration");
    }, b.model.setWithStrategy = b.model.getWithStrategy = b.requireDataBinding, b.model.resolvePathSegment = function(e, t, n, r) {
        if (!r && e.resolvePathSegment) {
            var o = e.resolvePathSegment(t);
            if (void 0 !== o) return o;
        }
        return n && void 0 === e[t] ? e[t] = {} : e[t];
    }, b.model.parseToSegments = function(e, t, n) {
        return "number" == typeof e || "string" == typeof e ? t(e) : n ? b.makeArray(e) : e;
    }, b.model.pathToSegments = function(e, t) {
        var n = t && t.parser ? t.parser.parse : b.model.parseEL;
        return b.model.parseToSegments(e, n);
    }, b.model.accessImpl = function(e, t, n, r, o, a, i) {
        var s = b.model.pathToSegments(t, r), l = 0;
        if (o && (l = o.length, s = o.concat(s)), e = i(e, s, l, r, n === b.NO_VALUE ? 0 : 1), 
        n === b.NO_VALUE || n === b.VALUE) return a ? {
            root: e,
            segs: s
        } : e;
        e[s[s.length - 1]] = n;
    }, b.model.accessSimple = function(e, t, n, r, o, a) {
        return b.model.accessImpl(e, t, n, r, o, a, b.model.traverseSimple);
    }, b.model.traverseSimple = function(e, t, n, r, o) {
        for (var a = r, i = t.length - o, s = 0; s < i; ++s) {
            if (!e) return;
            var l = t[s];
            e = r && r[l] ? r[l] : b.model.resolvePathSegment(e, l, 1 === o, a), r = null;
        }
        return e;
    }, b.model.setSimple = function(e, t, n, r, o) {
        b.model.accessSimple(e, t, n, r, o, !1);
    }, b.model.getSimple = function(e, t, n, r) {
        return null == t || 0 === t.length ? e : b.model.accessSimple(e, t, b.NO_VALUE, n, r, !1);
    }, b.getImmediate = function(e, t, n) {
        for (var r = void 0 === n ? t.length : n + 1, o = 0; o < r; ++o) e = e ? e[t[o]] : void 0;
        return e;
    }, b.decodeAccessorArg = function(e) {
        return e && e !== b.model.defaultGetConfig && e !== b.model.defaultSetConfig ? "environment" === e.type ? e.value : void 0 : null;
    }, b.set = function(e, t, n, r, o) {
        var a = b.decodeAccessorArg(r);
        void 0 === a ? b.model.setWithStrategy(e, t, n, r, o) : b.model.setSimple(e, t, n, a, o);
    }, b.get = function(e, t, n, r) {
        var o = b.decodeAccessorArg(n);
        return void 0 === o ? b.model.getWithStrategy(e, t, n, r) : b.model.accessImpl(e, t, b.NO_VALUE, o, null, !1, b.model.traverseSimple);
    }, b.getGlobalValue = function(e, t) {
        if (e) return t = t || b.environment, b.get(b.global, e, {
            type: "environment",
            value: t
        });
    }, b.bind = function(e, t, n) {
        return e[t].apply(e, b.makeArray(n));
    }, b.invokeGlobalFunction = function(e, t, n) {
        var r = b.getGlobalValue(e, n);
        if (r) return r.apply(null, b.isArrayable(t) ? t : b.makeArray(t));
        b.fail("Error invoking global function: " + e + " could not be located");
    }, b.registerGlobalFunction = function(e, t, n) {
        n = n || b.environment, b.set(b.global, e, t, {
            type: "environment",
            value: n
        });
    }, b.setGlobalValue = b.registerGlobalFunction, b.registerNamespace = function(e, t) {
        t = t || b.environment;
        var n = b.getGlobalValue(e, t);
        return n || (n = {}, b.setGlobalValue(e, n, t)), n;
    }, b.dumpEl = b.identity, b.renderTimestamp = b.identity, b.generateUniquePrefix = function() {
        return Math.floor(1e12 * Math.random()).toString(36) + "-";
    };
    var e = b.generateUniquePrefix();
    b.fluidInstance = e;
    var t = 1;
    b.allocateGuid = function() {
        return e + t++;
    }, b.registerNamespace("fluid.event"), b.extremePriority = 4e9, b.priorityTypes = {
        first: -1,
        last: 1,
        before: 0,
        after: 0
    }, b.extremalPriorities = {
        none: 0,
        testing: 10,
        authoring: 20
    }, b.parsePriorityConstraint = function(e, t, n) {
        var r = e.split(":"), o = r[0], a = b.priorityTypes[o];
        return void 0 === a && b.fail("Invalid constraint type in priority field " + e + ": the only supported values are " + b.keys(b.priorityTypes).join(", ") + " or numeric"), 
        t && 0 === a && b.fail("Constraint type in priority field " + e + " is not supported in a " + n + " record - you must use either a numeric value or first, last"), 
        {
            type: r[0],
            target: r[1]
        };
    }, b.parsePriority = function(e, t, n, r) {
        var o = {
            count: t || 0,
            fixed: null,
            constraint: null,
            site: r
        };
        "number" == typeof (e = e || 0) ? o.fixed = -e : o.constraint = b.parsePriorityConstraint(e, n, r);
        var a = o.constraint ? b.priorityTypes[o.constraint.type] : 0;
        if (0 !== a) {
            var i = o.constraint.target || "none", s = b.extremalPriorities[i];
            void 0 === s && b.fail("Unrecognised extremal priority target " + i + ": the currently supported values are " + b.keys(b.extremalPriorities).join(", ") + ": register your value in fluid.extremalPriorities"), 
            o.fixed = a * (b.extremePriority + s);
        }
        return null !== o.fixed && (o.fixed += o.count / 1024), o;
    }, b.renderPriority = function(e) {
        return e.constraint ? e.constraint.target ? e.constraint.type + ":" + e.constraint.target : e.constraint.type : Math.floor(e.fixed);
    }, b.compareByPriority = function(e, t) {
        return null !== e.priority.fixed && null !== t.priority.fixed ? e.priority.fixed - t.priority.fixed : (null === e.priority.fixed) - (null === t.priority.fixed);
    }, b.honourConstraint = function(e, t, n) {
        var r = e[n].priority.constraint, o = b.find(e, function(e, t) {
            return e.namespace === r.target ? t : void 0;
        }, -1);
        if (-1 === o) return !0;
        if (t <= o) return !1;
        for (var a = o + ("after" === r.type ? 1 : 0), i = e[n], s = n; a <= s; --s) e[s] = e[s - 1];
        return e[a] = i, !0;
    }, b.sortByPriority = function(e) {
        b.stableSort(e, b.compareByPriority);
        for (var t = b.find(e, function(e, t) {
            return e.priority.constraint && 0 === b.priorityTypes[e.priority.constraint.type] ? t : void 0;
        }, e.length); ;) {
            if (t === e.length) return e;
            for (var n = t, r = t; r < e.length; ++r) {
                b.honourConstraint(e, t, r) && ++t;
            }
            if (t === n) {
                var o = e.slice(t);
                b.fail("Could not find targets for any constraints in " + o[0].priority.site + " ", o, ": none of the targets (" + b.getMembers(o, "priority.constraint.target").join(", ") + ") matched any namespaces of the elements in (", e.slice(0, t), ") - this is caused by either an invalid or circular reference");
            }
        }
    }, b.parsePriorityRecords = function(e, r) {
        var t = b.hashToArray(e, "namespace", function(e, t, n) {
            y.extend(e, t), e.priority = b.parsePriority(t.priority, n, !1, r);
        });
        return b.sortByPriority(t), t;
    }, b.event.identifyListener = function(e, t) {
        return "string" == typeof e || e.$$fluid_guid || t || (e.$$fluid_guid = b.allocateGuid()), 
        e.$$fluid_guid;
    }, b.event.impersonateListener = function(e, t) {
        b.event.identifyListener(e), t.$$fluid_guid = e.$$fluid_guid;
    }, b.event.sortListeners = function(e) {
        var o = [];
        return b.each(e, function(e) {
            for (var t, n = 0; n < e.length; ++n) {
                var r = e[n];
                r.softNamespace || t || (t = r);
            }
            t ? o.push(t) : o = o.concat(e);
        }), b.sortByPriority(o);
    }, b.event.resolveListener = function(e) {
        var t = e.globalName || ("string" == typeof e ? e : null);
        if (t) {
            var n = b.getGlobalValue(t);
            n ? e = n : b.fail("Unable to look up name " + t + " as a global function");
        }
        return e;
    }, b.nameComponent = function(e) {
        return e ? "component with typename " + e.typeName + " and id " + e.id : "[unknown component]";
    }, b.event.nameEvent = function(e, t) {
        return t + " of " + b.nameComponent(e);
    }, b.makeEventFirer = function(a) {
        var s, e = (a = a || {}).name || "<anonymous>";
        return s = {
            eventId: b.allocateGuid(),
            name: e,
            ownerId: a.ownerId,
            typeName: "fluid.event.firer",
            destroy: function() {
                s.destroyed = !0;
            },
            addListener: function() {
                (function() {
                    s.listeners = {}, s.byId = {}, s.sortedListeners = [], s.addListener = function(e, t, n, r, o) {
                        var a;
                        if (s.destroyed && b.fail("Cannot add listener to destroyed event firer " + s.name), 
                        e) {
                            b.isPlainObject(e, !0) && !b.isApplicable(e) && (e = (a = e).listener, t = a.namespace, 
                            n = a.priority, r = a.softNamespace, o = a.listenerId), "string" == typeof e && (e = {
                                globalName: e
                            });
                            var i = o || b.event.identifyListener(e);
                            t = t || i, a = y.extend(a || {}, {
                                namespace: t,
                                listener: e,
                                softNamespace: r,
                                listenerId: o,
                                priority: b.parsePriority(n, s.sortedListeners.length, !1, "listeners")
                            }), s.byId[i] = a, (s.listeners[t] = b.makeArray(s.listeners[t]))[r ? "push" : "unshift"](a), 
                            s.sortedListeners = b.event.sortListeners(s.listeners);
                        }
                    }, s.addListener.apply(null, arguments);
                }).apply(null, arguments);
            },
            removeListener: function(e) {
                if (s.listeners) {
                    var t, n, r;
                    "string" == typeof e ? (t = e, (r = s.listeners[t]) || (n = t, t = null)) : "function" == typeof e && ((n = b.event.identifyListener(e, !0)) || b.fail("Cannot remove unregistered listener function ", e, " from event " + s.name));
                    var o = s.byId[n], a = o && o.softNamespace;
                    t = t || o && o.namespace || n, delete s.byId[n], (r = s.listeners[t]) && (a ? b.remove_if(r, function(e) {
                        return e.listener.$$fluid_guid === n || e.listenerId === n;
                    }) : r.shift(), 0 === r.length && delete s.listeners[t]), s.sortedListeners = b.event.sortListeners(s.listeners);
                }
            },
            fire: function() {
                var e = s.sortedListeners;
                if (e && !s.destroyed) for (var t = 0; t < e.length; ++t) {
                    var n = e[t];
                    "function" != typeof n.listener && (n.listener = b.event.resolveListener(n.listener));
                    var r, o = n.listener.apply(null, arguments);
                    if ((a.preventable && !1 === o || s.destroyed) && (r = !1), void 0 !== r) return r;
                }
            }
        };
    }, b.fireEvent = function(e, t, n) {
        var r = e.events[t];
        r && r.fire.apply(null, b.makeArray(n));
    }, b.event.addListenerToFirer = function(e, t, n, r) {
        if (r = r || b.identity, b.isArrayable(t)) for (var o = 0; o < t.length; ++o) b.event.addListenerToFirer(e, t[o], n, r); else "function" == typeof t || "string" == typeof t ? r(e).addListener(t, n) : t && "object" == typeof t && r(e).addListener(t.listener, n || t.namespace, t.priority, t.softNamespace, t.listenerId);
    }, b.event.resolveListenerRecord = function(e) {
        return {
            records: e
        };
    }, b.expandImmediate = function(e) {
        b.fail("fluid.expandImmediate could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor " + e);
    }, b.mergeListeners = function(i, s, e) {
        b.each(e, function(e, t) {
            var n, r;
            if (b.isIoCReference(t)) (n = b.expandImmediate(t, i)) || b.fail("Error in listener record: key " + t + ' could not be looked up to an event firer - did you miss out "events." when referring to an event firer?'); else {
                var o = t.indexOf(".");
                -1 !== o && (r = t.substring(o + 1), t = t.substring(0, o)), s[t] || b.fail("Listener registered for event " + t + " which is not defined for this component"), 
                n = s[t];
            }
            var a = b.event.resolveListenerRecord(e, i, t, r, !0);
            b.event.addListenerToFirer(n, a.records, r, a.adderWrapper);
        });
    }, b.eventFromRecord = function(e, t, n) {
        var r;
        return e && ("string" != typeof e || b.isIoCReference(e)) ? b.event.resolveEvent ? r = b.event.resolveEvent(n, t, e) : b.fail("fluid.event.resolveEvent could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor ", e) : r = b.makeEventFirer({
            name: b.event.nameEvent(n, t),
            preventable: "preventable" === e,
            ownerId: n.id
        }), r;
    }, b.instantiateFirers = function(n, e) {
        b.each(e.events, function(e, t) {
            n.events[t] = b.eventFromRecord(e, t, n);
        });
    }, b.mergeListenerPolicy = function(e, t, n) {
        return "string" != typeof n && b.fail("Error in listeners declaration - the keys in this structure must resolve to event names - got " + n + " from ", t), 
        !b.isIoCReference(n) && -1 !== n.indexOf(".") ? t || e : b.arrayConcatPolicy(e, t);
    }, b.makeMergeListenersPolicy = function(r, t) {
        return function(n, e) {
            return n = n || {}, t && (b.isArrayable(e) || "string" == typeof e.target) ? n[""] = r(n[""], e, "") : b.each(e, function(e, t) {
                n[t] = r(n[t], e, t);
            }), n;
        };
    }, b.validateListenersImplemented = function(n) {
        var r = [];
        return b.each(n.events, function(e, t) {
            b.each(e.sortedListeners, function(e) {
                e.listener !== b.notImplemented && "fluid.notImplemented" !== e.listener.globalName || r.push({
                    name: t,
                    namespace: e.namespace,
                    componentSource: b.model.getSimple(n.options.listeners, [ t + "." + e.namespace, 0, "componentSource" ])
                });
            });
        }), r;
    }, b.unique = function(n) {
        return b.remove_if(n, function(e, t) {
            return !e || 0 < t && e === n[t - 1];
        });
    }, b.arrayConcatPolicy = function(e, t) {
        return b.makeArray(e).concat(b.makeArray(t));
    }, b.loggingEvent = b.makeEventFirer({
        name: "logging event"
    }), b.addTimestampArg = function(e) {
        var t = b.renderTimestamp(new Date()) + ":  ";
        e.unshift(t);
    }, b.loggingEvent.addListener(b.doBrowserLog, "log"), b.loggingEvent.addListener(b.identity, "filterArgs", "before:log"), 
    b.loggingEvent.addListener(b.addTimestampArg, "addTimestampArg", "after:filterArgs"), 
    b.failureEvent = b.makeEventFirer({
        name: "failure event"
    }), b.failureEvent.addListener(b.builtinFail, "fail"), b.failureEvent.addListener(b.logFailure, "log", "before:fail"), 
    b.pushSoftFailure = function(e) {
        "function" == typeof e ? b.failureEvent.addListener(e, "fail") : -1 === e ? b.failureEvent.removeListener("fail") : "boolean" == typeof e && b.fail("pushSoftFailure with boolean value is no longer supported");
    }, b.componentConstructor = function() {}, b.typeTag = function(e) {
        var t = Object.create(b.componentConstructor.prototype);
        return t.typeName = e, t.id = b.allocateGuid(), t;
    };
    var l = 1, u = {};
    function x(e, t, n, r) {
        for (var o = 0; o < n; ++o) e = r(e, t[o], o, b.makeArray(t));
        return e;
    }
    b.defaultsStore = {}, b.resolveGradesImpl = function(e, t) {
        for (var n = (t = b.makeArray(t)).length - 1; 0 <= n; --n) {
            var r = t[n];
            if (r && !e.gradeHash[r]) {
                var o = (b.isIoCReference(r) ? null : b.rawDefaults(r)) || {}, a = u[r] || l - 1;
                e.lastTick = Math.max(e.lastTick, a), e.gradeHash[r] = !0, e.gradeChain.push(r);
                for (var i = b.makeArray(o.gradeNames), s = i.length - 1; 0 <= s; --s) b.resolveGradesImpl(e, i[s]);
            }
        }
        return e;
    }, b.resolveGradeStructure = function(e, t) {
        var n = {
            lastTick: 0,
            gradeChain: [],
            gradeHash: {}
        };
        return b.resolveGradesImpl(n, [ e ].concat(b.makeArray(t))), n.gradeChain.reverse(), 
        n;
    }, b.hasGrade = function(e, t) {
        return !(!e || !e.gradeNames) && b.contains(e.gradeNames, t);
    }, b.resolveGrade = function(e, t, n) {
        var r = b.resolveGradeStructure(t, n), o = b.transform(r.gradeChain, b.rawDefaults, b.copy);
        b.remove_if(o, function(e) {
            return !e;
        });
        for (var a = {}, i = 0; i < o.length; ++i) o[i] && o[i].mergePolicy && (a = y.extend(!0, a, o[i].mergePolicy));
        o = [ a, {} ].concat(o);
        var s = b.merge.apply(null, o);
        return s.gradeNames = r.gradeChain, b.freezeRecursive(s), {
            defaults: s,
            lastTick: r.lastTick
        };
    }, b.mergedDefaultsCache = {}, b.gradeNamesToKey = function(e, t) {
        return e + "|" + t.join("|");
    }, b.getMergedDefaults = function(e, t) {
        t = b.makeArray(t);
        var n = b.gradeNamesToKey(e, t), r = b.mergedDefaultsCache[n];
        if (r) {
            for (var o = 0, a = r.defaults.gradeNames || [], i = 0; i < a.length; ++i) o = Math.max(o, u[a[i]] || 0);
            o > r.lastTick && (b.passLogLevel(b.logLevel.TRACE) && b.log(b.logLevel.TRACE, "Clearing cache for component " + e + " with gradeNames ", a), 
            r = null);
        }
        if (!r) {
            var s = b.rawDefaults(e);
            if (!s) return s;
            r = b.mergedDefaultsCache[n] = b.resolveGrade(s, e, t);
        }
        return r.defaults;
    }, b.upgradePrimitiveFunc = function(e, t) {
        if (e && b.isPrimitive(e)) {
            var n = {};
            return n[t || ("string" == typeof e && "{" !== e.charAt(0) ? "funcName" : "func")] = e, 
            n.args = b.NO_VALUE, n;
        }
        return e;
    }, b.annotateListeners = function(n, e) {
        e.listeners = b.transform(e.listeners, function(e) {
            var t = b.makeArray(e);
            return b.transform(t, function(e) {
                return (e = b.upgradePrimitiveFunc(e, "listener")).componentSource = n, e;
            });
        }), e.invokers = b.transform(e.invokers, function(e) {
            return (e = b.upgradePrimitiveFunc(e)) && (e.componentSource = n), e;
        });
    }, b.rawDefaults = function(e) {
        var t = b.defaultsStore[e];
        return t && t.options;
    }, b.registerRawDefaults = function(e, t) {
        b.pushActivity("registerRawDefaults", "registering defaults for grade %componentName with options %options", {
            componentName: e,
            options: t
        });
        var n = b.expandCompact ? b.expandCompact(t) : b.copy(t);
        b.annotateListeners(e, n);
        var r = b.getCallerInfo && b.getCallerInfo(6);
        b.defaultsStore[e] = {
            options: n,
            callerInfo: r
        }, u[e] = l++, b.popActivity();
    }, b.doIndexDefaults = function(e, t, n, r) {
        for (var o = b.makeArray(r.gradeNames), a = 0; a < o.length; ++a) if (!b.hasGrade(t, o[a])) return;
        for (var i = ("function" == typeof r.indexFunc ? r.indexFunc : b.getGlobalValue(r.indexFunc))(t) || [], s = 0; s < i.length; ++s) b.pushArray(n, i[s], e);
    }, b.indexDefaults = function(e, t) {
        var n = {};
        for (var r in b.defaultsStore) {
            var o = b.getMergedDefaults(r);
            b.doIndexDefaults(r, o, n, t);
        }
        return n;
    }, b.defaults = function(e, t) {
        if (void 0 === t) return b.getMergedDefaults(e);
        t && t.options && b.fail("Probable error in options structure for " + e + ' with option named "options" - perhaps you meant to write these options at top level in fluid.defaults? - ', t), 
        b.registerRawDefaults(e, t);
        var n = b.getMergedDefaults(e);
        b.hasGrade(n, "fluid.function") || b.makeComponentCreator(e);
    }, b.makeComponentCreator = function(o) {
        function e() {
            var e = b.getMergedDefaults(o);
            if (e.gradeNames && 0 !== e.gradeNames.length) {
                if (e.initFunction) return b.initComponent(o, arguments);
                for (var t = [], n = 0; n < e.gradeNames.length; ++n) {
                    var r = e.gradeNames[n];
                    b.rawDefaults(r) || t.push(r);
                }
                0 === t.length ? b.fail("Cannot make component creator for type " + o + " which does not have an initFunction defined") : b.fail("The grade hierarchy of component with type " + o + " is incomplete - it inherits from the following grade(s): " + t.join(", ") + " for which the grade definitions are corrupt or missing. Please check the files which might include these grades and ensure they are readable and have been loaded by this instance of Infusion");
            } else b.fail("Cannot make component creator for type " + o + " which does not have any gradeNames defined");
        }
        var t = b.getGlobalValue(o);
        t && y.extend(e, t), b.setGlobalValue(o, e);
    }, b.emptyPolicy = b.freezeRecursive({}), b.derefMergePolicy = function(e) {
        return (e ? e["*"] : b.emptyPolicy) || b.emptyPolicy;
    }, b.compileMergePolicy = function(e) {
        var i = {}, s = {}, l = {
            builtins: i,
            defaultValues: s
        };
        return e && b.each(e, function(e, t) {
            var n = {}, r = !0;
            if ("function" == typeof e) n.func = e; else if ("object" == typeof e) n = e; else if (b.isDefaultValueMergePolicy(e)) b.set(s, t, "{that}.options." + e), 
            r = !(l.hasDefaults = !0); else for (var o = e.split(/\s*,\s*/), a = 0; a < o.length; ++a) n[o[a]] = !0;
            r && b.set(i, b.composePath(t, "*"), n);
        }), l;
    }, b.isDefaultValueMergePolicy = function(e) {
        return "string" == typeof e && -1 === e.indexOf(",") && !/replace|nomerge|noexpand/.test(e);
    }, b.mergeOneImpl = function(e, t, n, r, o, a, i) {
        var s = e, l = b.isPrimitive(e);
        return void 0 !== t && (o.func || null === t || !b.isPlainObject(t) || o.nomerge ? (r[n] = void 0, 
        s = o.func ? o.func.call(null, e, t, i[a - 1], i, a) : t) : l && (s = e = b.freshContainer(t))), 
        s;
    }, b.fetchMergeChildren = function(r, o, a, i, s, l) {
        for (var e = b.derefMergePolicy(s), t = i.length - 1; 0 <= t; --t) {
            var n = i[t];
            if (void 0 !== n && (b.each(n, function(e, t) {
                var n = b.concreteTrundler(s, t);
                t in r && (!l.evaluateFully || void 0 !== n || b.isPrimitive(r[t])) || (a[o] = t, 
                l.strategy(r, t, o + 1, a, i, s));
            }), e.replace)) break;
        }
        return r;
    }, b.inEvaluationMarker = Object.freeze({
        __CURRENTLY_IN_EVALUATION__: !0
    }), b.strategyRecursionBailout = 50, b.makeMergeStrategy = function(v) {
        function e(e, t, n, r, o, a) {
            if (n > b.strategyRecursionBailout && b.fail("Overflow/circularity in options merging, current path is ", r, " at depth ", n, ' - please protect components from merging using the "nomerge" merge policy'), 
            !b.isPrimitive(e)) {
                var i;
                if (b.isTracing && b.tracing.pathCount.push(b.path(r.slice(0, n))), t in e) {
                    if (i = e[t], !v.evaluateFully) return i;
                } else e !== b.inEvaluationMarker && (e[t] = b.inEvaluationMarker);
                void 0 === o && (r = b.makeArray(r), o = function(e, t, n, r) {
                    for (var o = [], a = 0; a < e.length; ++a) {
                        var i = x(e[a], t, n, r[a]);
                        void 0 !== i && o.push(i);
                    }
                    return o;
                }(v.sources, r, n - 1, v.sourceStrategies), a = x(v.mergePolicy, r, n - 1, b.concreteTrundler));
                var s, l, u, c = b.concreteTrundler(a, t), d = b.derefMergePolicy(c);
                u = d.replace ? (s = 1 - o.length, l = 0, -1) : (s = 0, l = o.length - 1, 1);
                for (var f, p = [], m = s; m <= l; ++m) {
                    var g = u * m, h = v.sourceStrategies[g](o[g], t, n, r);
                    if (void 0 !== h && (b.isPrimitive(h) || (p[g] = h), void 0 === i)) {
                        if (-1 === u) {
                            f = e[t] = h;
                            break;
                        }
                        f = b.mergeOneImpl(f, h, m, p, d, n, r, v), e !== b.inEvaluationMarker && (e[t] = f);
                    }
                }
                return void 0 !== i && (f = i), 0 < p.length && b.isPlainObject(f) && b.fetchMergeChildren(f, n, r, p, c, v), 
                void 0 === i && 0 === p.length && delete e[t], f;
            }
        }
        return v.strategy = e;
    }, b.driveStrategy = function(e, t, n) {
        t = b.makeArray(t);
        for (var r = 0; r < t.length; ++r) {
            if (!e) return;
            e = n(e, t[r], r + 1, t);
        }
        return e;
    }, b.concreteTrundler = function(e, t) {
        return e ? e[t] : void 0;
    }, b.merge = function(e) {
        var t = Array.prototype.slice.call(arguments, 1), n = b.compileMergePolicy(e).builtins, r = b.makeMergeOptions(n, t, {});
        return r.initter(), r.target;
    }, b.simpleGingerBlock = function(e, t) {
        return {
            target: e,
            simple: !0,
            strategy: b.concreteTrundler,
            initter: b.identity,
            recordType: t,
            priority: b.mergeRecordTypes[t]
        };
    }, b.makeMergeOptions = function(e, t, n) {
        var r = {
            mergePolicy: e,
            sources: t
        };
        return (r = y.extend(r, n)).target = r.target || b.freshContainer(r.sources[0]), 
        r.sourceStrategies = r.sourceStrategies || b.generate(r.sources.length, b.concreteTrundler), 
        r.initter = function() {
            r.evaluateFully = !0, b.fetchMergeChildren(r.target, 0, [], r.sources, r.mergePolicy, r);
        }, b.makeMergeStrategy(r), r;
    }, b.transformOptions = function(e, t) {
        return b.expect("Options transformation record", t, [ "transformer", "config" ]), 
        b.getGlobalValue(t.transformer).call(null, e, t.config);
    }, b.findMergeBlocks = function(e, t) {
        return b.remove_if(b.makeArray(e), function(e) {
            return e.recordType !== t;
        });
    }, b.transformOptionsBlocks = function(n, r, e) {
        b.each(e, function(e) {
            var t = b.findMergeBlocks(n, e);
            b.each(t, function(e) {
                var t = e.source ? "source" : "target";
                e[e.simple || "target" == t ? "target" : "source"] = b.transformOptions(e[t], r);
            });
        });
    }, b.dedupeDistributionNamespaces = function(e) {
        var n = {};
        b.remove_if(e, function(e) {
            var t = e.namespace;
            if (t) {
                if (n[t] && n[t] !== e.contextThat.id) return !0;
                n[t] = e.contextThat.id;
            }
        });
    }, b.deliverOptionsStrategy = b.identity, b.computeComponentAccessor = b.identity, 
    b.computeDynamicComponents = b.identity, b.mergeRecordTypes = {
        defaults: 1e3,
        defaultValueMerge: 900,
        subcomponentRecord: 800,
        user: 700,
        distribution: 100
    }, b.model.applyChangeRequest = function(e, t) {
        var n = t.segs;
        if (0 === n.length) "ADD" === t.type ? y.extend(!0, e, t.value) : b.clear(e); else if ("ADD" === t.type) b.model.setSimple(e, t.segs, t.value); else {
            for (var r = 0; r < n.length - 1; ++r) if (!(e = e[n[r]])) return;
            delete e[n[n.length - 1]];
        }
    }, b.destroyValue = function(e, t) {
        e && b.model.applyChangeRequest(e, {
            type: "DELETE",
            segs: t
        });
    }, b.mergeComponentOptions = function(e, t, n, r) {
        var o = b.rawDefaults(t), a = b.getMergedDefaults(t, o && o.gradeNames ? null : r.gradeNames), i = {}, s = [];
        s = b.expandComponentOptions ? s.concat(b.expandComponentOptions(i, a, n, e)) : s.concat([ b.simpleGingerBlock(a, "defaults"), b.simpleGingerBlock(n, "user") ]);
        function l() {
            b.each(s, function(e) {
                b.isPrimitive(e.priority) && (e.priority = b.parsePriority(e.priority, 0, !1, "options distribution"));
            }), b.sortByPriority(s), b.dedupeDistributionNamespaces(s), c.length = 0, d.length = 0, 
            b.each(s, function(e) {
                c.push(e.strategy), d.push(e.target);
            });
        }
        var u = {}, c = [], d = [], f = {
            target: u,
            sourceStrategies: c
        };
        l();
        var p, m, g = b.makeMergeOptions(i, d, f);
        function h() {
            m = b.driveStrategy(u, "mergePolicy", g.strategy), m = y.extend({}, b.rootMergePolicy, m), 
            p = b.compileMergePolicy(m), y.extend(!0, i, p.builtins);
        }
        g.mergeBlocks = s, g.updateBlocks = l, g.destroyValue = function(e) {
            for (var t = 0; t < s.length; ++t) s[t].immutableTarget || b.destroyValue(s[t].target, e);
            b.destroyValue(f.target, e);
        }, h(), g.computeMergePolicy = h, p.hasDefaults && (b.generateExpandBlock ? (s.push(b.generateExpandBlock({
            options: p.defaultValues,
            recordType: "defaultValueMerge",
            priority: b.mergeRecordTypes.defaultValueMerge
        }, e, {})), l()) : b.fail("Cannot operate mergePolicy ", m, " for component ", e, " without including FluidIoC.js")), 
        e.options = u, b.driveStrategy(u, "gradeNames", g.strategy), b.deliverOptionsStrategy(e, u, g), 
        b.computeComponentAccessor(e, n && n.localRecord);
        var v = b.driveStrategy(u, "transformOptions", g.strategy);
        return v && (b.transformOptionsBlocks(s, v, [ "user", "subcomponentRecord" ]), l()), 
        f.target.mergePolicy || h(), g;
    }, b.defaults("fluid.function", {}), b.invokeGradedFunction = function(e, n) {
        var t = b.defaults(e);
        t && t.argumentMap && b.hasGrade(t, "fluid.function") || b.fail("Cannot look up name " + e + " to a function with registered argumentMap - got defaults ", t);
        var r = [];
        return b.each(t.argumentMap, function(e, t) {
            r[e] = n[t];
        }), b.invokeGlobalFunction(e, r);
    }, b.noNamespaceDistributionPrefix = "no-namespace-distribution-", b.mergeOneDistribution = function(e, t, n) {
        var r = t.namespace || n || b.noNamespaceDistributionPrefix + b.allocateGuid();
        e[t.namespace = r] = y.extend(!0, {}, e[r], t);
    }, b.distributeOptionsPolicy = function(n, e) {
        if (n = n || {}, b.isArrayable(e)) for (var t = 0; t < e.length; ++t) b.mergeOneDistribution(n, e[t]); else "string" == typeof e.target ? b.mergeOneDistribution(n, e) : b.each(e, function(e, t) {
            b.mergeOneDistribution(n, e, t);
        });
        return n;
    }, b.mergingArray = function() {}, b.mergingArray.prototype = [], b.membersMergePolicy = function(n, e) {
        return n = n || {}, b.each(e, function(e, t) {
            n[t] || (n[t] = new b.mergingArray()), e instanceof b.mergingArray ? n[t].push.apply(n[t], e) : void 0 !== e && n[t].push(e);
        }), n;
    }, b.invokerStrategies = b.arrayToHash([ "func", "funcName", "listener", "this", "method", "changePath", "value" ]), 
    b.invokersMergePolicy = function(a, e) {
        return a = a || {}, b.each(e, function(e, t) {
            if (e) {
                e = b.upgradePrimitiveFunc(e);
                var n = a[t];
                for (var r in n || (n = a[t] = {}), b.invokerStrategies) if (r in e) for (var o in b.invokerStrategies) n[o] = void 0;
                y.extend(n, e);
            } else a[t] = e;
        }), a;
    }, b.rootMergePolicy = {
        gradeNames: b.arrayConcatPolicy,
        distributeOptions: b.distributeOptionsPolicy,
        members: {
            noexpand: !0,
            func: b.membersMergePolicy
        },
        invokers: {
            noexpand: !0,
            func: b.invokersMergePolicy
        },
        transformOptions: "replace",
        listeners: b.makeMergeListenersPolicy(b.mergeListenerPolicy)
    }, b.defaults("fluid.component", {
        initFunction: "fluid.initLittleComponent",
        mergePolicy: b.rootMergePolicy,
        argumentMap: {
            options: 0
        },
        events: {
            onCreate: null,
            onDestroy: null,
            afterDestroy: null
        }
    }), b.defaults("fluid.emptySubcomponent", {
        gradeNames: [ "fluid.component" ]
    }), b.computeNickName = function(e) {
        var t = b.model.parseEL(e);
        return t[t.length - 1];
    }, b.defaults("fluid.typeFount", {
        gradeNames: [ "fluid.component" ]
    }), b.initLittleComponent = function(e, t, n, r) {
        var o = b.typeTag(e);
        o.lifecycleStatus = "constructing", n = n || {
            gradeNames: "fluid.component"
        }, o.destroy = b.makeRootDestroy(o);
        var a = b.mergeComponentOptions(o, e, t, n);
        a.exceptions = {
            members: {
                model: !0,
                modelRelay: !0
            }
        };
        var i = o.options;
        o.events = {}, (r || b.identity)(o, i, a.strategy), b.computeDynamicComponents(o, a);
        for (var s = 0; s < a.mergeBlocks.length; ++s) a.mergeBlocks[s].initter();
        return a.initter(), delete i.mergePolicy, b.instantiateFirers(o, i), b.mergeListeners(o, o.events, i.listeners), 
        o;
    }, b.diagnoseFailedView = b.identity, b.makeRootDestroy = function(e) {
        return function() {
            b.doDestroy(e), b.fireEvent(e, "afterDestroy", [ e, "", null ]);
        };
    }, b.isDestroyed = function(e) {
        return "destroyed" === e.lifecycleStatus;
    }, b.doDestroy = function(e, t, n) {
        for (var r in b.fireEvent(e, "onDestroy", [ e, t || "", n ]), e.lifecycleStatus = "destroyed", 
        e.events) "afterDestroy" !== r && "function" == typeof e.events[r].destroy && e.events[r].destroy();
        e.applier && e.applier.destroy();
    }, b.initComponent = function(e, t) {
        var n = b.defaults(e);
        n.gradeNames || b.fail("Cannot initialise component " + e + " which has no gradeName registered");
        var r, o = [ e ].concat(b.makeArray(t));
        b.pushActivity("initComponent", "constructing component of type %componentName with arguments %initArgs", {
            componentName: e,
            initArgs: t
        }), r = b.invokeGlobalFunction(n.initFunction, o), b.diagnoseFailedView(e, r, n, o), 
        b.initDependents && b.initDependents(r);
        var a = b.validateListenersImplemented(r);
        return 0 < a.length && b.fail(b.transform(a, function(e) {
            return [ "Error constructing component ", r, " - the listener for event " + e.name + " with namespace " + e.namespace + (e.componentSource ? " which was defined in grade " + e.componentSource : "") + " needs to be overridden with a concrete implementation" ];
        })).join("\n"), "constructing" === r.lifecycleStatus && (r.lifecycleStatus = "constructed"), 
        r.events.onCreate.fire(r), b.popActivity(), r;
    }, b.initSubcomponentImpl = function(e, t, n) {
        var r;
        if ("function" != typeof t) {
            var o = "string" == typeof t ? t : t.type;
            r = "fluid.emptySubcomponent" === o ? null : b.invokeGlobalFunction(o, n);
        } else r = t.apply(null, n);
        return r;
    };
    var r = "(?:[\\w\\u00c0-\\uFFFF*_-";
    b.simpleCSSMatcher = {
        regexp: new RegExp("([#.]?)(" + r + "]|\\\\.)+)", "g"),
        charToTag: {
            "": "tag",
            "#": "id",
            ".": "clazz"
        }
    }, b.IoCSSMatcher = {
        regexp: new RegExp("([&#]?)(" + r + "]|\\.|\\/)+)", "g"),
        charToTag: {
            "": "context",
            "&": "context",
            "#": "id"
        }
    };
    var p = new RegExp("\\s*(>)?\\s*", "g");
    b.parseSelector = function(e, t) {
        var n = [];
        e = e.trim();
        for (var r = t.regexp, o = r.lastIndex = 0; ;) {
            for (var a = [], i = !0; ;) {
                var s = r.exec(e);
                if (!s) break;
                if (s.index !== o) {
                    if (!i) break;
                    b.fail("Error in selector string - cannot match child selector expression starting at " + e.substring(o));
                }
                var l = {}, u = s[2], c = t.charToTag[s[1]];
                c && (l[c] = u), a[a.length] = l, o = r.lastIndex, i = !1;
            }
            p.lastIndex = o;
            var d = {
                predList: a
            }, f = p.exec(e);
            if (f && f.index === o || b.fail("Error in selector string - can not match child selector expression at " + e.substring(o)), 
            ">" === f[1] && (d.child = !0), n[n.length] = d, p.lastIndex >= e.length) break;
            o = p.lastIndex, r.lastIndex = p.lastIndex;
        }
        return n;
    }, b.flattenObjectPaths = function(e) {
        var r = {};
        return b.each(e, function(e, n) {
            if (null !== e && "object" == typeof e) {
                var t = b.flattenObjectPaths(e);
                b.each(t, function(e, t) {
                    r[n + "." + t] = e;
                }), "function" == typeof b.get(e, "toString") && (r[n] = e.toString());
            } else r[n] = e;
        }), r;
    }, b.stringTemplate = function(e, t) {
        var n = b.flattenObjectPaths(t), r = b.keys(n);
        r = r.sort(b.compareStringLength());
        for (var o = 0; o < r.length; ++o) for (var a = r[o], i = "%" + a, s = n[a], l = -1; -1 !== (l = e.indexOf(i)); ) e = e.slice(0, l) + s + e.slice(l + i.length);
        return e;
    };
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(r, d) {
    "use strict";
    d.renderTimestamp = function(e) {
        function t(e, t) {
            t || (t = 2);
            var n = void 0 === e ? "" : e.toString();
            return "00000".substring(5 - t + n.length) + n;
        }
        return t(e.getHours()) + ":" + t(e.getMinutes()) + ":" + t(e.getSeconds()) + "." + t(e.getMilliseconds(), 3);
    }, d.isTracing = !1, d.registerNamespace("fluid.tracing"), d.tracing.pathCount = [], 
    d.tracing.summarisePathCount = function(e) {
        e = e || d.tracing.pathCount;
        for (var t = {}, n = 0; n < e.length; ++n) {
            var r = e[n];
            t[r] ? ++t[r] : t[r] = 1;
        }
        var o = [];
        return d.each(t, function(e, t) {
            o.push({
                path: t,
                count: e
            });
        }), o.sort(function(e, t) {
            return t.count - e.count;
        }), o;
    }, d.tracing.condensePathCount = function(e, t) {
        e = d.makeArray(e);
        var r = {};
        d.each(e, function(e) {
            r[e] = 0;
        });
        var o = [];
        return d.each(t, function(t) {
            var n = t.path;
            d.find(e, function(e) {
                if (0 === n.indexOf(e)) return r[e] += t.count, !0;
            }) || o.push(t);
        }), d.each(r, function(e, t) {
            o.unshift({
                path: t,
                count: e
            });
        }), o;
    }, d.detectStackStyle = function(e) {
        var t = "other", n = {
            offset: 0
        };
        return e.arguments ? t = "chrome" : "undefined" != typeof window && window.opera && e.stacktrace ? t = "opera10" : e.stack ? (t = "firefox", 
        n.offset = -1 === e.stack.indexOf("Trace exception") ? 1 : 0) : "undefined" == typeof window || !window.opera || "stacktrace" in e || (t = "opera"), 
        n.style = t, n;
    }, d.obtainException = function() {
        try {
            throw new Error("Trace exception");
        } catch (e) {
            return e;
        }
    };
    var a = d.detectStackStyle(d.obtainException());
    d.registerNamespace("fluid.exceptionDecoders"), d.decodeStack = function() {
        if ("firefox" !== a.style) return null;
        var e = d.obtainException();
        return d.exceptionDecoders[a.style](e);
    }, d.exceptionDecoders.firefox = function(e) {
        var t = e.stack.replace(/(?:\n@:0)?\s+$/m, "").replace(/^\(/gm, "{anonymous}(").split("\n");
        return d.transform(t, function(e) {
            var t = (e = e.replace(/\)/g, "")).indexOf("at ");
            return -1 === t ? [ e ] : [ e.substring(t + "at ".length), e.substring(0, t) ];
        });
    }, d.getCallerInfo = function(e) {
        e = (e || 3) - a.offset;
        var t = d.decodeStack(), n = t && t[e][0];
        if (n) {
            var r = n.lastIndexOf("/");
            -1 === r && (r = 0);
            var o = n.indexOf(":", r);
            return {
                path: n.substring(0, r),
                filename: n.substring(r + 1, o),
                index: n.substring(o + 1)
            };
        }
        return null;
    }, d.generatePadding = function(e, t) {
        for (var n = "", r = 0; r < t; ++r) n += e;
        return n;
    }, d.SYNTHETIC_PROPERTY = Object.freeze({}), d.getSafeProperty = function(e, t) {
        var n = Object.getOwnPropertyDescriptor(e, t);
        return n && !n.get ? e[t] : d.SYNTHETIC_PROPERTY;
    }, d.prettyPrintJSON = function(e, t) {
        return (t = r.extend({
            indent: 4,
            stack: [],
            output: ""
        }, t)).indentChars = d.generatePadding(" ", t.indent), function e(t, n, r) {
            function o(e) {
                r.output += e;
            }
            var a = n + r.indentChars, i = "function" == typeof t;
            if (void 0 !== r.maxRenderChars && r.output.length > r.maxRenderChars) return !0;
            if (null === t) o("null"); else if (void 0 === t) o("undefined"); else if (t === d.SYNTHETIC_PROPERTY) o("[Synthetic property]"); else if (d.isPrimitive(t) && !i) o(JSON.stringify(t)); else {
                if (-1 !== r.stack.indexOf(t)) return void o("(CIRCULAR)");
                var s;
                if (r.stack.push(t), d.isArrayable(t)) if (0 === t.length) o("[]"); else {
                    for (o("[\n" + a), s = 0; s < t.length; ++s) {
                        if (e(t[s], a, r)) return !0;
                        s !== t.length - 1 && o(",\n" + a);
                    }
                    o("\n" + n + "]");
                } else {
                    o("{" + (i ? " Function" : "") + "\n" + a);
                    var l = d.keys(t);
                    for (s = 0; s < l.length; ++s) {
                        var u = l[s], c = d.getSafeProperty(t, u);
                        if (o(JSON.stringify(u) + ": "), e(c, a, r)) return !0;
                        s !== l.length - 1 && o(",\n" + a);
                    }
                    o("\n" + n + "}");
                }
                r.stack.pop();
            }
        }(e, "", t), t.output;
    }, d.dumpEl = function(e) {
        var t;
        if (!e) return "null";
        if (3 === e.nodeType || 8 === e.nodeType) return "[data: " + e.data + "]";
        if (9 === e.nodeType) return "[document: location " + e.location + "]";
        if (e.nodeType || !d.isArrayable(e)) return t = (e = r(e)).get(0).tagName, e.id && (t += "#" + e.id), 
        e.attr("class") && (t += "." + e.attr("class")), t;
        t = "[";
        for (var n = 0; n < e.length; ++n) t += d.dumpEl(e[n]), n < e.length - 1 && (t += ", ");
        return t + "]";
    };
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(d, h) {
    "use strict";
    h.visitComponentChildren = function(e, t, n, r) {
        for (var o in r = r || [], e) {
            var a = e[o];
            if (!(!h.isComponent(a) || n.visited && n.visited[a.id])) {
                if (r.push(o), n.visited && (n.visited[a.id] = !0), t(a, o, r, r.length - 1)) return !0;
                n.flat || h.visitComponentChildren(a, t, n, r), r.pop();
            }
        }
    }, h.getContextHash = function(e, t) {
        var n = e.idToShadow[t.id];
        return n && n.contextHash;
    }, h.componentHasGrade = function(e, t) {
        var n = h.getContextHash(h.globalInstantiator, e);
        return !(!n || !n[t]);
    }, h.visitComponentsForMatching = function(e, t, a) {
        var i = h.getInstantiator(e);
        t = d.extend({
            visited: {},
            instantiator: i
        }, t);
        var s = [ e ], l = [ h.getContextHash(i, e) ];
        h.visitComponentChildren(e, function(e, t, n) {
            s.length = 1, l.length = 1;
            for (var r = 0; r < n.length; ++r) {
                var o = s[r][n[r]];
                s[r + 1] = o, l[r + 1] = h.getContextHash(i, o) || {};
            }
            return a(e, s, l, n, n.length);
        }, t, []);
    }, h.getMemberNames = function(e, t) {
        if (0 === t.length) return [];
        var n = e.idToPath(t[t.length - 1].id), r = e.parseEL(n);
        return r.unshift.apply(r, h.generate(t.length - r.length, "")), r;
    }, h.visitComponentsForVisibility = function(e, t, n, r) {
        r = r || {
            visited: {},
            flat: !0,
            instantiator: e
        };
        for (var o = h.getMemberNames(e, t), a = t.length - 1; 0 <= a; --a) {
            var i = t[a];
            if (r.visited[i.id] = !0, n(i, o[a], o, a)) return;
            if (h.visitComponentChildren(i, n, r, o)) return;
            o.pop();
        }
    }, h.mountStrategy = function(a, e, i) {
        var s = a.length;
        return function(e, t, n, r) {
            if (!(n <= a.length)) {
                for (var o = 0; o < a.length; ++o) if (r[o] !== a[o]) return;
                return i(e, t, n - a.length, r.slice(s));
            }
        };
    }, h.invokerFromRecord = function(e, t, n) {
        h.pushActivity("makeInvoker", "beginning instantiation of invoker with name %name and record %record as child of %that", {
            name: t,
            record: e,
            that: n
        });
        var r = e ? h.makeInvoker(n, e, t) : void 0;
        return h.popActivity(), r;
    }, h.memberFromRecord = function(e, t, n) {
        for (var r, o = 0; o < e.length; ++o) {
            var a = h.expandImmediate(e[o], n);
            r = h.isPlainObject(r) ? d.extend(!0, r, a) : a;
        }
        return r;
    }, h.recordStrategy = function(a, i, s, l, u, n, r) {
        return n = n || [], {
            strategy: function(e, t, n) {
                if (1 === n) {
                    var r = h.driveStrategy(i, [ l, t ], s);
                    if (void 0 !== r) {
                        h.set(e, [ t ], h.inEvaluationMarker);
                        var o = u(r, t, a);
                        return h.set(e, [ t ], o), o;
                    }
                }
            },
            initter: function() {
                var e = h.driveStrategy(i, l, s) || {};
                for (var t in e) r && r[t] || h.getForComponent(a, n.concat([ t ]));
            }
        };
    }, h.instantiateFirers = function(e) {
        var t = h.shadowForComponent(e);
        (h.get(t, [ "eventStrategyBlock", "initter" ]) || h.identity)();
    }, h.makeDistributionRecord = function(e, t, n, r, o, a) {
        a = a || "distribution", h.pushActivity("makeDistributionRecord", "Making distribution record from source record %sourceRecord path %sourcePath to target path %targetSegs", {
            sourceRecord: t,
            sourcePath: n,
            targetSegs: r
        });
        var i = h.copy(h.get(t, n));
        h.each(o, function(e) {
            h.model.applyChangeRequest(i, {
                segs: e,
                type: "DELETE"
            });
        });
        var s = {
            options: {}
        };
        return h.model.applyChangeRequest(s, {
            segs: r,
            type: "ADD",
            value: i
        }), h.checkComponentRecord(s), h.popActivity(), d.extend(s, {
            contextThat: e,
            recordType: a
        });
    }, h.filterBlocks = function(t, e, o, a, i, s) {
        var l = [];
        return h.each(e, function(n) {
            var e = h.get(n.source, o);
            if (void 0 !== e) {
                l.push(h.makeDistributionRecord(t, n.source, o, a, i, n.recordType));
                var r = d.extend({}, e);
                s && h.model.applyChangeRequest(n.source, {
                    segs: o,
                    type: "DELETE"
                }), h.each(i, function(e) {
                    var t = h.get(r, e);
                    h.set(n.source, o.concat(e), t);
                });
            }
        }), l;
    }, h.noteCollectedDistribution = function(e, t, n) {
        h.model.setSimple(e, [ "collectedDistributions", t, n.id ], !0);
    }, h.isCollectedDistribution = function(e, t, n) {
        return h.model.getSimple(e, [ "collectedDistributions", t, n.id ]);
    }, h.clearCollectedDistributions = function(e, t) {
        h.model.applyChangeRequest(e, {
            segs: [ "collectedDistributions", t ],
            type: "DELETE"
        });
    }, h.collectDistributions = function(e, t, n, r, o, a, i) {
        var s = a[a.length - 1];
        !h.isCollectedDistribution(t, s, n) && h.matchIoCSelector(n.selector, r, o, a, i) && (e.push.apply(e, n.blocks), 
        h.noteCollectedDistribution(t, s, n));
    }, h.registerCollectedClearer = function(e, t, n) {
        !e.collectedClearer && t && (e.collectedClearer = function() {
            h.clearCollectedDistributions(t, n);
        });
    }, h.receiveDistributions = function(e, t, n, r) {
        var o = h.getInstantiator(e || r), a = o.getThatStack(e || r);
        a.unshift(h.rootComponent);
        var i = h.getMemberNames(o, a), s = h.transform(a, function(e) {
            return o.idToShadow[e.id];
        }), l = s[s.length - (e ? 1 : 2)], u = h.getMembers(s, "contextHash");
        e ? (i.push(n), u.push(h.gradeNamesToHash(t)), a.push(r)) : h.registerCollectedClearer(s[s.length - 1], l, i[i.length - 1]);
        for (var c = [], d = 0; d < a.length - 1; ++d) h.each(s[d].distributions, function(e) {
            h.collectDistributions(c, l, e, a, u, i, d);
        });
        return c;
    }, h.computeTreeDistance = function(e, t) {
        for (var n = 0; n < e.length && n < t.length && e[n] === t[n]; ) ++n;
        return e.length + t.length - 2 * n;
    }, h.computeDistributionPriority = function(e, t) {
        if (!t.priority) {
            var n = h.getInstantiator(e), r = n.getThatStack(e), o = h.getMemberNames(n, r), a = n.getThatStack(t.contextThat), i = h.getMemberNames(n, a), s = h.computeTreeDistance(o, i);
            t.priority = h.mergeRecordTypes.distribution - s;
        }
        return t;
    }, h.applyDistributions = function(t, e, n) {
        var r = h.transform(e, function(e) {
            return h.generateExpandBlock(e, t, n.mergePolicy);
        }, function(e) {
            return h.computeDistributionPriority(t, e);
        }), o = n.mergeOptions;
        return o.mergeBlocks.push.apply(o.mergeBlocks, r), o.updateBlocks(), r;
    }, h.matchIoCSelector = function(e, t, n, r, o) {
        for (var a = t.length - 1, i = e.length - 1; ;) {
            for (var s = e[i].child, l = a === t.length - 1 || s, u = t[a], c = e[i], d = !0, f = 0; f < c.predList.length; ++f) {
                var p = c.predList[f], m = p.context;
                if (m && "*" !== m && !n[a][m] && r[a] !== m) {
                    d = !1;
                    break;
                }
                if (p.id && u.id !== p.id) {
                    d = !1;
                    break;
                }
            }
            if (0 === i && o < a && l && s && (d = !1), d) {
                if (0 === i) return !0;
                --a, --i;
            } else {
                if (l) return !1;
                --a;
            }
            if (a < o) return !1;
        }
    }, h.queryIoCSelector = function(e, t, n) {
        var r = h.parseSelector(t, h.IoCSSMatcher), o = [];
        return h.visitComponentsForMatching(e, {
            flat: n
        }, function(e, t, n) {
            h.matchIoCSelector(r, t, n, [], 1) && o.push(e);
        }), o;
    }, h.isIoCSSSelector = function(e) {
        return -1 !== e.indexOf(" ");
    }, h.pushDistributions = function(e, t, n, r) {
        var o = h.shadowForComponent(e), a = h.allocateGuid(), i = {
            id: a,
            target: n,
            selector: t,
            blocks: r
        };
        return Object.freeze(i), Object.freeze(i.blocks), h.pushArray(o, "distributions", i), 
        a;
    }, h.clearDistribution = function(e, t) {
        var n = h.globalInstantiator.idToShadow[e];
        n && h.remove_if(n.distributions, function(e) {
            return e.id === t;
        });
    }, h.clearDistributions = function(e) {
        h.each(e.outDistributions, function(e) {
            h.clearDistribution(e.targetHeadId, e.distributionId);
        });
    }, h.extractSelectorHead = function(e) {
        var t = e[0].predList, n = t[0].context;
        return t.length = 0, n;
    }, h.parseExpectedOptionsPath = function(e, t) {
        var n = h.model.parseEL(e);
        return "options" !== n[0] && h.fail("Error in options distribution path ", e, " - only " + t + ' paths beginning with "options" are supported'), 
        n.slice(1);
    }, h.replicateProperty = function(t, n, e) {
        void 0 !== t[n] && h.each(e, function(e) {
            e[n] = t[n];
        });
    }, h.undistributableOptions = [ "gradeNames", "distributeOptions", "argumentMap", "initFunction", "mergePolicy", "progressiveCheckerOptions" ], 
    h.distributeOptions = function(m, e) {
        var g = h.shadowForComponent(m), t = h.driveStrategy(m.options, "distributeOptions", e);
        h.each(t, function(e) {
            h.pushActivity("distributeOptions", "parsing distributeOptions block %record %that ", {
                that: m,
                record: e
            }), "string" != typeof e.target && h.fail("Error in options distribution record ", e, ' a member named "target" must be supplied holding an IoC reference'), 
            "string" == typeof e.source ^ void 0 === e.record && h.fail("Error in options distribution record ", e, ': must supply either a member "source" holding an IoC reference or a member "record" holding a literal record');
            var t, n, r, o = h.parseContextReference(e.target);
            if (h.isIoCSSSelector(o.context)) {
                n = h.parseSelector(o.context, h.IoCSSMatcher);
                var a = h.extractSelectorHead(n);
                "/" === a ? t = h.rootComponent : r = a;
            } else r = o.context;
            (t = t || h.resolveContext(r, m)) || h.fail("Error in options distribution record ", e, " - could not resolve context {" + r + "} to a head component");
            var i, s = h.model.parseEL(o.path);
            if (void 0 !== e.record) i = [ h.makeDistributionRecord(m, e.record, [], s, []) ]; else {
                var l = h.parseContextReference(e.source);
                "that" !== l.context && h.fail("Error in options distribution record ", e, " only a context of {that} is supported");
                var u = h.parseExpectedOptionsPath(l.path, "source"), c = h.makeArray(e.exclusions).concat(0 === u.length ? h.undistributableOptions : []), d = h.transform(c, function(e) {
                    return h.model.parseEL(e);
                });
                i = h.filterBlocks(m, g.mergeOptions.mergeBlocks, u, s, d, e.removeSource), g.mergeOptions.updateBlocks();
            }
            if (h.replicateProperty(e, "priority", i), h.replicateProperty(e, "namespace", i), 
            n) {
                var f = h.pushDistributions(t, n, e.target, i);
                g.outDistributions = g.outDistributions || [], g.outDistributions.push({
                    targetHeadId: t.id,
                    distributionId: f
                });
            } else {
                var p = h.shadowForComponent(t);
                h.applyDistributions(m, i, p);
            }
            h.popActivity();
        });
    }, h.gradeNamesToHash = function(e) {
        var t = {};
        return h.each(e, function(e) {
            t[e] = !0, t[h.computeNickName(e)] = !0;
        }), t;
    }, h.cacheShadowGrades = function(n, r) {
        var e = h.gradeNamesToHash(n.options.gradeNames);
        e[r.memberName] || (e[r.memberName] = "memberName"), r.contextHash = e, h.each(e, function(e, t) {
            r.ownScope[t] = n, r.parentShadow && "fluid.rootComponent" !== r.parentShadow.that.type && (r.parentShadow.childrenScope[t] = n);
        });
    }, h.deliverOptionsStrategy = function(e, t, n) {
        var r = h.shadowForComponent(e, r);
        h.cacheShadowGrades(e, r), r.mergeOptions = n;
    }, h.collectDistributedGrades = function(e) {
        var t = h.receiveDistributions(null, null, null, e.that);
        if (0 < t.length) {
            var n = h.applyDistributions(e.that, t, e.shadow), r = h.transform(h.getMembers(n, [ "source", "gradeNames" ]), h.makeArray);
            h.accumulateDynamicGrades(e, h.flatten(r));
        }
    }, h.applyDynamicGrades = function(t) {
        t.oldGradeNames = h.makeArray(t.gradeNames);
        var e = h.copy(h.getMergedDefaults(t.that.typeName, t.gradeNames));
        t.gradeNames.length = 0, t.gradeNames.push.apply(t.gradeNames, e.gradeNames), h.each(t.gradeNames, function(e) {
            h.isIoCReference(e) || (t.seenGrades[e] = !0);
        });
        var n = t.shadow;
        h.cacheShadowGrades(t.that, n), n.mergeOptions.destroyValue([ "mergePolicy" ]), 
        n.mergeOptions.destroyValue([ "components" ]), n.mergeOptions.destroyValue([ "invokers" ]), 
        t.defaultsBlock.source = e, n.mergeOptions.updateBlocks(), n.mergeOptions.computeMergePolicy(), 
        h.accumulateDynamicGrades(t, e.gradeNames);
    }, h.accumulateDynamicGrades = function(t, e) {
        h.each(e, function(e) {
            t.seenGrades[e] || (h.isIoCReference(e) ? (t.rawDynamic.push(e), t.seenGrades[e] = !0) : h.contains(t.oldGradeNames, e) || t.plainDynamic.push(e));
        });
    }, h.computeDynamicGrades = function(e, t, n) {
        delete e.options.gradeNames;
        var r = h.driveStrategy(e.options, "gradeNames", n);
        r.length = 0;
        var o = {
            that: e,
            shadow: t,
            defaultsBlock: h.findMergeBlocks(t.mergeOptions.mergeBlocks, "defaults")[0],
            gradeNames: r,
            seenGrades: {},
            plainDynamic: [],
            rawDynamic: []
        };
        for (h.each(t.mergeOptions.mergeBlocks, function(e) {
            r.push.apply(r, h.makeArray(e.target && e.target.gradeNames)), h.applyDynamicGrades(o);
        }), h.collectDistributedGrades(o); ;) {
            for (;0 < o.plainDynamic.length; ) r.push.apply(r, o.plainDynamic), o.plainDynamic.length = 0, 
            h.applyDynamicGrades(o), h.collectDistributedGrades(o);
            if (!(0 < o.rawDynamic.length)) break;
            var a = h.expandImmediate(o.rawDynamic.shift(), e, t.localDynamic);
            "function" == typeof a && (a = a()), a && (o.plainDynamic = o.plainDynamic.concat(a));
        }
        t.collectedClearer && (t.collectedClearer(), delete t.collectedClearer);
    }, h.computeDynamicComponentKey = function(e, t) {
        return e + (0 === t ? "" : "-" + t);
    }, h.hasDynamicComponentCount = function(e, t) {
        var n = t.indexOf("-");
        if (-1 !== n) {
            var r = t.substring(0, n);
            return void 0 !== e.dynamicComponentCount && void 0 !== e.dynamicComponentCount[r];
        }
    }, h.clearDynamicParentRecord = function(e, t) {
        if (h.hasDynamicComponentCount(e, t)) {
            var n = h.get(e.that, [ "options", "components" ]);
            n && delete n[t];
        }
    }, h.registerDynamicRecord = function(e, t, n, r, o) {
        var a = h.computeDynamicComponentKey(t, n), i = h.copy(r);
        return delete i[o], h.set(e.options, [ "components", a ], i), a;
    }, h.computeDynamicComponents = function(a, e) {
        var i = h.shadowForComponent(a), s = i.subcomponentLocal = {}, t = h.driveStrategy(a.options, "dynamicComponents", e.strategy);
        h.each(t, function(r, o) {
            if (r.sources || r.createOnEvent || h.fail("Cannot process dynamicComponents record ", r, ' without a "sources" or "createOnEvent" entry'), 
            r.sources) {
                var e = h.expandOptions(r.sources, a);
                h.each(e, function(e, t) {
                    var n = h.registerDynamicRecord(a, o, t, r, "sources");
                    s[n] = {
                        source: e,
                        sourcePath: t
                    };
                });
            } else if (r.createOnEvent) {
                var t = h.event.expandOneEvent(a, r.createOnEvent);
                h.set(i, [ "dynamicComponentCount", o ], 0);
                var n = function() {
                    var e = h.registerDynamicRecord(a, o, i.dynamicComponentCount[o]++, r, "createOnEvent"), t = {
                        arguments: h.makeArray(arguments)
                    };
                    h.initDependent(a, e, t);
                };
                t.addListener(n), h.recordListener(t, n, i);
            }
        });
    }, h.computeComponentAccessor = function(e, t) {
        var n = h.globalInstantiator, r = h.shadowForComponent(e);
        r.localDynamic = t;
        var o = e.options, a = r.mergeOptions.strategy, i = h.mountStrategy([ "options" ], o, a);
        r.invokerStrategy = h.recordStrategy(e, o, a, "invokers", h.invokerFromRecord), 
        r.eventStrategyBlock = h.recordStrategy(e, o, a, "events", h.eventFromRecord, [ "events" ]);
        var s = h.mountStrategy([ "events" ], e, r.eventStrategyBlock.strategy, [ "events" ]);
        if (r.memberStrategy = h.recordStrategy(e, o, a, "members", h.memberFromRecord, null, {
            model: !0,
            modelRelay: !0
        }), r.getConfig = {
            strategies: [ h.model.funcResolverStrategy, h.makeGingerStrategy(e), i, r.invokerStrategy.strategy, r.memberStrategy.strategy, s ]
        }, h.computeDynamicGrades(e, r, a, r.mergeOptions.mergeBlocks), h.distributeOptions(e, a), 
        r.contextHash["fluid.resolveRoot"]) {
            var l;
            if (r.contextHash["fluid.resolveRootSingle"]) {
                var u = h.getForComponent(e, [ "options", "singleRootType" ]);
                u || h.fail("Cannot register object with grades " + Object.keys(r.contextHash).join(", ") + " as fluid.resolveRootSingle since it has not defined option singleRootType"), 
                l = h.typeNameToMemberName(u);
            } else l = h.computeGlobalMemberName(e);
            var c = h.resolveRootComponent;
            c[l] && n.clearComponent(c, l), n.recordKnownComponent(c, e, l, !1);
        }
        return r.getConfig;
    }, h.shadowForComponent = function(e) {
        var t = h.getInstantiator(e);
        return t && e ? t.idToShadow[e.id] : null;
    }, h.getForComponent = function(e, t) {
        var n = h.shadowForComponent(e), r = n ? n.getConfig : void 0;
        return h.get(e, t, r);
    }, h.makeGingerStrategy = function(e) {
        var l = h.getInstantiator(e);
        return function(e, t, n, r) {
            var o = e[t];
            if (o === h.inEvaluationMarker && n === r.length && h.fail('Error in component configuration - a circular reference was found during evaluation of path segment "' + t + '": for more details, see the activity records following this message in the console, or issue fluid.setLogging(fluid.logLevel.TRACE) when running your application'), 
            1 < n) return o;
            if (void 0 === o && e.hasOwnProperty(t)) return h.NO_VALUE;
            if (void 0 === o) {
                var a = l.idToShadow[e.id].path, i = l.composePath(a, t);
                o = l.pathToComponent[i];
            }
            if (void 0 === o) {
                var s = h.getForComponent(e, [ "options", "components", t ]);
                s && (s.createOnEvent && h.fail('Error resolving path segment "' + t + '" of path ' + r.join(".") + " since component with record ", s, ' has annotation "createOnEvent" - this very likely represents an implementation error. Either alter the reference so it does not  match this component, or alter your workflow to ensure that the component is instantiated by the time this reference resolves'), 
                h.initDependent(e, t), o = e[t]);
            }
            return o;
        };
    }, h.frameworkGrades = [ "fluid.component", "fluid.modelComponent", "fluid.viewComponent", "fluid.rendererComponent" ], 
    h.filterBuiltinGrades = function(e) {
        return h.remove_if(h.makeArray(e), function(e) {
            return -1 !== h.frameworkGrades.indexOf(e);
        });
    }, h.dumpGradeNames = function(e) {
        return e.options && e.options.gradeNames ? " gradeNames: " + JSON.stringify(h.filterBuiltinGrades(e.options.gradeNames)) : "";
    }, h.dumpThat = function(e) {
        return '{ typeName: "' + e.typeName + '"' + h.dumpGradeNames(e) + " id: " + e.id + "}";
    }, h.dumpThatStack = function(e, n) {
        return h.transform(e, function(e) {
            var t = n.idToPath(e.id);
            return h.dumpThat(e) + (t ? " - path: " + t : "");
        }).join("\n");
    }, h.dumpComponentPath = function(e) {
        var t = h.pathForComponent(e);
        return t ? h.pathUtil.composeSegments(t) : "** no path registered for component **";
    }, h.resolveContext = function(r, e, t) {
        if ("that" === r) return e;
        if ("object" == typeof r) {
            var n = h.resolveContext(r.context, e, t);
            h.isComponent(n) || h.triggerMismatchedPathError(r.context, e);
            var o = h.getForComponent(n, r.path), a = h.expandOptions(o, e);
            return h.isComponent(a) || h.fail("Unable to resolve recursive context expression " + h.renderContextReference(r) + ": the directly resolved value of " + o + " did not resolve to a component in the scope of component ", e, ": got ", a), 
            a;
        }
        var i, s = h.globalInstantiator;
        if (t) return s.idToShadow[e.id].ownScope[r];
        var l = s.getFullStack(e);
        return h.visitComponentsForVisibility(s, l, function(e, t) {
            var n = h.shadowForComponent(e);
            return r === t || n && n.contextHash && n.contextHash[r] || r === e.typeName ? (i = e, 
            !0) : h.getForComponent(e, [ "options", "components", r ]) && !e[r] ? (i = h.getForComponent(e, r), 
            !0) : void 0;
        }), i;
    }, h.triggerMismatchedPathError = function(e, t) {
        var n = h.renderContextReference(e);
        h.fail("Failed to resolve reference " + n + " - could not match context with name " + e.context + " from component " + h.dumpThat(t) + " at path " + h.dumpComponentPath(t) + " component: ", t);
    }, h.makeStackFetcher = function(r, o, a) {
        return function(e) {
            r && "destroyed" === r.lifecycleStatus && h.fail("Cannot resolve reference " + h.renderContextReference(e) + " from component " + h.dumpThat(r) + " which has been destroyed");
            var t = e.context;
            if (o && t in o) return h.get(o[t], e.path);
            var n = h.resolveContext(t, r, a);
            return n || "" === e.path || h.triggerMismatchedPathError(e, r), h.getForComponent(n, e.path);
        };
    }, h.makeStackResolverOptions = function(e, t, n) {
        return d.extend(h.copy(h.rawDefaults("fluid.makeExpandOptions")), {
            localRecord: t || {},
            fetcher: h.makeStackFetcher(e, t, n),
            contextThat: e,
            exceptions: {
                members: {
                    model: !0,
                    modelRelay: !0
                }
            }
        });
    }, h.clearListeners = function(e) {
        h.each(e.listeners, function(e) {
            e.event.removeListener(e.listenerId || e.listener);
        }), delete e.listeners;
    }, h.recordListener = function(e, t, n, r) {
        e.ownerId !== n.that.id && h.pushArray(n, "listeners", {
            event: e,
            listener: t,
            listenerId: r
        });
    }, h.constructScopeObjects = function(e, t, n, r) {
        var o = t ? e.idToShadow[t.id] : null;
        r.childrenScope = o ? Object.create(o.ownScope) : {}, r.ownScope = Object.create(r.childrenScope), 
        r.parentShadow = o;
    }, h.clearChildrenScope = function(e, n, r, t) {
        h.each(t.contextHash, function(e, t) {
            n.childrenScope[t] === r && delete n.childrenScope[t];
        });
    }, h.instantiator = function() {
        var c = h.typeTag("instantiator");
        function i(e, t, n, r, o) {
            var a;
            if (o) (a = c.idToShadow[t.id] = {}).that = t, a.path = n, a.memberName = r, h.constructScopeObjects(c, e, t, a); else {
                (a = c.idToShadow[t.id]).injectedPaths = a.injectedPaths || {}, a.injectedPaths[n] = !0;
                var i = c.idToShadow[e.id], s = h.keys(a.contextHash);
                h.remove_if(s, function(e) {
                    return a.contextHash && "memberName" === a.contextHash[e];
                }), s.push(r), h.each(s, function(e) {
                    i.childrenScope[e] || (i.childrenScope[e] = t);
                });
            }
            c.pathToComponent[n] && h.fail("Error during instantiation - path " + n + " which has just created component " + h.dumpThat(t) + " has already been used for component " + h.dumpThat(c.pathToComponent[n]) + " - this is a circular instantiation or other oversight. Please clear the component using instantiator.clearComponent() before reusing the path."), 
            c.pathToComponent[n] = t;
        }
        return d.extend(c, {
            lifecycleStatus: "constructed",
            pathToComponent: {},
            idToShadow: {},
            modelTransactions: {
                init: {}
            },
            composePath: h.model.composePath,
            composeSegments: h.model.composeSegments,
            parseEL: h.model.parseEL,
            events: {
                onComponentAttach: h.makeEventFirer({
                    name: "instantiator's onComponentAttach event"
                }),
                onComponentClear: h.makeEventFirer({
                    name: "instantiator's onComponentClear event"
                })
            }
        }), c.idToPath = function(e) {
            var t = c.idToShadow[e];
            return t ? t.path : "";
        }, c.getThatStack = function(e) {
            var t = c.idToShadow[e.id];
            if (t) {
                for (var n = t.path, r = c.parseEL(n), o = c.pathToComponent[""], a = [], i = 0; i < r.length; ++i) o = o[r[i]], 
                a.push(o);
                return a;
            }
            return [];
        }, c.getFullStack = function(e) {
            var t = e ? c.getThatStack(e) : [];
            return t.unshift(h.resolveRootComponent), t;
        }, c.recordRoot = function(e) {
            i(null, e, "", "", !0);
        }, c.recordKnownComponent = function(e, t, n, r) {
            if (e[n] = t, h.isComponent(t) || "instantiator" === t.type) {
                var o = c.idToShadow[e.id].path, a = c.composePath(o, n);
                i(e, t, a, n, r), c.events.onComponentAttach.fire(t, a, c, r);
            } else h.fail("Cannot record non-component with value ", t, ' at path "' + n + '" of parent ', e);
        }, c.clearConcreteComponent = function(o) {
            h.each(o.childShadow.injectedPaths, function(e, t) {
                var n = h.model.getToTailPath(t), r = c.pathToComponent[n];
                c.clearComponent(r, h.model.getTailPath(t), o.child);
            }), h.clearDistributions(o.childShadow), h.clearListeners(o.childShadow), h.clearDynamicParentRecord(o.shadow, o.name), 
            h.fireEvent(o.child, "afterDestroy", [ o.child, o.name, o.component ]), delete c.idToShadow[o.child.id];
        }, c.clearComponent = function(e, t, a, i, n, r) {
            var o = c.idToShadow[e.id];
            i = i || {
                flat: !0,
                instantiator: c,
                destroyRecs: []
            }, a = a || e[t], void 0 === (r = r || o.path) && h.fail("Cannot clear component " + t + " from component ", e, " which was not created by this instantiator");
            var s = c.composePath(r, t), l = c.idToShadow[a.id];
            if (l) {
                var u = l.path === s;
                c.events.onComponentClear.fire(a, s, e, u), u ? (h.visitComponentChildren(a, function(e, t, n, r) {
                    var o = c.composeSegments.apply(null, n.slice(0, r));
                    c.clearComponent(a, t, null, i, !0, o);
                }, i, c.parseEL(s)), h.doDestroy(a, t, e), i.destroyRecs.push({
                    child: a,
                    childShadow: l,
                    name: t,
                    component: e,
                    shadow: o
                })) : h.remove_if(l.injectedPaths, function(e, t) {
                    return t === s;
                }), h.clearChildrenScope(c, o, a, l), delete c.pathToComponent[s], n || (delete e[t], 
                h.each(i.destroyRecs, c.clearConcreteComponent));
            }
        }, c;
    }, h.globalInstantiator = h.instantiator(), h.getInstantiator = function(e) {
        var t = h.globalInstantiator;
        return e && t.idToShadow[e.id] ? t : null;
    }, h.defaults("fluid.resolveRoot"), h.defaults("fluid.resolveRootSingle", {
        gradeNames: "fluid.resolveRoot"
    }), h.constructRootComponents = function(e) {
        h.rootComponent = e.rootComponent = h.typeTag("fluid.rootComponent"), e.recordRoot(h.rootComponent), 
        h.resolveRootComponent = e.resolveRootComponent = h.typeTag("fluid.resolveRootComponent"), 
        e.recordKnownComponent(h.rootComponent, h.resolveRootComponent, "resolveRootComponent", !0);
        var t = e.idToShadow[h.rootComponent.id];
        t.contextHash = {};
        var n = e.idToShadow[h.resolveRootComponent.id];
        n.ownScope = t.ownScope, n.childrenScope = t.childrenScope, e.recordKnownComponent(h.resolveRootComponent, e, "instantiator", !0), 
        n.childrenScope.instantiator = e;
    }, h.constructRootComponents(h.globalInstantiator), h.expandOptions = function(e, t, n, r, o) {
        if (!e) return e;
        h.pushActivity("expandOptions", "expanding options %args for component %that ", {
            that: t,
            args: e
        });
        var a = h.makeStackResolverOptions(t, r);
        a.mergePolicy = n, a.defer = o && o.defer;
        var i = a.defer ? h.makeExpandOptions(e, a) : h.expand(e, a);
        return h.popActivity(), i;
    }, h.localRecordExpected = h.arrayToHash([ "type", "options", "container", "createOnEvent", "priority", "recordType" ]), 
    h.checkComponentRecord = function(n) {
        h.each(n, function(e, t) {
            h.localRecordExpected[t] || h.fail("Probable error in subcomponent record ", n, ' - key "' + t + '" found, where the only legal options are ' + h.keys(h.localRecordExpected).join(", "));
        });
    }, h.mergeRecordsToList = function(n, e) {
        var r = [];
        return h.each(e, function(e, t) {
            if ("distributions" === (e.recordType = t)) r.push.apply(r, h.transform(e, function(e) {
                return h.computeDistributionPriority(n, e);
            })); else {
                if (!e.options) return;
                e.priority = h.mergeRecordTypes[t], void 0 === e.priority && h.fail("Merge record with unrecognised type " + t + ": ", e), 
                r.push(e);
            }
        }), r;
    };
    h.generateExpandBlock = function(e, t, n, r) {
        var o = h.expandOptions(e.options, e.contextThat || t, n, r, {
            defer: !0
        });
        return o.priority = e.priority, o.namespace = e.namespace, o.recordType = e.recordType, 
        o;
    };
    function s(t, e, n, r) {
        var o = h.copy(e);
        !function(t) {
            h.each([ "gradeNames", "mergePolicy", "argumentMap", "components", "dynamicComponents", "events", "listeners", "modelListeners", "modelRelay", "distributeOptions", "transformOptions" ], function(e) {
                h.set(t, [ e, "*", "noexpand" ], !0);
            });
        }(t), h.shadowForComponent(r).mergePolicy = t;
        var a = {
            defaults: {
                options: o
            }
        };
        d.extend(a, n.mergeRecords), a.subcomponentRecord && h.checkComponentRecord(a.subcomponentRecord);
        var i = h.mergeRecordsToList(r, a);
        return h.transform(i, function(e) {
            return h.generateExpandBlock(e, r, t, n.localRecord);
        });
    }
    h.fabricateDestroyMethod = function(e, t, n, r) {
        return function() {
            n.clearComponent(e, t, r);
        };
    }, h.computeGlobalMemberName = function(e) {
        return h.computeNickName(e.typeName) + "-" + e.id;
    }, h.typeNameToMemberName = function(e) {
        return e.replace(/\./g, "_");
    }, h.expandComponentOptions = function(e, t, n, r) {
        var o = n, a = n && n.marker === h.EXPAND ? n.instantiator : null;
        h.pushActivity("expandComponentOptions", "expanding component options %options with record %record for component %that", {
            options: a ? n.mergeRecords.user : n,
            record: o,
            that: r
        }), a || (a = h.globalInstantiator, o = {
            mergeRecords: {
                user: {
                    options: h.expandCompact(n, !0)
                }
            },
            memberName: h.computeGlobalMemberName(r),
            instantiator: a,
            parentThat: h.rootComponent
        }), r.destroy = h.fabricateDestroyMethod(o.parentThat, o.memberName, a, r), a.recordKnownComponent(o.parentThat, r, o.memberName, !0);
        var i = s(e, t, o, r);
        return h.popActivity(), i;
    }, h.assembleCreatorArguments = function(o, e, a) {
        var t = h.defaults(e);
        t && t.argumentMap || h.fail("Error in assembleCreatorArguments: cannot look up component type name " + e + " to a component creator grade with an argumentMap");
        var n = o ? h.receiveDistributions(o, t.gradeNames, a.memberName, {}) : [];
        h.each(n, function(e) {
            h.computeDistributionPriority(o, e), h.isPrimitive(e.priority) && (e.priority = h.parsePriority(e.priority, 0, !1, "options distribution"));
        }), h.sortByPriority(n);
        var i = a.localDynamic, s = d.extend({}, h.censorKeys(a.componentRecord, [ "type" ]), i), r = t.argumentMap, l = Object.keys(r).concat([ "type" ]);
        h.each(l, function(e) {
            for (var t = 0; t < n.length; ++t) void 0 !== n[t][e] && (s[e] = n[t][e]);
        }), e = s.type || e, delete s.type, delete s.options;
        var u = {
            distributions: n
        };
        void 0 !== a.componentRecord && (u.subcomponentRecord = d.extend({}, a.componentRecord));
        var c = [];
        return h.each(r, function(e, t) {
            var n;
            if ("options" === t) n = {
                marker: h.EXPAND,
                localRecord: i,
                mergeRecords: u,
                instantiator: h.getInstantiator(o),
                parentThat: o,
                memberName: a.memberName
            }; else {
                var r = s[t];
                n = h.expandImmediate(r, o, s);
            }
            c[e] = n;
        }), {
            args: c,
            funcName: e
        };
    }, h.initDependent = function(e, t, n) {
        if (!e[t]) {
            var r, o = e.options.components[t], a = h.globalInstantiator, i = a.idToShadow[e.id], s = n || i.subcomponentLocal && i.subcomponentLocal[t];
            if (h.pushActivity("initDependent", 'instantiating dependent component at path "%path" with record %record as child of %parent', {
                path: i.path + "." + t,
                record: o,
                parent: e
            }), "string" == typeof o || o.expander) e[t] = h.inEvaluationMarker, (r = h.expandImmediate(o, e)) ? a.recordKnownComponent(e, r, t, !1) : delete e[t]; else if (o.type) {
                var l = h.expandImmediate(o.type, e, s);
                l || h.fail("Error in subcomponent record: ", o.type, " could not be resolved to a type for component ", t, " of parent ", e);
                var u = h.assembleCreatorArguments(e, l, {
                    componentRecord: o,
                    memberName: t,
                    localDynamic: s
                });
                r = h.initSubcomponentImpl(e, {
                    type: u.funcName
                }, u.args);
            } else h.fail("Unrecognised material in place of subcomponent " + t + ' - no "type" field found');
            return h.popActivity(), r;
        }
    }, h.bindDeferredComponent = function(n, r, o) {
        var e = h.makeArray(o.createOnEvent);
        h.each(e, function(t) {
            var e = h.isIoCReference(t) ? h.expandOptions(t, n) : n.events[t];
            e && e.addListener || h.fail("Error instantiating createOnEvent component with name " + r + " of parent ", n, " since event specification " + t + " could not be expanded to an event - got ", e), 
            e.addListener(function() {
                h.pushActivity("initDeferred", "instantiating deferred component %componentName of parent %that due to event %eventName", {
                    componentName: r,
                    that: n,
                    eventName: t
                }), n[r] && h.globalInstantiator.clearComponent(n, r);
                var e = {
                    arguments: h.makeArray(arguments)
                };
                h.initDependent(n, r, e), h.popActivity();
            }, null, o.priority);
        });
    }, h.priorityForComponent = function(e) {
        return e.priority ? e.priority : "fluid.typeFount" === e.type || h.hasGrade(h.defaults(e.type), "fluid.typeFount") ? "first" : void 0;
    }, h.initDependents = function(r) {
        h.pushActivity("initDependents", "instantiating dependent components for component %that", {
            that: r
        });
        var e = h.shadowForComponent(r);
        if (e.memberStrategy.initter(), e.invokerStrategy.initter(), h.getForComponent(r, "modelRelay"), 
        h.getForComponent(r, "model"), !h.isDestroyed(r)) {
            var t = r.options.components || {}, o = [];
            h.each(t, function(e, t) {
                if (e.createOnEvent) h.bindDeferredComponent(r, t, e); else {
                    var n = h.priorityForComponent(e);
                    o.push({
                        namespace: t,
                        priority: h.parsePriority(n)
                    });
                }
            }), h.sortByPriority(o), h.each(o, function(e) {
                h.initDependent(r, e.namespace);
            }), e.subcomponentLocal && h.clear(e.subcomponentLocal), r.lifecycleStatus = "constructed", 
            h.assessTreeConstruction(r, e), h.popActivity();
        }
    }, h.assessTreeConstruction = function(e, t) {
        var n = h.globalInstantiator, r = n.getThatStack(e);
        h.find_if(r, function(e) {
            return "constructing" === e.lifecycleStatus;
        }) ? e.lifecycleStatus = "constructed" : h.markSubtree(n, e, t.path, "treeConstructed");
    }, h.markSubtree = function(o, e, a, i) {
        e.lifecycleStatus = i, h.visitComponentChildren(e, function(e, t) {
            var n = o.composePath(a, t), r = o.idToShadow[e.id];
            r && r.path === n && h.markSubtree(o, e, n, i);
        }, {
            flat: !0
        });
    }, h.pathForComponent = function(e, t) {
        var n = (t = t || h.getInstantiator(e) || h.globalInstantiator).idToShadow[e.id];
        return n ? t.parseEL(n.path) : null;
    }, h.construct = function(e, t, n) {
        var r = h.destroy(e, n);
        return h.set(r.parent, [ "options", "components", r.memberName ], {
            type: t.type,
            options: t
        }), h.initDependent(r.parent, r.memberName);
    }, h.destroy = function(e, t) {
        t = t || h.globalInstantiator;
        var n = h.model.parseToSegments(e, t.parseEL, !0);
        0 === n.length && h.fail("Cannot destroy the root component");
        var r = n.pop(), o = t.composeSegments.apply(null, n), a = t.pathToComponent[o];
        return a || h.fail("Cannot modify component with nonexistent parent at path ", e), 
        a[r] && a[r].destroy(), {
            parent: a,
            memberName: r
        };
    }, h.constructSingle = function(e, t, n) {
        n = n || h.globalInstantiator, e = e || "";
        var r = h.model.parseToSegments(e, n.parseEL, !0);
        "string" == typeof t && (t = {
            type: t
        });
        var o = t.type;
        o || h.fail("Cannot construct singleton object without a type entry");
        var a = (t = d.extend({}, t)).gradeNames = h.makeArray(t.gradeNames);
        a.unshift(o), t.type = "fluid.component", 0 === r.length && a.push("fluid.resolveRoot");
        var i = h.typeNameToMemberName(t.singleRootType || o);
        r.push(i), h.construct(r, t, n);
    }, h.destroySingle = function(e, t, n) {
        n = n || h.globalInstantiator;
        var r = h.model.parseToSegments(e, n.parseEL, !0), o = h.typeNameToMemberName(t);
        r.push(o), h.destroy(r, n);
    }, h.makeGradeLinkage = function(e, t, n) {
        h.defaults(e, {
            gradeNames: "fluid.component",
            distributeOptions: {
                record: n,
                target: "{/ " + t.join("&") + "}.options.gradeNames"
            }
        }), h.constructSingle([], e);
    }, h.componentForPath = function(e) {
        return h.globalInstantiator.pathToComponent[h.isArrayable(e) ? e.join(".") : e];
    }, h.debugger = function() {}, h.defaults("fluid.debuggingProbe", {
        gradeNames: [ "fluid.component" ]
    }), h.probeToDistribution = function(e) {
        var t = h.globalInstantiator, n = h.parseContextReference(e.target), r = h.model.parseToSegments(n.path, t.parseEL, !0);
        "options" !== r[0] && r.unshift("options");
        var o = h.parsePriority(e.priority);
        return o.constraint && !o.constraint.target && (o.constraint.target = "authoring"), 
        {
            target: "{/ " + n.context + "}." + t.composeSegments.apply(null, r),
            record: {
                func: e.func,
                funcName: e.funcName,
                args: e.args,
                priority: h.renderPriority(o)
            }
        };
    }, h.registerProbes = function(e) {
        var t = h.transform(e, h.probeToDistribution), n = "fluid_debuggingProbe_" + h.allocateGuid();
        return h.construct([ n ], {
            type: "fluid.debuggingProbe",
            distributeOptions: t
        }), n;
    }, h.deregisterProbes = function(e) {
        h.destroy([ e ]);
    }, h.thisistToApplicable = function(o, a, i) {
        return {
            apply: function(e, t) {
                var n = h.expandOptions(a, i);
                "string" == typeof n && (n = h.getGlobalValue(n)), n || h.fail("Could not resolve reference " + a + " to a value");
                var r = n[o.method];
                return "function" != typeof r && h.fail("Object ", n, " at reference " + a + " has no member named " + o.method + " which is a function "), 
                h.passLogLevel(h.logLevel.TRACE) && h.log(h.logLevel.TRACE, "Applying arguments ", t, " to method " + o.method + " of instance ", n), 
                r.apply(n, t);
            }
        };
    }, h.changeToApplicable = function(s, l) {
        return {
            apply: function(e, t, n, r) {
                var o = h.parseValidModelReference(l, "changePath listener record", s.changePath), a = h.expandOptions(s.value, l, {}, h.extend(n, {
                    arguments: t
                })), i = r && r.source && r.source.length ? h.makeArray(s.source).concat(r.source) : s.source;
                o.applier.change(o.modelSegs, a, s.type, i);
            }
        };
    }, h.recordToApplicable = function(e, t, n) {
        if (void 0 !== e.changePath) return h.changeToApplicable(e, t, n);
        var r = e.this;
        return e.method ^ r && h.fail("Record ", t, ' must contain both entries "method" and "this" if it contains either'), 
        e.method ? h.thisistToApplicable(e, r, t) : null;
    }, h.getGlobalValueNonComponent = function(e, t) {
        var n = h.defaults(e);
        return n && h.hasGrade(n, "fluid.component") && h.fail("Error in function specification - cannot invoke function " + e + " in the context of " + t + ": component creator functions can only be used as subcomponents"), 
        h.getGlobalValue(e);
    }, h.makeInvoker = function(n, r, o) {
        void 0 === (r = h.upgradePrimitiveFunc(r)).args || r.args === h.NO_VALUE || h.isArrayable(r.args) || (r.args = h.makeArray(r.args));
        var a = h.recordToApplicable(r, n), i = h.preExpand(r.args), s = {}, l = h.makeStackResolverOptions(n, s, !0);
        return (a = a || (r.funcName ? h.getGlobalValueNonComponent(r.funcName, "an invoker") : h.expandImmediate(r.func, n))) && a.apply ? a === h.notImplemented && h.fail("Error constructing component ", n, " - the invoker named " + o + " which was defined in grade " + r.componentSource + " needs to be overridden with a concrete implementation") : h.fail("Error in invoker record: could not resolve members func, funcName or method to a function implementation - got " + a + " from ", r), 
        function() {
            var e, t;
            return !1 === h.defeatLogging && h.pushActivity("invokeInvoker", "invoking invoker with name %name and record %record from path %path holding component %that", {
                name: o,
                record: r,
                path: h.dumpComponentPath(n),
                that: n
            }), "destroyed" === n.lifecycleStatus ? h.log(h.logLevel.WARN, "Ignoring call to invoker " + o + " of component ", n, " which has been destroyed") : (s.arguments = arguments, 
            t = void 0 === r.args || r.args === h.NO_VALUE ? arguments : (h.expandImmediateImpl(i, l), 
            i.source), e = a.apply(null, t)), !1 === h.defeatLogging && h.popActivity(), e;
        };
    }, h.event.makeTrackedListenerAdder = function(e) {
        var i = h.shadowForComponent(e);
        return function(a) {
            return {
                addListener: function(e, t, n, r, o) {
                    h.recordListener(a, e, i, o), a.addListener.apply(null, arguments);
                }
            };
        };
    }, h.event.listenerEngine = function(n, r, o) {
        var a = {};
        h.each(n, function(e, t) {
            o(e).addListener(function() {
                a[t] = h.makeArray(arguments), function() {
                    if (!h.find(n, function(e, t) {
                        if (void 0 === a[t]) return !0;
                    })) {
                        var e = a;
                        a = {}, r(e);
                    }
                }();
            });
        });
    }, h.event.dispatchListener = function(r, o, a, i, s) {
        void 0 === i.args || i.args === h.NO_VALUE || h.isArrayable(i.args) || (i.args = h.makeArray(i.args)), 
        o = h.event.resolveListener(o);
        function e() {
            !1 === h.defeatLogging && h.pushActivity("dispatchListener", "firing to listener to event named %eventName of component %that", {
                eventName: a,
                that: r
            });
            var e, t = s ? arguments[0] : arguments;
            u.arguments = t, e = void 0 !== i.args && i.args !== h.NO_VALUE ? (h.expandImmediateImpl(l, c), 
            l.source) : t;
            var n = o.apply(null, e);
            return !1 === h.defeatLogging && h.popActivity(), n;
        }
        var l = h.preExpand(i.args), u = {}, c = h.makeStackResolverOptions(r, u, !0);
        return h.event.impersonateListener(o, e), e;
    }, h.event.resolveSoftNamespace = function(e) {
        if ("string" != typeof e) return null;
        var t = Math.max(e.lastIndexOf("."), e.lastIndexOf("}"));
        return e.substring(t + 1);
    }, h.event.resolveListenerRecord = function(e, i, s, l, u) {
        function c(e, t) {
            h.fail("Error in listener record - could not resolve reference ", e, ' to a listener or firer. Did you miss out "events." when referring to an event firer?' + t);
        }
        h.pushActivity("resolveListenerRecord", "resolving listener record for event named %eventName for component %that", {
            eventName: s,
            that: i
        });
        var t = h.makeArray(e), n = {
            records: h.transform(t, function(e) {
                var t = h.isPrimitive(e) || e.expander ? {
                    listener: e
                } : h.copy(e), n = h.recordToApplicable(e, i, u);
                t.listener = n || (t.listener || t.func || t.funcName), t.listener || c(e, ' Listener record must contain a member named "listener", "func", "funcName" or "method"');
                var r = e.method ? h.event.resolveSoftNamespace(e.this) + "." + e.method : h.event.resolveSoftNamespace(t.listener);
                t.namespace || l || !r || (t.softNamespace = !0, t.namespace = (e.componentSource ? e.componentSource : i.typeName) + "." + r);
                var o = t.listener = h.expandOptions(t.listener, i);
                o || c(e, "");
                var a = !1;
                return "fluid.event.firer" === o.typeName && (o = o.fire, a = !0), t.listener = u && (t.args && "fluid.notImplemented" !== o || a) ? h.event.dispatchListener(i, o, s, t) : o, 
                t.listenerId = h.allocateGuid(), t;
            }),
            adderWrapper: u ? h.event.makeTrackedListenerAdder(i) : null
        };
        return h.popActivity(), n;
    }, h.event.expandOneEvent = function(e, t) {
        var n;
        return (n = "string" == typeof t && "{" !== t.charAt(0) ? h.getForComponent(e, [ "events", t ]) : h.expandOptions(t, e)) && "fluid.event.firer" === n.typeName || h.fail("Error in event specification - could not resolve base event reference ", t, " to an event firer: got ", n), 
        n;
    }, h.event.expandEvents = function(t, e) {
        return "string" == typeof e ? h.event.expandOneEvent(t, e) : h.transform(e, function(e) {
            return h.event.expandOneEvent(t, e);
        });
    }, h.event.resolveEvent = function(i, s, l) {
        h.pushActivity("resolveEvent", "resolving event with name %eventName attached to component %that", {
            eventName: s,
            that: i
        });
        var u = h.event.makeTrackedListenerAdder(i);
        "string" == typeof l && (l = {
            event: l
        });
        var e = "fluid.event.firer" === l.typeName ? l : l.event || l.events;
        e || h.fail("Event specification for event with name " + s + " does not include a base event specification: ", l);
        var t, c = "fluid.event.firer" === e.typeName ? e : h.event.expandEvents(i, e), n = "fluid.event.firer" !== c.typeName;
        if (l.args || n) {
            t = h.makeEventFirer({
                name: " [composite] " + h.event.nameEvent(i, s)
            });
            var r = h.event.dispatchListener(i, t.fire, s, l, n);
            n ? h.event.listenerEngine(c, r, u) : u(c).addListener(r);
        } else (t = {
            typeName: "fluid.event.firer",
            fire: function() {
                var e = h.makeArray(arguments);
                h.pushActivity("fireSynthetic", "firing synthetic event %eventName ", {
                    eventName: s
                });
                var t = c.fire.apply(null, e);
                return h.popActivity(), t;
            },
            addListener: function(e, t, n, r, o) {
                var a = h.event.dispatchListener(i, e, s, l);
                u(c).addListener(a, t, n, r, o);
            },
            removeListener: function(e) {
                c.removeListener(e);
            }
        }).originEvent = c;
        return h.popActivity(), t;
    }, h.withEnvironment = function(e, t, n) {
        var r;
        n = n || h.globalThreadLocal();
        try {
            for (r in e) n[r] = e[r];
            return d.extend(n, e), t();
        } finally {
            for (r in e) delete n[r];
        }
    }, h.fetchContextReference = function(e, t, n, r, o) {
        r && (e = r(e, n));
        var a = e.context ? n[e.context] : t;
        return a ? e.noDereference ? e.path : h.get(a, e.path) : o && o(e) || a;
    }, h.makeEnvironmentFetcher = function(n, r, o, a) {
        return o = o || h.globalThreadLocal, function(e) {
            var t = o();
            return h.fetchContextReference(e, n, t, r, a);
        };
    }, h.coerceToPrimitive = function(e) {
        return "false" !== e && ("true" === e || (isFinite(e) ? Number(e) : e));
    }, h.compactStringToRec = function(e, t) {
        var n = e.indexOf("("), r = e.indexOf(")");
        if ((-1 === n ^ -1 === r || r < n) && h.fail("Badly-formed compact " + t + " record without matching parentheses: " + e), 
        -1 === n || -1 === r) return "expander" === t && h.fail("Badly-formed compact expander record without parentheses: " + e), 
        e;
        var o = e.substring(r + 1);
        "" !== d.trim(o) && h.fail("Badly-formed compact " + t + " record " + e + " - unexpected material following close parenthesis: " + o);
        var a = e.substring(0, n), i = d.trim(e.substring(n + 1, r)), s = "" === i ? [] : h.transform(i.split(","), d.trim, h.coerceToPrimitive), l = h.upgradePrimitiveFunc(a, null);
        return l.args = s, l;
    }, h.expandPrefix = "@expand:", h.expandCompactString = function(e, t) {
        var n = e;
        if (0 === e.indexOf(h.expandPrefix)) {
            var r = e.substring(h.expandPrefix.length);
            n = {
                expander: h.compactStringToRec(r, "expander")
            };
        } else t && (n = h.compactStringToRec(e, t));
        return n;
    };
    var a = {
        listeners: "listener",
        modelListeners: "modelListener"
    }, i = d.extend({
        invokers: "invoker"
    }, a);
    function c(e, t, n, r) {
        for (var o = 0; o < n; ++o) e = r(e, t[o], o, h.makeArray(t));
        return e;
    }
    h.expandCompactRec = function(n, r, e) {
        h.guardCircularExpansion(n, n.length);
        var t = 0 < n.length ? n[n.length - 1] : "", o = i[t];
        !o && 1 < n.length && (o = a[n[n.length - 2]]), h.each(e, function(e, t) {
            if (h.isPlainObject(e)) return r[t] = h.freshContainer(e), n.push(t), h.expandCompactRec(n, r[t], e), 
            void n.pop();
            "string" == typeof e && (e = h.expandCompactString(e, o)), r[t] = e;
        });
    }, h.expandCompact = function(e) {
        var t = {};
        return h.expandCompactRec([], t, e), t;
    }, h.extractEL = function(e, t) {
        if ("ALL" === t.ELstyle) return e;
        if (1 === t.ELstyle.length) {
            if (e.charAt(0) === t.ELstyle) return e.substring(1);
        } else if ("${}" === t.ELstyle) {
            var n = e.indexOf("${"), r = e.lastIndexOf("}");
            if (0 === n && -1 !== r) return e.substring(2, r);
        }
    }, h.extractELWithContext = function(e, t) {
        var n = h.extractEL(e, t);
        return h.isIoCReference(n) ? h.parseContextReference(n) : n ? {
            path: n
        } : n;
    }, h.parseContextReference = function(e, t, n) {
        t = t || 0;
        var r, o, a, i = "{" === e.charAt(t + 1);
        -1 === (r = i ? (a = h.parseContextReference(e, t + 1, "}")).endpos : e.indexOf("}", t + 1)) && h.fail('Cannot parse context reference "' + e + '": Malformed context reference without }'), 
        o = i ? a : e.substring(t + 1, r);
        var s = n ? e.indexOf(n, r + 1) : e.length, l = e.substring(r + 1, s);
        return "." === l.charAt(0) && (l = l.substring(1)), {
            context: o,
            path: l,
            endpos: s
        };
    }, h.renderContextReference = function(e) {
        var t = e.context;
        return "{" + ("string" == typeof t ? t : h.renderContextReference(t)) + "}" + (e.path ? "." + e.path : "");
    }, h.resolveContextValue = function(e, n) {
        function t(e) {
            h.pushActivity("resolveContextValue", "resolving context value %parsed", {
                parsed: e
            });
            var t = n.fetcher(e);
            return h.pushActivity("resolvedContextValue", "resolved value %parsed to value %value", {
                parsed: e,
                value: t
            }), h.popActivity(2), t;
        }
        var r;
        if (n.bareContextRefs && h.isIoCReference(e)) return t(r = h.parseContextReference(e));
        if (n.ELstyle && "${}" !== n.ELstyle && (r = h.extractELWithContext(e, n))) return t(r);
        for (;"string" == typeof e; ) {
            var o = e.indexOf("${"), a = e.indexOf("}", o + 2);
            if (-1 === o || -1 === a) break;
            "{" === e.charAt(o + 2) ? a = (r = h.parseContextReference(e, o + 2, "}")).endpos : r = {
                path: e.substring(o + 2, a)
            };
            var i = t(r), s = 0 === o && a === e.length - 1;
            if (null == i) return i;
            e = s ? i : e.substring(0, o) + i + e.substring(a + 1);
        }
        return e;
    }, h.fetchExpandChildren = function(n, r, o, a, i, s) {
        if (a.expander) {
            var e = h.expandExpander(n, a, s);
            if (h.isPrimitive(e) || !h.isPlainObject(e) || h.isArrayable(e) ^ h.isArrayable(n)) return e;
            d.extend(!0, n, e);
        }
        return h.each(a, function(e, t) {
            void 0 === e ? n[t] = void 0 : "expander" !== t && (o[r] = t, !0 !== h.getImmediate(s.exceptions, o, r) && s.strategy(n, t, r + 1, o, a, i));
        }), n;
    }, h.isUnexpandable = function(e) {
        return h.isPrimitive(e) || !h.isPlainObject(e);
    }, h.expandSource = function(e, t, n, r, o, a, i, s) {
        var l, u, c = h.derefMergePolicy(i);
        return "string" != typeof a || c.noexpand ? c.noexpand || h.isUnexpandable(a) ? l = a : a.expander ? l = h.expandExpander(o, a, e) : (l = h.freshContainer(a), 
        u = !0) : e.defaultEL && "{" !== a.charAt(0) ? l = a : (h.pushActivity("expandContextValue", "expanding context value %source held at path %path", {
            source: a,
            path: h.path.apply(null, r.slice(0, n))
        }), l = h.resolveContextValue(a, e), h.popActivity(1)), l !== h.NO_VALUE && o(l), 
        u && s(l, a, n, r, i), l;
    }, h.guardCircularExpansion = function(e, t) {
        t > h.strategyRecursionBailout && h.fail("Overflow/circularity in options expansion, current path is ", e, " at depth ", t, ' - please ensure options are not circularly connected, or protect from expansion using the "noexpand" policy or expander');
    }, h.makeExpandStrategy = function(l) {
        function u(e, t, n, r, o) {
            return h.fetchExpandChildren(e, n || 0, r || [], t, o, l);
        }
        function e(t, n, e, r, o, a) {
            if (h.guardCircularExpansion(r, e), t) {
                if (t.hasOwnProperty(n)) return t[n];
                void 0 === o && (o = c(l.source, r, e - 1, l.sourceStrategy), a = c(l.mergePolicy, r, e - 1, h.concreteTrundler));
                var i = l.sourceStrategy(o, n, e, r), s = h.concreteTrundler(a, n);
                return h.expandSource(l, t, e, r, function(e) {
                    t[n] = e;
                }, i, s, u);
            }
        }
        return l.recurse = u, l.strategy = e;
    }, h.defaults("fluid.makeExpandOptions", {
        ELstyle: "${}",
        bareContextRefs: !0,
        target: h.inCreationMarker
    }), h.makeExpandOptions = function(e, t) {
        return (t = d.extend({}, h.rawDefaults("fluid.makeExpandOptions"), t)).defaultEL = "${}" === t.ELStyle && t.bareContextRefs, 
        t.expandSource = function(e) {
            return h.expandSource(t, null, 0, [], h.identity, e, t.mergePolicy, !1);
        }, h.isUnexpandable(e) ? (t.strategy = h.concreteTrundler, t.initter = h.identity, 
        t.target = "string" == typeof e ? (t.defer ? h.copy : h.identity)(t.expandSource(e)) : e, 
        t.immutableTarget = !0) : (t.source = e, t.target = h.freshContainer(e), t.sourceStrategy = t.sourceStrategy || h.concreteTrundler, 
        h.makeExpandStrategy(t), t.initter = function() {
            t.target = h.fetchExpandChildren(t.target, 0, [], t.source, t.mergePolicy, t);
        }), t;
    }, h.expand = function(e, t) {
        var n = h.makeExpandOptions(e, t);
        return n.initter(), n.target;
    }, h.preExpandRecurse = function(n, r, t, o, a) {
        function e(e) {
            n.expanders.push({
                expander: e,
                holder: t,
                member: o
            }), delete t[o];
        }
        if (h.guardCircularExpansion(a, a.length), h.isIoCReference(r)) {
            var i = h.parseContextReference(r), s = h.model.parseEL(i.path);
            e({
                typeFunc: h.expander.fetch,
                context: i.context,
                segs: s
            });
        } else h.isPlainObject(r) && (r.expander ? (r.expander.typeFunc = h.getGlobalValue(r.expander.type || "fluid.invokeFunc"), 
        e(r.expander)) : h.each(r, function(e, t) {
            a.push(t), h.preExpandRecurse(n, e, r, t, a), a.pop();
        }));
    }, h.preExpand = function(e) {
        var t = {
            expanders: [],
            source: h.isUnexpandable(e) ? e : h.copy(e)
        };
        return h.preExpandRecurse(t, t.source, t, "source", []), t;
    }, h.expandImmediate = function(e, t, n) {
        var r = h.makeStackResolverOptions(t, n, !0), o = h.preExpand(e);
        return h.expandImmediateImpl(o, r), o.source;
    }, h.expandImmediateImpl = function(e, t) {
        for (var n = e.expanders, r = 0; r < n.length; ++r) {
            var o = n[r];
            o.holder[o.member] = o.expander.typeFunc(null, o, t);
        }
    }, h.expandExpander = function(e, t, n) {
        var r = h.getGlobalValue(t.expander.type || "fluid.invokeFunc");
        return r || h.fail("Unknown expander with type " + t.expander.type), r(e, t, n);
    }, h.registerNamespace("fluid.expander"), h.expander.fetch = function(e, t, n) {
        var r = n.localRecord, o = t.expander.context, a = t.expander.segs, i = void 0 !== r[o], s = n.contextThat.lifecycleStatus, l = "treeConstructed" === s || "destroyed" === s, u = i ? r[o] : h.resolveContext(o, n.contextThat, l);
        if (u) {
            var c = u;
            if (i || "constructing" !== u.lifecycleStatus) for (var d = 0; d < a.length; ++d) c = c ? c[a[d]] : void 0; else c = h.getForComponent(u, a);
            return void 0 !== c || i || (c = h.getForComponent(u, a)), c;
        }
        0 < a.length && h.triggerMismatchedPathError(t.expander, n.contextThat);
    }, h.invokeFunc = function(e, t, n) {
        var r = t.expander, o = h.makeArray(r.args);
        r.args = o, o = n.recurse ? n.recurse([], o) : (r = h.expandImmediate(r, n.contextThat, n.localRecord)).args;
        var a = r.func || r.funcName, i = (n.expandSource ? n.expandSource(a) : a) || h.recordToApplicable(r, n.contextThat);
        return "string" == typeof i && (i = h.getGlobalValue(i)), i || h.fail("Error in expander record ", r, ": " + a + " could not be resolved to a function for component ", n.contextThat), 
        i.apply(null, o);
    }, h.noexpand = function(e, t) {
        return t.expander.value ? t.expander.value : t.expander.tree;
    };
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(n, y) {
    "use strict";
    y.model.makeEnvironmentStrategy = function(r) {
        return function(e, t, n) {
            return 0 === n && r[t] ? r[t] : void 0;
        };
    }, y.model.defaultCreatorStrategy = function(e, t) {
        if (void 0 === e[t]) return e[t] = {}, e[t];
    }, y.model.defaultFetchStrategy = function(e, t) {
        return e[t];
    }, y.model.funcResolverStrategy = function(e, t) {
        if (e.resolvePathSegment) return e.resolvePathSegment(t);
    }, y.model.traverseWithStrategy = function(e, t, n, r, o) {
        for (var a = r.strategies, i = t.length - o, s = n; s < i; ++s) {
            if (!e) return e;
            for (var l, u = 0; u < a.length && void 0 === (l = a[u](e, t[s], s + 1, t)); ++u) ;
            l === y.NO_VALUE && (l = void 0), e = l;
        }
        return e;
    }, y.model.getValueAndSegments = function(e, t, n, r) {
        return y.model.accessWithStrategy(e, t, y.NO_VALUE, n, r, !0);
    }, y.model.makeTrundler = function(n) {
        return function(e, t) {
            return y.model.getValueAndSegments(e.root, t, n, e.segs);
        };
    }, y.model.getWithStrategy = function(e, t, n, r) {
        return y.model.accessWithStrategy(e, t, y.NO_VALUE, n, r);
    }, y.model.setWithStrategy = function(e, t, n, r, o) {
        y.model.accessWithStrategy(e, t, n, r, o);
    }, y.model.accessWithStrategy = function(e, t, n, r, o, a) {
        if (y.isPrimitive(t) || y.isArrayable(t)) return y.model.accessImpl(e, t, n, r, o, a, y.model.traverseWithStrategy);
        var i = t.type || "default", s = r.resolvers[i];
        s || y.fail("Unable to find resolver of type " + i);
        var l = y.model.makeTrundler(r), u = {
            root: e,
            segs: o
        };
        return u = s(u, t, l), t.path && u && (u = l(u, t.path)), a ? u : u ? u.root : void 0;
    }, y.registerNamespace("fluid.pathUtil"), y.pathUtil.getPathSegmentImpl = function(e, t, n) {
        var r = null;
        e && (r = "");
        for (var o = !1, a = t.length; n < a; ++n) {
            var i = t.charAt(n);
            if (o) o = !1, null !== r && (r += i); else {
                if ("." === i) break;
                "\\" === i ? o = !0 : null !== r && (r += i);
            }
        }
        return null !== r && (e[0] = r), n;
    };
    var a = [];
    y.pathUtil.parseEL = function(e) {
        for (var t = [], n = 0, r = e.length; n < r; ) {
            var o = y.pathUtil.getPathSegmentImpl(a, e, n);
            t.push(a[0]), n = o + 1;
        }
        return t;
    }, y.pathUtil.composeSegment = function(e, t) {
        t = t.toString();
        for (var n = 0; n < t.length; ++n) {
            var r = t.charAt(n);
            "." !== r && "\\" !== r && "}" !== r || (e += "\\"), e += r;
        }
        return e;
    }, y.pathUtil.escapeSegment = function(e) {
        return y.pathUtil.composeSegment("", e);
    }, y.pathUtil.composePath = function(e, t) {
        return 0 !== e.length && (e += "."), y.pathUtil.composeSegment(e, t);
    }, y.pathUtil.composeSegments = function() {
        for (var e = "", t = 0; t < arguments.length; ++t) e = y.pathUtil.composePath(e, arguments[t]);
        return e;
    }, y.pathUtil.matchSegments = function(e, t, n, r) {
        if (r - n !== e.length) return !1;
        for (var o = n; o < r; ++o) if (t[o] !== e[o - n]) return !1;
        return !0;
    }, y.model.unescapedParser = {
        parse: y.model.parseEL,
        compose: y.model.composeSegments
    }, y.model.defaultGetConfig = {
        parser: y.model.unescapedParser,
        strategies: [ y.model.funcResolverStrategy, y.model.defaultFetchStrategy ]
    }, y.model.defaultSetConfig = {
        parser: y.model.unescapedParser,
        strategies: [ y.model.funcResolverStrategy, y.model.defaultFetchStrategy, y.model.defaultCreatorStrategy ]
    }, y.model.escapedParser = {
        parse: y.pathUtil.parseEL,
        compose: y.pathUtil.composeSegments
    }, y.model.escapedGetConfig = {
        parser: y.model.escapedParser,
        strategies: [ y.model.defaultFetchStrategy ]
    }, y.model.escapedSetConfig = {
        parser: y.model.escapedParser,
        strategies: [ y.model.defaultFetchStrategy, y.model.defaultCreatorStrategy ]
    }, y.stronglyConnected = function(e, t) {
        var n = {
            stack: [],
            accessor: t,
            components: [],
            index: 0
        };
        return e.forEach(function(e) {
            void 0 === e.tarjanIndex && y.stronglyConnectedOne(e, n);
        }), n.components;
    }, y.stronglyConnectedOne = function(t, n) {
        if (t.tarjanIndex = n.index, t.lowIndex = n.index, ++n.index, n.stack.push(t), t.onStack = !0, 
        n.accessor(t).forEach(function(e) {
            void 0 === e.tarjanIndex ? (y.stronglyConnectedOne(e, n), t.lowIndex = Math.min(t.lowIndex, e.lowIndex)) : e.onStack && (t.lowIndex = Math.min(t.lowIndex, e.tarjanIndex));
        }), t.lowIndex === t.tarjanIndex) {
            for (var e, r = []; (e = n.stack.pop()).onStack = !1, r.push(e), e !== t; ) ;
            n.components.push(r);
        }
    }, y.initRelayModel = function(e) {
        return y.deenlistModelComponent(e), e.model;
    }, y.isModelComplete = function(e) {
        return "model" in e && e.model !== y.inEvaluationMarker;
    }, y.enlistModelComponent = function(e) {
        var t = y.getInstantiator(e), n = t.modelTransactions.init[e.id];
        return n || (n = {
            that: e,
            applier: y.getForComponent(e, "applier"),
            complete: y.isModelComplete(e)
        }, t.modelTransactions.init[e.id] = n), n;
    }, y.clearTransactions = function() {
        var e = y.globalInstantiator;
        y.clear(e.modelTransactions), e.modelTransactions.init = {};
    }, y.failureEvent.addListener(y.clearTransactions, "clearTransactions", "before:fail"), 
    y.clearLinkCounts = function(n, r) {
        y.each(n, function(e, t) {
            "number" == typeof e ? n[t] = 0 : r && e.options && "number" == typeof e.relayCount && (e.relayCount = 0);
        });
    }, y.computeInitialOutArcs = function(a, i) {
        return y.transform(i, function(e, n) {
            var r = {}, t = e.that.applier.listeners.sortedListeners;
            y.each(t, function(e) {
                if (e.isRelay && !y.isExcludedChangeSource(a[n], e.cond)) {
                    var t = e.targetId;
                    t !== n && (r[t] = !0);
                }
            });
            var o = Object.keys(r).map(function(e) {
                return i[e];
            });
            return y.remove_if(o, function(e) {
                return void 0 === e;
            }), o;
        });
    }, y.sortCompleteLast = function(e, t) {
        return (e.completeOnInit ? 1 : 0) - (t.completeOnInit ? 1 : 0);
    }, y.operateInitialTransaction = function(e, t) {
        var n, r = y.allocateGuid(), o = y.getModelTransactionRec(e, r), a = y.transform(t, function(e) {
            return n = e.that.applier.initiate(null, "init", r), o[e.that.applier.applierId] = {
                transaction: n
            }, n;
        }), i = y.computeInitialOutArcs(a, t), s = y.values(t), l = y.stronglyConnected(s, function(e) {
            return i[e.that.id];
        }), u = 0;
        l.forEach(function(e) {
            e.forEach(function(e) {
                e.initPriority = e.completeOnInit ? Math.Infinity : u++;
            });
        }), s.sort(function(e, t) {
            return e.initPriority - t.initPriority;
        }), s.forEach(function(e) {
            var t = e.that, n = a[t.id];
            e.completeOnInit ? y.initModelEvent(t, t.applier, n, t.applier.listeners.sortedListeners) : y.each(e.initModels, function(e) {
                n.fireChangeRequest({
                    type: "ADD",
                    segs: [],
                    value: e
                }), y.clearLinkCounts(o, !0);
            });
            var r = y.shadowForComponent(t);
            r && (r.modelComplete = !0);
        }), n.commit();
    }, y.deenlistModelComponent = function(e) {
        var t = y.getInstantiator(e), n = t.modelTransactions.init;
        if (n[e.id] && (e.model = void 0, n[e.id].complete = !0, !y.find_if(n, function(e) {
            return !0 !== e.complete;
        }))) {
            try {
                y.operateInitialTransaction(e, n);
            } catch (e) {
                throw y.clearTransactions(), e;
            }
            t.modelTransactions.init = {};
        }
    }, y.parseModelReference = function(e, t) {
        var n = y.parseContextReference(t);
        return n.segs = e.applier.parseEL(n.path), n;
    }, y.parseValidModelReference = function(e, t, n, r) {
        function o() {
            var e = [ "Error in " + t + ": ", n ].concat(y.makeArray(arguments));
            y.fail.apply(null, e);
        }
        function a(e) {
            o(" must be a reference to a component with a ChangeApplier (descended from fluid.modelComponent), instead got ", e);
        }
        var i, s, l;
        if ("string" == typeof n) if (y.isIoCReference(n)) {
            var u = (i = y.parseModelReference(e, n)).segs.indexOf("model");
            -1 === u ? r ? i.nonModel = !0 : o(' must be a reference into a component model via a path including the segment "model"') : (i.modelSegs = i.segs.slice(u + 1), 
            i.contextSegs = i.segs.slice(0, u), delete i.path);
        } else i = {
            path: n,
            modelSegs: e.applier.parseEL(n)
        }; else y.isArrayable(n.segs) || o(' must contain an entry "segs" holding path segments referring a model path within a component'), 
        i = {
            context: n.context,
            modelSegs: y.expandOptions(n.segs, e)
        };
        return l = i.context ? ((s = y.resolveContext(i.context, e)) || o(" context must be a reference to an existing component"), 
        i.contextSegs ? y.getForComponent(s, i.contextSegs) : s) : e, i.nonModel || (y.isComponent(l) || a(l), 
        l.applier || y.getForComponent(l, [ "applier" ]), l.applier || a(l)), i.that = l, 
        i.applier = l && l.applier, i.path || (i.path = l && l.applier.composeSegments.apply(null, i.modelSegs)), 
        i;
    }, y.getModelTransactionRec = function(e, t) {
        var n = y.getInstantiator(e);
        if (t || y.fail("Cannot get transaction record without transaction id"), !n) return null;
        var r = n.modelTransactions[t];
        return r || (r = n.modelTransactions[t] = {
            relays: [],
            sources: {},
            externalChanges: {}
        }), r;
    }, y.recordChangeListener = function(e, t, n, r) {
        var o = y.shadowForComponent(e);
        y.recordListener(t.modelChanged, n, o, r);
    }, y.registerRelayTransaction = function(e, t, n, r, o) {
        var a = t.initiate("relay", null, n), i = e[t.applierId] = {
            transaction: a,
            relayCount: 0,
            namespace: o.namespace,
            priority: o.priority,
            options: r
        };
        return i.priority = y.parsePriority(i.priority, e.relays.length, !1, "model relay"), 
        e.relays.push(i), i;
    }, y.relayRecursionBailout = 100, y.registerDirectChangeRelay = function(u, c, e, d, f, p, m, g) {
        var h = m.targetApplier || u.applier, t = m.sourceApplier || e.applier, v = h.applierId;
        c = y.makeArray(c), d = y.makeArray(d);
        function n(e, t, n, r, o, a) {
            var i = o.id, s = y.getModelTransactionRec(u, i);
            a && o && !s[a.applierId] && (s[a.applierId] = {
                transaction: o
            });
            var l = s[v];
            s[f] = s[f] || 0, ++s[f], s[f] > y.relayRecursionBailout && y.fail("Error in model relay specification at component ", u, " - operated more than " + y.relayRecursionBailout + " relays without model value settling - current model contents are ", o.newHolder.model), 
            l || (l = y.registerRelayTransaction(s, h, i, m, g)), p && !m.targetApplier ? p(l.transaction, m.sourceApplier ? void 0 : e, d, c, r) : (r && "DELETE" === r.type && l.transaction.fireChangeRequest({
                type: "DELETE",
                segs: c
            }), void 0 !== e && l.transaction.fireChangeRequest({
                type: "ADD",
                segs: c,
                value: e
            }));
        }
        var r = t.modelChanged.addListener({
            isRelay: !0,
            cond: p && p.cond,
            targetId: u.id,
            targetApplierId: h.id,
            segs: d,
            transactional: m.transactional
        }, n);
        y.passLogLevel(y.logLevel.TRACE) && y.log(y.logLevel.TRACE, "Adding relay listener with listenerId " + r.listenerId + " to source applier with id " + t.applierId + " from target applier with id " + v + " for target component with id " + u.id), 
        e && (y.recordChangeListener(e, t, n, r.listenerId), u !== e && y.recordChangeListener(u, t, n, r.listenerId));
    }, y.connectModelRelay = function(e, t, n, r, o) {
        var a = y.allocateGuid();
        function i(e) {
            var t = y.enlistModelComponent(e);
            t.complete && y.shadowForComponent(e).modelComplete && (t.completeOnInit = !0);
        }
        i(n), i(e);
        var s = y.filterKeys(o, [ "namespace", "priority" ]);
        o.update ? o.targetApplier ? y.registerDirectChangeRelay(e, t, n, r, a, null, {
            transactional: !1,
            targetApplier: o.targetApplier,
            update: o.update
        }, s) : y.registerDirectChangeRelay(n, r, e, [], a + "-transform", o.forwardAdapter, {
            transactional: !0,
            sourceApplier: o.forwardApplier
        }, s) : (y.registerDirectChangeRelay(n, r, e, t, a, o.forwardAdapter, {
            transactional: !1
        }, s), y.registerDirectChangeRelay(e, t, n, r, a, o.backwardAdapter, {
            transactional: !1
        }, s));
    }, y.parseSourceExclusionSpec = function(e, t) {
        return e.excludeSource = y.arrayToHash(y.makeArray(t.excludeSource || (t.includeSource ? "*" : void 0))), 
        e.includeSource = y.arrayToHash(y.makeArray(t.includeSource)), e;
    }, y.isExcludedChangeSource = function(e, t) {
        if (!t || !t.excludeSource) return !1;
        var n = t.excludeSource["*"];
        for (var r in e.fullSources) t.excludeSource[r] && (n = !0), t.includeSource[r] && (n = !1);
        return n;
    }, y.model.guardedAdapter = function(e, t, n, r) {
        y.isExcludedChangeSource(e, t) || n === y.model.transform.uninvertibleTransform || n.apply(null, r);
    }, y.transformToAdapter = function(e, a) {
        var i = {};
        return i[a] = e, function(e, t, n, r, o) {
            o && "DELETE" === o.type && e.fireChangeRequest({
                type: "DELETE",
                path: a
            }), y.model.transformWithRules(t, i, {
                finalApplier: e
            });
        };
    }, y.makeTransformPackage = function(e, n, r, o, a, t, i, s) {
        var l = {
            forwardHolder: {
                model: n
            },
            backwardHolder: {
                model: null
            },
            generateAdapters: function(e) {
                if (l.forwardAdapterImpl = y.transformToAdapter(e ? e.newHolder.model : l.forwardHolder.model, o), 
                null !== r) {
                    var t = y.model.transform.invertConfiguration(n);
                    t !== y.model.transform.uninvertibleTransform ? (l.backwardHolder.model = t, l.backwardAdapterImpl = y.transformToAdapter(l.backwardHolder.model, r)) : l.backwardAdapterImpl = t;
                }
            },
            forwardAdapter: function(e, t) {
                void 0 === t && l.generateAdapters(), y.model.guardedAdapter(e, a, l.forwardAdapterImpl, arguments);
            }
        };
        l.forwardAdapter.cond = a, l.runTransform = function(e) {
            e.commit(), e.reset();
        }, l.forwardApplier = y.makeHolderChangeApplier(l.forwardHolder), l.forwardApplier.isRelayApplier = !0, 
        l.invalidator = y.makeEventFirer({
            name: "Invalidator for model relay with applier " + l.forwardApplier.applierId
        }), null !== r && (l.backwardApplier = y.makeHolderChangeApplier(l.backwardHolder), 
        l.backwardAdapter = function(e) {
            y.model.guardedAdapter(e, t, l.backwardAdapterImpl, arguments);
        }, l.backwardAdapter.cond = t), l.update = l.invalidator.fire;
        var u = {
            targetApplier: l.forwardApplier,
            update: l.update,
            namespace: i,
            priority: s,
            refCount: 0
        };
        return l.forwardHolder.model = y.parseImplicitRelay(e, n, [], u), l.refCount = u.refCount, 
        l.namespace = i, l.priority = s, l.generateAdapters(), l.invalidator.addListener(l.generateAdapters), 
        l.invalidator.addListener(l.runTransform), l;
    }, y.singleTransformToFull = function(e) {
        return {
            "": {
                transform: n.extend(!0, {
                    inputPath: ""
                }, e)
            }
        };
    }, y.model.relayConditions = {
        initOnly: {
            includeSource: "init"
        },
        liveOnly: {
            excludeSource: "init"
        },
        never: {
            includeSource: []
        },
        always: {}
    }, y.model.parseRelayCondition = function(e) {
        var t;
        return "initOnly" === e ? y.log(y.logLevel.WARN, 'The relay condition "initOnly" is deprecated: Please use the form \'includeSource: "init"\' instead') : "liveOnly" === e && y.log(y.logLevel.WARN, 'The relay condition "liveOnly" is deprecated: Please use the form \'excludeSource: "init"\' instead'), 
        e ? "string" == typeof e ? (t = y.model.relayConditions[e]) || y.fail('Unrecognised model relay condition string "' + e + '": the supported values are "never" or a record with members "includeSource" and/or "excludeSource"') : t = e : t = {}, 
        y.parseSourceExclusionSpec({}, t);
    }, y.parseModelRelay = function(e, t, n) {
        var r = void 0 !== t.source ? y.parseValidModelReference(e, 'modelRelay record member "source"', t.source) : {
            path: null,
            modelSegs: null
        }, o = y.parseValidModelReference(e, 'modelRelay record member "target"', t.target), a = t.namespace || n, i = t.singleTransform ? y.singleTransformToFull(t.singleTransform) : t.transform;
        i || y.fail('Cannot parse modelRelay record without element "singleTransform" or "transform":', t);
        var s = y.model.parseRelayCondition(t.forward), l = y.model.parseRelayCondition(t.backward), u = y.makeTransformPackage(e, i, r.path, o.path, s, l, a, t.priority);
        0 === u.refCount ? y.connectModelRelay(r.that || e, r.modelSegs, o.that, o.modelSegs, y.filterKeys(u, [ "forwardAdapter", "backwardAdapter", "namespace", "priority" ])) : (r.modelSegs && y.fail('Error in model relay definition: If a relay transform has a model dependency, you can not specify a "source" entry - please instead enter this as "input" in the transform specification. Definition was ', t, " for component ", e), 
        y.connectModelRelay(e, null, o.that, o.modelSegs, u));
    }, y.parseImplicitRelay = function(r, e, o, a) {
        var i;
        if (y.isIoCReference(e)) {
            var t = y.parseValidModelReference(r, "model reference from model (implicit relay)", e, !0);
            t.nonModel ? i = y.getForComponent(t.that, t.segs) : (++a.refCount, y.connectModelRelay(r, o, t.that, t.modelSegs, a));
        } else y.isPrimitive(e) || !y.isPlainObject(e) ? i = e : e.expander && y.isPlainObject(e.expander) ? i = y.expandOptions(e, r) : (i = y.freshContainer(e), 
        y.each(e, function(e, t) {
            o.push(t);
            var n = y.parseImplicitRelay(r, e, o, a);
            void 0 !== n && (i[t] = n), o.pop();
        }));
        return i;
    }, y.model.notifyExternal = function(e) {
        var t = e ? y.values(e.externalChanges) : [];
        y.sortByPriority(t);
        for (var n = 0; n < t.length; ++n) {
            var r = t[n];
            r.args[5].destroyed || r.listener.apply(null, r.args);
        }
        y.clearLinkCounts(e, !0);
    }, y.model.commitRelays = function(e, t) {
        var n = e.modelTransactions[t];
        y.each(n, function(e) {
            e.transaction && (e.transaction.commit("relay"), e.transaction.reset());
        });
    }, y.model.updateRelays = function(e, t) {
        var n = e.modelTransactions[t], r = 0;
        return y.sortByPriority(n.relays), y.each(n.relays, function(e) {
            0 < e.transaction.changeRecord.changes && e.relayCount < 2 && e.options.update && (e.relayCount++, 
            y.clearLinkCounts(n), e.options.update(e.transaction, n), ++r);
        }), r;
    }, y.establishModelRelay = function(r, e, t, n, o) {
        var a = y.shadowForComponent(r);
        a.modelRelayEstablished ? y.fail("FLUID-5887 failure: Model relay initialised twice on component", r) : a.modelRelayEstablished = !0, 
        y.mergeModelListeners(r, t);
        var i = y.enlistModelComponent(r);
        y.each(n, function(e, t) {
            for (var n = 0; n < e.length; ++n) y.parseModelRelay(r, e[n], t);
        });
        var s = y.transform(e, function(e) {
            return y.parseImplicitRelay(r, e, [], {
                refCount: 0,
                priority: "first"
            });
        });
        i.initModels = s;
        var l = y.getInstantiator(r);
        return o.preCommit.addListener(function(e) {
            for (;0 < y.model.updateRelays(l, e.id); ) ;
        }), o.preCommit.addListener(function(e, t, n) {
            "relay" !== n && y.model.commitRelays(l, e.id);
        }), o.postCommit.addListener(function(e, t, n) {
            "relay" !== n && (y.model.notifyExternal(l.modelTransactions[e.id]), delete l.modelTransactions[e.id]);
        }), null;
    }, y.defaults("fluid.modelComponent", {
        gradeNames: [ "fluid.component" ],
        changeApplierOptions: {
            relayStyle: !0,
            cullUnchanged: !0
        },
        members: {
            model: "@expand:fluid.initRelayModel({that}, {that}.modelRelay)",
            applier: "@expand:fluid.makeHolderChangeApplier({that}, {that}.options.changeApplierOptions)",
            modelRelay: "@expand:fluid.establishModelRelay({that}, {that}.options.model, {that}.options.modelListeners, {that}.options.modelRelay, {that}.applier)"
        },
        mergePolicy: {
            model: {
                noexpand: !0,
                func: y.arrayConcatPolicy
            },
            modelListeners: y.makeMergeListenersPolicy(y.arrayConcatPolicy),
            modelRelay: y.makeMergeListenersPolicy(y.arrayConcatPolicy, !0)
        }
    }), y.modelChangedToChange = function(e) {
        return {
            value: e[0],
            oldValue: e[1],
            path: e[2],
            transaction: e[4]
        };
    }, y.event.invokeListener = function(e, t, n, r) {
        return "string" == typeof e && (e = y.event.resolveListener(e)), e.apply(null, t, n, r);
    }, y.resolveModelListener = function(o, a) {
        function e() {
            if (!y.isDestroyed(o)) {
                var e = y.modelChangedToChange(arguments), t = arguments, n = {
                    change: e,
                    arguments: t
                }, r = {
                    source: Object.keys(e.transaction.sources)
                };
                a.args && (t = y.expandOptions(a.args, o, {}, n)), y.event.invokeListener(a.listener, y.makeArray(t), n, r);
            }
        }
        return y.event.impersonateListener(a.listener, e), e;
    }, y.registerModelListeners = function(r, o, e, a) {
        var i = y.resolveModelListener(r, o);
        y.each(o.byTarget, function(e) {
            var t = e[0], n = {
                listener: i,
                listenerId: y.allocateGuid(),
                segsArray: y.getMembers(e, "modelSegs"),
                pathArray: y.getMembers(e, "path"),
                includeSource: o.includeSource,
                excludeSource: o.excludeSource,
                priority: y.expandOptions(o.priority, r),
                transactional: !0
            };
            n = t.applier.modelChanged.addListener(n, i, a, o.softNamespace), y.recordChangeListener(r, t.applier, i, n.listenerId), 
            r === t.that || y.isModelComplete(r) || y.getForComponent(r, [ "events", "onCreate" ]).addListener(function() {
                if (y.isModelComplete(t.that)) {
                    var e = t.applier.initiate(null, "init");
                    y.initModelEvent(r, t.applier, e, [ n ]), e.commit();
                }
            });
        });
    }, y.mergeModelListeners = function(o, e) {
        y.each(e, function(e, r) {
            "string" == typeof e && (e = {
                funcName: e
            });
            var t = y.event.resolveListenerRecord(e, o, "modelListeners", null, !1).records;
            y.each(t, function(n) {
                n.byTarget = {};
                var e = y.makeArray(void 0 === n.path ? r : n.path);
                y.each(e, function(e) {
                    var t = y.parseValidModelReference(o, "modelListeners entry", e);
                    y.pushArray(n.byTarget, t.that.id, t);
                });
                var t = (n.namespace && !n.softNamespace ? n.namespace : null) || (void 0 !== n.path ? r : null);
                y.registerModelListeners(o, n, e, t);
            });
        });
    }, y.fireChanges = function(e, t) {
        for (var n = 0; n < t.length; ++n) e.fireChangeRequest(t[n]);
    }, y.model.isChangedPath = function(e, t) {
        for (var n = 0; n <= t.length; ++n) {
            if ("string" == typeof e) return !0;
            n < t.length && e && (e = e[t[n]]);
        }
        return !1;
    }, y.model.setChangedPath = function(t, n, r) {
        function e(e) {
            n.unshift(e), y.model.setSimple(t, n, r), n.shift();
        }
        y.model.isChangedPath(t.changeMap, n) || (++t.changes, e("changeMap")), y.model.isChangedPath(t.deltaMap, n) || (++t.deltas, 
        e("deltaMap"));
    }, y.model.fetchChangeChildren = function(n, r, o, e, a) {
        y.each(e, function(e, t) {
            o[r] = t, y.model.applyChangeStrategy(n, t, r, o, e, a), o.length = r;
        });
    }, y.model.isSameValue = function(e, t) {
        return "number" != typeof e || "number" != typeof t ? e === t : e === t || e != e && t != t || Math.abs((e - t) / t) < 1e-12;
    }, y.model.applyChangeStrategy = function(e, t, n, r, o, a) {
        var i = e[t], s = y.typeCode(o), l = y.typeCode(i), u = y.NO_VALUE;
        "primitive" === s ? y.model.isSameValue(i, o) || (u = o, ++a.unchanged) : (l !== s || "array" === s && o.length !== i.length) && (u = y.freshContainer(o)), 
        u !== y.NO_VALUE && (e[t] = u, a.changeMap && y.model.setChangedPath(a, r, a.inverse ? "DELETE" : "ADD")), 
        "primitive" !== s && y.model.fetchChangeChildren(e[t], n + 1, r, o, a);
    }, y.model.stepTargetAccess = function(e, t, n, r, o, a) {
        for (var i = r; i < o; ++i) {
            if (e) e[n[i]] !== (e = y.model.traverseWithStrategy(e, n, i, a["ADD" === t ? "resolverSetConfig" : "resolverGetConfig"], n.length - i - 1)) && a.changeMap && y.model.setChangedPath(a, n.slice(0, i + 1), "ADD");
        }
        return {
            root: e,
            last: n[o]
        };
    }, y.model.defaultAccessorConfig = function(e) {
        return (e = e || {}).resolverSetConfig = e.resolverSetConfig || y.model.escapedSetConfig, 
        e.resolverGetConfig = e.resolverGetConfig || y.model.escapedGetConfig, e;
    }, y.model.applyHolderChangeRequest = function(e, t, n) {
        (n = y.model.defaultAccessorConfig(n)).deltaMap = n.changeMap ? {} : null, n.deltas = 0;
        var r, o = t.segs.length, a = 0 === o;
        if (r = a ? {
            root: e,
            last: "model"
        } : (e.model || (e.model = {}, y.model.setChangedPath(n, [], n.inverse ? "DELETE" : "ADD")), 
        y.model.stepTargetAccess(e.model, t.type, t.segs, 0, o - 1, n)), "ADD" === t.type) {
            var i = t.value, s = y.makeArray(t.segs);
            y.model.applyChangeStrategy(r.root, r.last, o - 1, s, i, n, a);
        } else "DELETE" === t.type ? r.root && void 0 !== r.root[r.last] && (delete r.root[r.last], 
        n.changeMap && y.model.setChangedPath(n, t.segs, "DELETE")) : y.fail("Unrecognised change type of " + t.type);
        return n.deltas ? n.deltaMap : null;
    }, y.model.diff = function(e, t, n) {
        n = n || {
            changes: 0,
            unchanged: 0,
            changeMap: {}
        };
        var r, o = y.typeCode(e), a = y.typeCode(t);
        if ("primitive" === o && "primitive" === a) r = y.model.isSameValue(e, t); else if ("primitive" === o ^ "primitive" === a) r = !1; else {
            var i = {
                model: y.copy(e)
            };
            y.model.applyHolderChangeRequest(i, {
                value: t,
                segs: [],
                type: "ADD"
            }, n);
            var s = {
                model: y.copy(t)
            };
            n.inverse = !0, y.model.applyHolderChangeRequest(s, {
                value: e,
                segs: [],
                type: "ADD"
            }, n), r = 0 === n.changes;
        }
        return !1 === r && 0 === n.changes ? (n.changes = 1, n.changeMap = void 0 === t ? "DELETE" : "ADD") : !0 === r && 0 === n.unchanged && (n.unchanged = 1), 
        r;
    }, y.outputMatches = function(n, r, e) {
        y.each(e, function(e, t) {
            n.push(r.concat(t));
        });
    }, y.matchChanges = function(e, t, n, r) {
        for (var o = n.model, a = r.model, i = e, s = [ "model" ], l = !1, u = [], c = 0; c < t.length; ++c) {
            var d = t[c];
            "*" === d ? c === t.length - 1 ? l = !0 : y.fail("Wildcard specification in modelChanged listener is only supported for the final path segment: " + t.join(".")) : (s.push(d), 
            i = y.isPrimitive(i) ? i : i[d], o = o ? o[d] : void 0, a = a ? a[d] : void 0);
        }
        return i && (l ? "DELETE" === i ? y.outputMatches(u, s, a) : "ADD" === i ? y.outputMatches(u, s, o) : y.outputMatches(u, s, i) : u.push(s)), 
        u;
    }, y.storeExternalChange = function(e, t, n, r, o) {
        var a = t.composeSegments.apply(null, n), i = [ t.holder.id, r.listenerId, r.wildcard ? a : "" ].join("|");
        e.externalChanges[i] = {
            listener: r.listener,
            namespace: r.namespace,
            priority: r.priority,
            args: o
        };
    }, y.notifyModelChanges = function(e, t, n, r, o, a, i, s) {
        if (e) for (var l = a && y.getModelTransactionRec(s, a.id), u = 0; u < e.length; ++u) for (var c = e[u], d = 1 < c.segsArray.length, f = 0; f < c.segsArray.length; ++f) for (var p = y.matchChanges(t, c.segsArray[f], n, r), m = 0; m < p.length; ++m) {
            if (i.destroyed) return;
            var g = p[m];
            c.listener = y.event.resolveListener(c.listener);
            var h = [ d ? n.model : y.model.getSimple(n, g), d ? r.model : y.model.getSimple(r, g), d ? [] : g.slice(1), o, a, i ];
            if (!c.isRelay) {
                if (y.model.diff(h[0], h[1])) continue;
                if (y.isExcludedChangeSource(a, c)) continue;
            }
            l && !c.isRelay && c.transactional ? y.storeExternalChange(l, i, g, c, h) : c.listener.apply(null, h);
        }
    }, y.bindELMethods = function(t) {
        t.parseEL = function(e) {
            return y.model.pathToSegments(e, t.options.resolverSetConfig);
        }, t.composeSegments = function() {
            return t.options.resolverSetConfig.parser.compose.apply(null, arguments);
        };
    }, y.initModelEvent = function(e, t, n, r) {
        y.notifyModelChanges(r, "ADD", n.oldHolder, y.emptyHolder, null, n, t, e);
    }, y.emptyHolder = y.freezeRecursive({
        model: void 0
    }), y.preFireChangeRequest = function(e, t) {
        t.type || (t.type = "ADD"), t.segs = t.segs || e.parseEL(t.path);
    }, y.bindRequestChange = function(a) {
        a.change = function(e, t, n, r) {
            var o = {
                path: e,
                value: t,
                type: n,
                source: r
            };
            a.fireChangeRequest(o);
        };
    }, y.isObjectSimple = function(e) {
        return "[object Object]" === Object.prototype.toString.call(e);
    }, y.mergeChangeSources = function(t, e) {
        y.isObjectSimple(e) ? y.extend(t, e) : y.each(y.makeArray(e), function(e) {
            t[e] = !0;
        });
    }, y.ChangeApplier = function() {}, y.makeHolderChangeApplier = function(i, s) {
        s = y.model.defaultAccessorConfig(s);
        var e = y.allocateGuid(), l = new y.ChangeApplier(), t = y.isComponent(i) ? "ChangeApplier for component " + y.dumpThat(i) : "ChangeApplier with id " + e;
        return n.extend(l, {
            applierId: e,
            holder: i,
            listeners: y.makeEventFirer({
                name: "Internal change listeners for " + t
            }),
            transListeners: y.makeEventFirer({
                name: "External change listeners for " + t
            }),
            options: s,
            modelChanged: {},
            preCommit: y.makeEventFirer({
                name: "preCommit event for " + t
            }),
            postCommit: y.makeEventFirer({
                name: "postCommit event for " + t
            })
        }), l.destroy = function() {
            l.preCommit.destroy(), l.postCommit.destroy(), l.destroyed = !0;
        }, l.modelChanged.addListener = function(e, t, n, r) {
            return (e = "string" == typeof e ? {
                path: e
            } : y.copy(e)).listenerId = e.listenerId || y.allocateGuid(), e.namespace = n, e.softNamespace = r, 
            "string" == typeof t && (t = {
                globalName: t
            }), e.listener = t, !1 !== e.transactional && (e.transactional = !0), e.segsArray || (void 0 !== e.path && (e.segs = e.segs || l.parseEL(e.path)), 
            e.segsArray || (e.segsArray = [ e.segs ])), e.isRelay || (y.parseSourceExclusionSpec(e, e), 
            e.wildcard = y.accumulate(y.transform(e.segsArray, function(e) {
                return y.contains(e, "*");
            }), y.add, 0), e.wildcard && 1 < e.segsArray.length && y.fail("Error in model listener specification ", e, " - you may not supply a wildcard pattern as one of a set of multiple paths to be matched")), 
            l[e.transactional ? "transListeners" : "listeners"].addListener(e), e;
        }, l.modelChanged.removeListener = function(e) {
            l.listeners.removeListener(e), l.transListeners.removeListener(e);
        }, l.fireChangeRequest = function(e) {
            var t = l.initiate("local", e.source);
            t.fireChangeRequest(e), t.commit();
        }, l.initiate = function(e, t, n) {
            var r = "relay" === (e = "init" === t ? null : e || "local"), o = {
                instanceId: y.allocateGuid(),
                id: n || y.allocateGuid(),
                changeRecord: {
                    resolverSetConfig: s.resolverSetConfig,
                    resolverGetConfig: s.resolverGetConfig
                },
                reset: function() {
                    o.oldHolder = i, o.newHolder = {
                        model: y.copy(i.model)
                    }, o.changeRecord.changes = 0, o.changeRecord.unchanged = 0, o.changeRecord.changeMap = {};
                },
                commit: function(e) {
                    if (l.preCommit.fire(o, l, e), 0 < o.changeRecord.changes) {
                        var t = {
                            model: i.model
                        };
                        i.model = o.newHolder.model, y.notifyModelChanges(l.transListeners.sortedListeners, o.changeRecord.changeMap, i, t, null, o, l, i);
                    }
                    r || l.postCommit.fire(o, l, e);
                },
                fireChangeRequest: function(e) {
                    y.preFireChangeRequest(l, e), e.transactionId = o.id;
                    var t = y.model.applyHolderChangeRequest(o.newHolder, e, o.changeRecord);
                    y.notifyModelChanges(l.listeners.sortedListeners, t, o.newHolder, i, e, o, l, i);
                },
                hasChangeSource: function(e) {
                    return o.fullSources[e];
                }
            }, a = y.getModelTransactionRec(i, o.id);
            return a && (y.mergeChangeSources(a.sources, t), o.sources = a.sources, o.fullSources = Object.create(a.sources), 
            o.fullSources[e] = !0), o.reset(), y.bindRequestChange(o), o;
        }, y.bindRequestChange(l), y.bindELMethods(l), l;
    }, y.modelPairToChanges = function(e, t, n) {
        n = n || "";
        var r = {
            changes: 0,
            unchanged: 0,
            changeMap: {}
        };
        y.model.diff(t, e, r);
        var o = [];
        return y.modelPairToChangesImpl(e, y.pathUtil.parseEL(n), r.changeMap, [], o), o;
    }, y.modelPairToChangesImpl = function(r, o, e, a, i) {
        "ADD" === e ? i.push({
            path: o,
            value: r,
            type: "ADD"
        }) : "DELETE" === e ? i.push({
            path: o,
            value: null,
            type: "DELETE"
        }) : y.isPlainObject(e, !0) && y.each(e, function(e, t) {
            var n = a.concat([ t ]);
            "ADD" === e ? i.push({
                path: o.concat(n),
                value: y.get(r, n),
                type: "ADD"
            }) : "DELETE" === e ? i.push({
                path: o.concat(n),
                value: null,
                type: "DELETE"
            }) : y.isPlainObject(e, !0) && y.modelPairToChangesImpl(r, o, e, n, i);
        });
    };
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(l, c) {
    "use strict";
    c.registerNamespace("fluid.model.transform"), c.defaults("fluid.transformFunction", {
        gradeNames: "fluid.function"
    }), c.defaults("fluid.standardInputTransformFunction", {
        gradeNames: "fluid.transformFunction"
    }), c.defaults("fluid.standardOutputTransformFunction", {
        gradeNames: "fluid.transformFunction"
    }), c.defaults("fluid.multiInputTransformFunction", {
        gradeNames: "fluid.transformFunction"
    }), c.defaults("fluid.standardTransformFunction", {
        gradeNames: [ "fluid.standardInputTransformFunction", "fluid.standardOutputTransformFunction" ]
    }), c.defaults("fluid.lens", {
        gradeNames: "fluid.transformFunction",
        invertConfiguration: null
    }), c.model.transform.pathToRule = function(e) {
        return {
            transform: {
                type: "fluid.transforms.value",
                inputPath: e
            }
        };
    }, c.model.transform.literalValueToRule = function(e) {
        return {
            transform: {
                type: "fluid.transforms.literalValue",
                input: e
            }
        };
    }, c.model.composePaths = function(e, t) {
        return t = 0 === t ? "0" : t || "", (e = 0 === e ? "0" : e || "") ? t ? e + "." + t : e : t;
    }, c.model.transform.accumulateInputPath = function(e, t, n) {
        void 0 !== e && n.push(c.model.composePaths(t.inputPrefix, e));
    }, c.model.transform.accumulateStandardInputPath = function(e, t, n, r) {
        c.model.transform.getValue(void 0, t[e], n), c.model.transform.accumulateInputPath(t[e + "Path"], n, r);
    }, c.model.transform.accumulateMultiInputPaths = function(e, n, r, o) {
        c.each(e, function(e, t) {
            c.model.transform.accumulateStandardInputPath(t, n, r, o);
        });
    }, c.model.transform.getValue = function(e, t, n) {
        var r;
        return void 0 !== e && (r = c.get(n.source, c.model.composePaths(n.inputPrefix, e), n.resolverGetConfig)), 
        void 0 === r && (r = c.isPrimitive(t) ? t : "literalValue" in t ? t.literalValue : void 0 === t.transform ? t : n.expand(t)), 
        r;
    }, c.model.transform.NONDEFAULT_OUTPUT_PATH_RETURN = {}, c.model.transform.setValue = function(e, t, n) {
        var r = c.copy(t), o = c.model.composePaths(n.outputPrefix, e);
        return void 0 !== r && n.applier.change(o, r), e ? c.model.transform.NONDEFAULT_OUTPUT_PATH_RETURN : r;
    }, c.model.transform.resolveParam = function(e, t, n, r) {
        var o = c.model.transform.getValue(e[n + "Path"], e[n], t);
        return void 0 !== o ? o : r;
    }, c.model.transform.matchValue = function(e, t, n) {
        var r = {
            changes: 0,
            unchanged: 0,
            changeMap: {}
        };
        return c.model.diff(e, t, r), 0 === r.unchanged ? 0 : n ? 0xffffff000000 - 16777216 * r.changes + r.unchanged : r.changes ? 0 : 0xffffff000000 + r.unchanged;
    }, c.model.transform.invertPaths = function(e, t) {
        var n = c.model.composePaths(t.outputPrefix, e.outputPath);
        return e.outputPath = c.model.composePaths(t.inputPrefix, e.inputPath), e.inputPath = n, 
        e;
    }, c.model.transform.prefixApplier = function(e, t) {
        e.inputPrefix && t.inputPrefixOp.push(e.inputPrefix), e.outputPrefix && t.outputPrefixOp.push(e.outputPrefix), 
        t.expand(e.input), e.inputPrefix && t.inputPrefixOp.pop(), e.outputPrefix && t.outputPrefixOp.pop();
    }, c.defaults("fluid.model.transform.prefixApplier", {
        gradeNames: [ "fluid.transformFunction" ]
    }), c.model.makePathStack = function(n, r) {
        var o = n[r + "Stack"] = [];
        return n[r] = "", {
            push: function(e) {
                var t = c.model.composePaths(n[r], e);
                o.push(n[r]), n[r] = t;
            },
            pop: function() {
                n[r] = o.pop();
            }
        };
    }, c.model.transform.doTransform = function(r, o, e) {
        var t = e.defaults, n = c.getGlobalValue(e.typeName);
        "function" != typeof n && c.fail("Transformation record specifies transformation function with name " + r.type + " which is not a function - ", n), 
        c.hasGrade(t, "fluid.transformFunction") || (t = c.defaults("fluid.standardTransformFunction"));
        var a = [ r, o ];
        if (c.hasGrade(t, "fluid.multiInputTransformFunction")) {
            var i = {};
            c.each(t.inputVariables, function(t, n) {
                i[n] = function() {
                    var e = c.model.transform.getValue(r[n + "Path"], r[n], o);
                    return e = void 0 === e && null !== t ? t : e;
                };
            }), a.unshift(i);
        }
        if (c.hasGrade(t, "fluid.standardInputTransformFunction")) {
            "input" in r || "inputPath" in r || c.fail('Error in transform specification. Either "input" or "inputPath" must be specified for a standardInputTransformFunction: received ', r);
            var s = c.model.transform.getValue(r.inputPath, r.input, o);
            if (a.unshift(s), void 0 === s) return;
        }
        var l = n.apply(null, a);
        c.hasGrade(t, "fluid.standardOutputTransformFunction") && void 0 !== (void 0 !== r.outputPath ? r.outputPath : e.doOutput ? "" : void 0) && void 0 !== l && (c.model.transform.setValue(r.outputPath, l, o), 
        l = void 0);
        return l;
    };
    var n = [];
    c.registerNamespace("fluid.pathUtil"), c.pathUtil.getPathSegment = function(e, t) {
        return c.pathUtil.getPathSegmentImpl(n, e, t), n[0];
    }, c.pathUtil.getHeadPath = function(e) {
        return c.pathUtil.getPathSegment(e, 0);
    }, c.pathUtil.getFromHeadPath = function(e) {
        var t = c.pathUtil.getPathSegmentImpl(null, e, 0);
        return t === e.length ? "" : e.substring(t + 1);
    }, c.pathUtil.matchPath = function(e, t, n) {
        for (var r = []; ;) {
            if ("" === t ^ "" === e && n) return null;
            if (!e || !t) break;
            var o = c.pathUtil.getHeadPath(e), a = c.pathUtil.getHeadPath(t);
            if ("*" !== o && o !== a) return null;
            r.push(a), e = c.pathUtil.getFromHeadPath(e), t = c.pathUtil.getFromHeadPath(t);
        }
        return r;
    }, c.model.transform.expandWildcards = function(s, e) {
        c.each(e, function(e, t) {
            var n = s.queuedTransforms;
            s.pathOp.push(c.pathUtil.escapeSegment(t.toString()));
            for (var r = 0; r < n.length; ++r) if (c.pathUtil.matchPath(n[r].matchPath, s.path, !0)) {
                var o = c.copy(n[r].transformSpec);
                void 0 !== o.inputPath && !c.model.transform.hasWildcard(o.inputPath) || (o.inputPath = ""), 
                s.inputPrefixOp.push(s.path), s.outputPrefixOp.push(s.path);
                var a = c.model.transform.lookupType(o.type), i = c.model.transform.doTransform(o, s, a);
                void 0 !== i && c.model.transform.setValue(null, i, s), s.outputPrefixOp.pop(), 
                s.inputPrefixOp.pop();
            }
            c.isPrimitive(e) || c.model.transform.expandWildcards(s, e), s.pathOp.pop();
        });
    }, c.model.transform.hasWildcard = function(e) {
        return "string" == typeof e && -1 !== e.indexOf("*");
    }, c.model.transform.maybePushWildcard = function(e, t) {
        var n, r = c.model.transform.hasWildcard;
        return r(e.inputPath) ? n = c.model.composePaths(t.inputPrefix, e.inputPath) : (r(t.outputPrefix) || r(e.outputPath)) && (n = c.model.composePaths(t.outputPrefix, e.outputPath)), 
        !!n && (t.queuedTransforms.push({
            transformSpec: e,
            outputPrefix: t.outputPrefix,
            inputPrefix: t.inputPrefix,
            matchPath: n
        }), !0);
    }, c.model.sortByKeyLength = function(e) {
        return c.keys(e).sort(c.compareStringLength(!0));
    }, c.model.transform.handleTransformStrategy = function(e, t, n) {
        return c.model.transform.maybePushWildcard(e, t) ? void 0 : c.model.transform.doTransform(e, t, n);
    }, c.model.transform.handleInvertStrategy = function(e, t, n) {
        e = c.copy(e), c.hasGrade(n.defaults, "fluid.standardTransformFunction") && (e = c.model.transform.invertPaths(e, t));
        var r = n.defaults && n.defaults.invertConfiguration;
        if (r) {
            var o = c.invokeGlobalFunction(r, [ e, t ]);
            t.inverted.push(o);
        } else t.inverted.push(c.model.transform.uninvertibleTransform);
    }, c.model.transform.handleCollectStrategy = function(e, t, n) {
        var r = n.defaults, o = c.hasGrade(r, "fluid.standardInputTransformFunction"), a = c.hasGrade(r, "fluid.multiInputTransformFunction");
        o && c.model.transform.accumulateStandardInputPath("input", e, t, t.inputPaths), 
        a && c.model.transform.accumulateMultiInputPaths(r.inputVariables, e, t, t.inputPaths);
        var i = r.collectInputPaths;
        if (i) {
            var s = c.makeArray(c.invokeGlobalFunction(i, [ e, t ]));
            Array.prototype.push.apply(t.inputPaths, s);
        }
    }, c.model.transform.lookupType = function(e, t) {
        return e || c.fail("Transformation record is missing a type name: ", t), -1 === e.indexOf(".") && (e = "fluid.transforms." + e), 
        {
            defaults: c.defaults(e),
            typeName: e
        };
    }, c.model.transform.processRule = function(e, r) {
        var t, n, o;
        if ("string" == typeof e ? e = c.model.transform.pathToRule(e) : void 0 !== e.literalValue && (e = c.model.transform.literalValueToRule(e.literalValue)), 
        e.transform) if (c.isArrayable(e.transform)) {
            var a = e.transform;
            t = void 0;
            for (var i = 0; i < a.length; ++i) n = a[i], o = c.model.transform.lookupType(n.type), 
            r.transformHandler(n, r, o);
        } else n = e.transform, o = c.model.transform.lookupType(n.type), t = r.transformHandler(n, r, o);
        return c.isArrayable(e) && (r.collectedFlatSchemaOpts = r.collectedFlatSchemaOpts || {}, 
        r.collectedFlatSchemaOpts[r.outputPrefix] = "array"), c.each(e, function(e, t) {
            if ("transform" !== t) {
                r.outputPrefixOp.push(t);
                var n = r.expand(e, r);
                void 0 !== n && (c.model.transform.setValue(null, n, r), n = void 0), r.outputPrefixOp.pop();
            }
        }), t;
    }, c.model.transform.makeStrategy = function(t, e, n) {
        n = n || c.model.transform.processRule, t.expand = function(e) {
            return n(e, t);
        }, t.outputPrefixOp = c.model.makePathStack(t, "outputPrefix"), t.inputPrefixOp = c.model.makePathStack(t, "inputPrefix"), 
        t.transformHandler = e;
    }, c.model.transform.uninvertibleTransform = Object.freeze({}), c.model.transform.invertConfiguration = function(e) {
        var t = {
            inverted: []
        };
        return c.model.transform.makeStrategy(t, c.model.transform.handleInvertStrategy), 
        t.expand(e), -1 === t.inverted.indexOf(c.model.transform.uninvertibleTransform) ? {
            transform: t.inverted
        } : c.model.transform.uninvertibleTransform;
    }, c.model.transform.collectInputPaths = function(e) {
        var t = {
            inputPaths: []
        };
        c.model.transform.makeStrategy(t, c.model.transform.handleCollectStrategy), t.expand(e);
        var n = c.arrayToHash(t.inputPaths);
        return Object.keys(n);
    }, c.model.transform.flatSchemaStrategy = function(s, l) {
        var u = c.model.sortByKeyLength(s);
        return function(e, t, n, r) {
            for (var o = l.parser.compose.apply(null, r.slice(0, n)), a = 0; a < u.length; ++a) {
                var i = u[a];
                if (null !== c.pathUtil.matchPath(i, o, !0)) return s[i];
            }
        };
    }, c.model.transform.defaultSchemaValue = function(e) {
        return "array" === (c.isPrimitive(e) ? e : e.type) ? [] : {};
    }, c.model.transform.isomorphicSchemaStrategy = function(a, i) {
        return function(e, t, n, r) {
            var o = c.get(a, r.slice(0, n), i);
            return c.isArrayable(o) ? "array" : "object";
        };
    }, c.model.transform.decodeStrategy = function(e, t, n) {
        return t.isomorphic ? c.model.transform.isomorphicSchemaStrategy(e, n) : t.flatSchema ? c.model.transform.flatSchemaStrategy(t.flatSchema, n) : void 0;
    }, c.model.transform.schemaToCreatorStrategy = function(a) {
        return function(e, t, n, r) {
            if (void 0 === e[t]) {
                var o = a(e, t, n, r);
                return e[t] = c.model.transform.defaultSchemaValue(o), e[t];
            }
        };
    }, c.model.transform.sequence = function(e, t, n) {
        for (var r = 0; r < t.length; ++r) e = c.model.transform(e, t[r], n);
        return e;
    }, c.model.compareByPathLength = function(e, t) {
        var n = e.path.length - t.path.length;
        return 0 == n ? e.sequence - t.sequence : n;
    }, c.model.fireSortedChanges = function(e, t) {
        e.sort(c.model.compareByPathLength), c.fireChanges(t, e);
    }, c.model.transformWithRules = function(e, t, n) {
        n = n || {};
        var r = c.model.escapedGetConfig, o = c.model.escapedSetConfig, a = c.model.transform.decodeStrategy(e, n, r), i = {
            source: e,
            target: {
                model: a ? c.model.transform.defaultSchemaValue(a(null, "", 0, [ "" ])) : {}
            },
            resolverGetConfig: r,
            resolverSetConfig: o,
            collectedFlatSchemaOpts: void 0,
            queuedChanges: [],
            queuedTransforms: []
        };
        c.model.transform.makeStrategy(i, c.model.transform.handleTransformStrategy), i.applier = {
            fireChangeRequest: function(e) {
                e.sequence = i.queuedChanges.length, i.queuedChanges.push(e);
            }
        }, c.bindRequestChange(i.applier), i.expand(t);
        var s = c.copy(o);
        return void 0 !== i.collectedFlatSchemaOpts && (l.extend(i.collectedFlatSchemaOpts, n.flatSchema), 
        a = c.model.transform.flatSchemaStrategy(i.collectedFlatSchemaOpts, r)), s.strategies = [ c.model.defaultFetchStrategy, a ? c.model.transform.schemaToCreatorStrategy(a) : c.model.defaultCreatorStrategy ], 
        i.finalApplier = n.finalApplier || c.makeHolderChangeApplier(i.target, {
            resolverSetConfig: s
        }), 0 < i.queuedTransforms.length && (i.typeStack = [], i.pathOp = c.model.makePathStack(i, "path"), 
        c.model.transform.expandWildcards(i, e)), c.model.fireSortedChanges(i.queuedChanges, i.finalApplier), 
        i.target.model;
    }, l.extend(c.model.transformWithRules, c.model.transform), c.model.transform = c.model.transformWithRules, 
    c.transformOne = function(e) {
        return {
            transformOptions: {
                transformer: "fluid.model.transformWithRules",
                config: e
            }
        };
    }, c.transformMany = function(e) {
        return {
            transformOptions: {
                transformer: "fluid.model.transform.sequence",
                config: e
            }
        };
    };
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(l, u) {
    "use strict";
    u.registerNamespace("fluid.model.transform"), u.registerNamespace("fluid.transforms"), 
    u.defaults("fluid.transforms.value", {
        gradeNames: "fluid.standardTransformFunction",
        invertConfiguration: "fluid.identity"
    }), u.transforms.value = u.identity, u.transforms.identity = u.transforms.value, 
    u.defaults("fluid.transforms.identity", {
        gradeNames: "fluid.transforms.value"
    }), u.transforms.invertToIdentity = function(e) {
        return e.type = "fluid.transforms.identity", e;
    }, u.defaults("fluid.transforms.literalValue", {
        gradeNames: "fluid.standardOutputTransformFunction"
    }), u.transforms.literalValue = function(e) {
        return e.input;
    }, u.defaults("fluid.transforms.stringToNumber", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.stringToNumber.invert"
    }), u.transforms.stringToNumber = function(e) {
        var t = Number(e);
        return isNaN(t) ? void 0 : t;
    }, u.transforms.stringToNumber.invert = function(e) {
        return e.type = "fluid.transforms.numberToString", e;
    }, u.defaults("fluid.transforms.numberToString", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.numberToString.invert"
    }), u.transforms.numberToString = function(e, t) {
        if ("number" == typeof e) return "number" != typeof t.scale || isNaN(t.scale) ? e.toString() : u.roundToDecimal(e, t.scale, t.method).toString();
    }, u.transforms.numberToString.invert = function(e) {
        return e.type = "fluid.transforms.stringToNumber", e;
    }, u.defaults("fluid.transforms.count", {
        gradeNames: "fluid.standardTransformFunction"
    }), u.transforms.count = function(e) {
        return u.makeArray(e).length;
    }, u.defaults("fluid.transforms.round", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.invertToIdentity"
    }), u.transforms.round = function(e, t) {
        return u.roundToDecimal(e, t.scale, t.method);
    }, u.defaults("fluid.transforms.delete", {
        gradeNames: "fluid.transformFunction"
    }), u.transforms.delete = function(e, t) {
        var n = u.model.composePaths(t.outputPrefix, e.outputPath);
        t.applier.change(n, null, "DELETE");
    }, u.defaults("fluid.transforms.firstValue", {
        gradeNames: "fluid.standardOutputTransformFunction"
    }), u.transforms.firstValue = function(e, t) {
        e.values && e.values.length || u.fail('firstValue transformer requires an array of values at path named "values", supplied', e);
        for (var n = 0; n < e.values.length; n++) {
            var r = e.values[n], o = t.expand(r);
            if (void 0 !== o) return o;
        }
    }, u.defaults("fluid.transforms.linearScale", {
        gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.linearScale.invert",
        inputVariables: {
            factor: 1,
            offset: 0
        }
    }), u.transforms.linearScale = function(e, t) {
        var n = t.factor(), r = t.offset();
        if ("number" == typeof e && "number" == typeof n && "number" == typeof r) return e * n + r;
    }, u.transforms.linearScale.invert = function(e) {
        return delete e.factorPath, delete e.offsetPath, void 0 !== e.factor && (e.factor = 0 === e.factor ? 0 : 1 / e.factor), 
        void 0 !== e.offset && (e.offset = -e.offset * (void 0 !== e.factor ? e.factor : 1)), 
        e;
    }, u.defaults("fluid.transforms.binaryOp", {
        gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardOutputTransformFunction" ],
        inputVariables: {
            left: null,
            right: null
        }
    }), u.transforms.binaryLookup = {
        "===": function(e, t) {
            return u.model.isSameValue(e, t);
        },
        "!==": function(e, t) {
            return !u.model.isSameValue(e, t);
        },
        "<=": function(e, t) {
            return e <= t;
        },
        "<": function(e, t) {
            return e < t;
        },
        ">=": function(e, t) {
            return t <= e;
        },
        ">": function(e, t) {
            return t < e;
        },
        "+": function(e, t) {
            return e + t;
        },
        "-": function(e, t) {
            return e - t;
        },
        "*": function(e, t) {
            return e * t;
        },
        "/": function(e, t) {
            return e / t;
        },
        "%": function(e, t) {
            return e % t;
        },
        "&&": function(e, t) {
            return e && t;
        },
        "||": function(e, t) {
            return e || t;
        }
    }, u.transforms.binaryOp = function(e, t, n) {
        var r = e.left(), o = e.right(), a = u.model.transform.getValue(void 0, t.operator, n), i = u.transforms.binaryLookup[a];
        return void 0 === i || void 0 === r || void 0 === o ? void 0 : i(r, o);
    }, u.defaults("fluid.transforms.condition", {
        gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardOutputTransformFunction" ],
        inputVariables: {
            true: null,
            false: null,
            condition: null
        }
    }), u.transforms.condition = function(e) {
        var t = e.condition();
        if (null !== t) return e[t ? "true" : "false"]();
    }, u.defaults("fluid.transforms.valueMapper", {
        gradeNames: [ "fluid.lens" ],
        invertConfiguration: "fluid.transforms.valueMapper.invert",
        collectInputPaths: "fluid.transforms.valueMapper.collect"
    }), u.model.transform.compareMatches = function(e, t) {
        var n = t.matchValue - e.matchValue;
        return 0 == n ? e.index - t.index : n;
    }, u.transforms.valueMapper = function(e, t) {
        e.match || u.fail('valueMapper requires an array or hash of matches at path named "match", supplied ', e);
        var n = u.model.transform.getValue(e.defaultInputPath, e.defaultInput, t), r = u.isArrayable(e.match) ? u.transforms.valueMapper.longFormMatch(n, e, t) : e.match[n];
        if (void 0 === r && (r = e.noMatch), void 0 !== r) {
            var o, a = void 0 === r.outputPath ? e.defaultOutputPath : r.outputPath;
            return t.outputPrefixOp.push(a), o = u.isPrimitive(r) ? r : r.outputUndefinedValue ? void 0 : void 0 === (o = u.model.transform.resolveParam(r, t, "outputValue", void 0)) ? e.defaultOutputValue : o, 
            "string" == typeof a && void 0 !== o && (u.model.transform.setValue(void 0, o, t, e.merge), 
            o = void 0), t.outputPrefixOp.pop(), o;
        }
    }, u.transforms.valueMapper.longFormMatch = function(e, t, n) {
        var r = t.match;
        0 === r.length && u.fail("valueMapper supplied empty list of matches: ", t);
        for (var o = [], a = 0; a < r.length; ++a) {
            var i = r[a], s = i.inputPath ? u.model.transform.getValue(i.inputPath, void 0, n) : e, l = u.model.transform.matchValue(i.inputValue, s, i.partialMatches);
            o[a] = {
                index: a,
                matchValue: l
            };
        }
        return o.sort(u.model.transform.compareMatches), o[0].matchValue <= 0 ? void 0 : r[o[0].index];
    }, u.transforms.valueMapper.invert = function(o, a) {
        var i = [], e = {
            type: "fluid.transforms.valueMapper",
            match: i
        }, s = u.isArrayable(o.match);
        e.defaultInputPath = u.model.composePaths(a.outputPrefix, o.defaultOutputPath), 
        e.defaultOutputPath = u.model.composePaths(a.inputPrefix, o.defaultInputPath);
        var l = u.firstDefined;
        return u.each(o.match, function(e, t) {
            if (!0 !== e.outputUndefinedValue) {
                var n = {}, r = l(s ? e.inputValue : t, o.defaultInputValue);
                void 0 === r && u.fail("Failure inverting configuration for valueMapper - inputValue could not be resolved for record " + t + ": ", o), 
                n.outputValue = r, n.inputValue = !s && u.isPrimitive(e) ? e : l(e.outputValue, o.defaultOutputValue), 
                e.outputPath && (n.inputPath = u.model.composePaths(a.outputPrefix, l(e.outputPath, o.outputPath))), 
                e.inputPath && (n.outputPath = u.model.composePaths(a.inputPrefix, l(e.inputPath, o.inputPath))), 
                i.push(n);
            }
        }), e;
    }, u.transforms.valueMapper.collect = function(e, t) {
        var n = [];
        return u.model.transform.accumulateStandardInputPath("defaultInput", e, t, n), u.each(e.match, function(e) {
            u.model.transform.accumulateInputPath(e.inputPath, t, n);
        }), n;
    }, u.defaults("fluid.transforms.arrayToSetMembership", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.arrayToSetMembership.invert"
    }), u.transforms.arrayToSetMembership = function(r, o, a) {
        var i = {}, e = o.options;
        return r && u.isArrayable(r) || u.fail("arrayToSetMembership didn't find array at inputPath nor passed as value.", o), 
        e || u.fail("arrayToSetMembership requires an options block set"), void 0 === o.presentValue && (o.presentValue = !0), 
        void 0 === o.missingValue && (o.missingValue = !1), u.each(e, function(e, t) {
            var n = -1 !== r.indexOf(t) ? o.presentValue : o.missingValue;
            u.set(i, e, n, a.resolverSetConfig);
        }), i;
    }, u.transforms.arrayToSetMembership.invertWithType = function(e, t, n) {
        e.type = n;
        var r = {};
        return u.each(e.options, function(e, t) {
            r[e] = t;
        }), e.options = r, e;
    }, u.transforms.arrayToSetMembership.invert = function(e, t) {
        return u.transforms.arrayToSetMembership.invertWithType(e, t, "fluid.transforms.setMembershipToArray");
    }, u.defaults("fluid.transforms.setMembershipToArray", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.setMembershipToArray.invert"
    }), u.transforms.setMembershipToArray = function(n, r, o) {
        var e = r.options;
        e || u.fail("setMembershipToArray requires an options block specified"), void 0 === r.presentValue && (r.presentValue = !0), 
        void 0 === r.missingValue && (r.missingValue = !1);
        var a = [];
        return u.each(e, function(e, t) {
            u.get(n, t, o.resolverGetConfig) === r.presentValue && a.push(e);
        }), a;
    }, u.transforms.setMembershipToArray.invert = function(e, t) {
        return u.transforms.arrayToSetMembership.invertWithType(e, t, "fluid.transforms.arrayToSetMembership");
    }, u.model.transform.applyPaths = function(e, t, n) {
        for (var r = 0; r < n.length; ++r) "push" === e ? t.push(n[r]) : t.pop();
    }, u.model.transform.expandInnerValues = function(e, t, n, r) {
        var o = n.inputPrefixOp, a = n.outputPrefixOp, i = u.model.transform.applyPaths;
        i("push", o, e), i("push", a, t);
        var s = {};
        return u.each(r, function(e) {
            var t = n.expand(e);
            u.isPrimitive(t) ? s = t : l.extend(!0, s, t);
        }), i("pop", a, t), i("pop", o, e), s;
    }, u.defaults("fluid.transforms.indexArrayByKey", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.indexArrayByKey.invert"
    }), u.transforms.indexArrayByKey = function(e, a, i) {
        void 0 === a.key && u.fail("indexArrayByKey requires a 'key' option.", a), u.isArrayable(e) || u.fail("indexArrayByKey didn't find array at inputPath.", a);
        var s = {}, l = a.key;
        return u.each(e, function(e, t) {
            var n = e[l], r = typeof n;
            "string" != r && "boolean" != r && "number" != r && u.fail("indexArrayByKey encountered untransformable array due to missing or invalid key", e);
            var o = u.copy(e);
            delete o[l], a.innerValue && (o = u.model.transform.expandInnerValues([ i.inputPrefix, a.inputPath, t.toString() ], [ a.outputPath, n ], i, a.innerValue)), 
            s[n] = o;
        }), s;
    }, u.transforms.indexArrayByKey.invert = function(e) {
        if (e.type = "fluid.transforms.deindexIntoArrayByKey", e.innerValue) for (var t = e.innerValue, n = 0; n < t.length; ++n) {
            var r = u.model.transform.invertConfiguration(t[n]);
            if (r === u.model.transform.uninvertibleTransform) return r;
            t[n] = r;
        }
        return e;
    }, u.defaults("fluid.transforms.deindexIntoArrayByKey", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.deindexIntoArrayByKey.invert"
    }), u.transforms.deindexIntoArrayByKey = function(e, r, o) {
        void 0 === r.key && u.fail('deindexIntoArrayByKey requires a "key" option.', r);
        var a = [], i = r.key;
        return u.each(e, function(e, t) {
            var n = {};
            n[i] = t, r.innerValue && (e = u.model.transform.expandInnerValues([ r.inputPath, t ], [ r.outputPath, a.length.toString() ], o, r.innerValue)), 
            l.extend(!0, n, e), a.push(n);
        }), a;
    }, u.transforms.deindexIntoArrayByKey.invert = function(e) {
        if (e.type = "fluid.transforms.indexArrayByKey", e.innerValue) for (var t = e.innerValue, n = 0; n < t.length; ++n) t[n] = u.model.transform.invertConfiguration(t[n]);
        return e;
    }, u.defaults("fluid.transforms.limitRange", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.invertToIdentity"
    }), u.transforms.limitRange = function(e, t) {
        var n = t.min;
        void 0 !== n && e < (n += t.excludeMin || 0) && (e = n);
        var r = t.max;
        void 0 !== r && (r -= t.excludeMax || 0) < e && (e = r);
        return e;
    }, u.defaults("fluid.transforms.indexOf", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.indexOf.invert"
    }), u.transforms.indexOf = function(e, t) {
        "number" == typeof t.notFound && 0 <= t.notFound && u.fail("A positive number is not allowed as 'notFound' value for indexOf");
        var n = u.transforms.parseIndexationOffset(t.offset, "indexOf"), r = u.makeArray(t.array).indexOf(e);
        return -1 === r && t.notFound ? t.notFound : r + n;
    }, u.transforms.indexOf.invert = function(e, t) {
        var n = u.transforms.invertArrayIndexation(e, t);
        return n.type = "fluid.transforms.dereference", n;
    }, u.defaults("fluid.transforms.dereference", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.dereference.invert"
    }), u.transforms.dereference = function(e, t) {
        if ("number" == typeof e) {
            var n = u.transforms.parseIndexationOffset(t.offset, "dereference");
            return u.makeArray(t.array)[e + n];
        }
    }, u.transforms.dereference.invert = function(e, t) {
        var n = u.transforms.invertArrayIndexation(e, t);
        return n.type = "fluid.transforms.indexOf", n;
    }, u.transforms.parseIndexationOffset = function(e, t) {
        var n = 0;
        return void 0 !== e && (n = u.parseInteger(e), isNaN(n) && u.fail(t + ' requires the value of "offset" to be an integer or a string that can be converted to an integer. ' + e + " is invalid.")), 
        n;
    }, u.transforms.invertArrayIndexation = function(e) {
        return isNaN(Number(e.offset)) || (e.offset = -1 * Number(e.offset)), e;
    }, u.defaults("fluid.transforms.stringTemplate", {
        gradeNames: "fluid.standardOutputTransformFunction"
    }), u.transforms.stringTemplate = function(e) {
        return u.stringTemplate(e.template, e.terms);
    }, u.defaults("fluid.transforms.free", {
        gradeNames: "fluid.transformFunction"
    }), u.transforms.free = function(e) {
        var t = u.makeArray(e.args);
        return u.invokeGlobalFunction(e.func, t);
    }, u.defaults("fluid.transforms.quantize", {
        gradeNames: "fluid.standardTransformFunction",
        collectInputPaths: "fluid.transforms.quantize.collect"
    }), u.transforms.quantize = function(e, t, n) {
        t.ranges && t.ranges.length || u.fail("fluid.transforms.quantize should have a key called ranges containing an array defining ranges to quantize");
        for (var r = 0; r < t.ranges.length; r++) {
            var o = t.ranges[r];
            if (e <= o.upperBound || void 0 === o.upperBound && e >= Number.NEGATIVE_INFINITY) return u.isPrimitive(o.output) ? o.output : n.expand(o.output);
        }
    }, u.transforms.quantize.collect = function(e, t) {
        e.ranges.forEach(function(e) {
            u.isPrimitive(e.output) || t.expand(e.output);
        });
    }, u.defaults("fluid.transforms.inRange", {
        gradeNames: "fluid.standardTransformFunction"
    }), u.transforms.inRange = function(e, t) {
        return (void 0 === t.min || t.min <= e) && (void 0 === t.max || t.max >= e);
    }, u.transforms.stringToBoolean = function(e) {
        return !!e && !("0" === e || "false" === e);
    }, u.transforms.stringToBoolean.invert = function(e) {
        return e.type = "fluid.transforms.booleanToString", e;
    }, u.defaults("fluid.transforms.stringToBoolean", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.stringToBoolean.invert"
    }), u.transforms.booleanToString = function(e) {
        return e ? "true" : "false";
    }, u.transforms.booleanToString.invert = function(e) {
        return e.type = "fluid.transforms.stringToBoolean", e;
    }, u.defaults("fluid.transforms.booleanToString", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.booleanToString.invert"
    }), u.transforms.JSONstringToObject = function(e) {
        try {
            return JSON.parse(e);
        } catch (e) {
            return;
        }
    }, u.transforms.JSONstringToObject.invert = function(e) {
        return e.type = "fluid.transforms.objectToJSONString", e;
    }, u.defaults("fluid.transforms.JSONstringToObject", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.JSONstringToObject.invert"
    }), u.transforms.objectToJSONString = function(e, t) {
        var n = t.space || 0;
        return JSON.stringify(e, null, n);
    }, u.transforms.objectToJSONString.invert = function(e) {
        return e.type = "fluid.transforms.JSONstringToObject", e;
    }, u.defaults("fluid.transforms.objectToJSONString", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.objectToJSONString.invert"
    }), u.transforms.stringToDate = function(e) {
        var t = new Date(e);
        return isNaN(t.getTime()) ? void 0 : t;
    }, u.transforms.stringToDate.invert = function(e) {
        return e.type = "fluid.transforms.dateToString", e;
    }, u.defaults("fluid.transforms.stringToDate", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.stringToDate.invert"
    }), u.transforms.dateToString = function(e) {
        if (e instanceof Date) {
            var t = e.toISOString();
            return t.substring(0, t.indexOf("T"));
        }
    }, u.transforms.dateToString.invert = function(e) {
        return e.type = "fluid.transforms.stringToDate", e;
    }, u.defaults("fluid.transforms.dateToString", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.dateToString.invert"
    }), u.transforms.dateTimeToString = function(e) {
        return e instanceof Date ? e.toISOString() : void 0;
    }, u.defaults("fluid.transforms.dateTimeToString", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.dateToString.invert"
    });
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(e, a) {
    "use strict";
    a.registerNamespace("fluid.contextAware"), a.defaults("fluid.contextAware.marker", {
        gradeNames: [ "fluid.component" ]
    }), a.contextAware.makeCheckMarkers = function(e, n, r) {
        a.each(e, function(e, t) {
            a.constructSingle(n, {
                type: t,
                gradeNames: "fluid.contextAware.marker",
                value: e
            }, r);
        });
    }, a.contextAware.performChecks = function(e) {
        return a.transform(e, function(e) {
            return "function" == typeof e ? e = {
                func: e
            } : "string" == typeof e && (e = {
                funcName: e
            }), a.isPrimitive(e) ? e : "value" in e ? e.value : "func" in e ? e.func() : "funcName" in e ? a.invokeGlobalFunction(e.funcName) : void a.fail("Error in contextAwareness check record ", e, " - must contain an entry with name value, func, or funcName");
        });
    }, a.contextAware.makeChecks = function(e, t, n) {
        var r = a.contextAware.performChecks(e);
        a.contextAware.makeCheckMarkers(r, t, n);
    }, a.contextAware.forgetChecks = function(e, r, o) {
        o = o || a.globalInstantiator, r = r || [];
        var t = a.makeArray(e);
        a.each(t, function(e) {
            var t = a.typeNameToMemberName(e), n = a.model.parseToSegments(r, o.parseEL, !0);
            n.push(t), a.destroy(n, o);
        });
    }, a.defaults("fluid.contextAware", {
        gradeNames: [ "{that}.check" ],
        mergePolicy: {
            contextAwareness: "noexpand"
        },
        contextAwareness: {},
        invokers: {
            check: {
                funcName: "fluid.contextAware.check",
                args: [ "{that}", "{that}.options.contextAwareness" ]
            }
        }
    }), a.contextAware.getCheckValue = function(e, t) {
        var n = a.parseContextReference(t), r = a.resolveContext(n.context, e), o = n.path || [ "options", "value" ];
        return a.getForComponent(r, o);
    }, a.contextAware.checkOne = function(n, e) {
        e.checks && e.checks.contextValue && a.fail("Nesting error in contextAwareness record ", e, ' - the "checks" entry must contain a hash and not a contextValue/gradeNames record at top level');
        var t = a.parsePriorityRecords(e.checks, "contextAwareness checkRecord");
        return a.find(t, function(e) {
            e.contextValue || a.fail("Cannot perform check for contextAwareness record ", e, ' without a valid field named "contextValue"');
            var t = a.contextAware.getCheckValue(n, e.contextValue);
            if (void 0 === e.equals ? t : t === e.equals) return e.gradeNames;
        }, e.defaultGradeNames);
    }, a.contextAware.check = function(n, e) {
        var r = [], t = a.parsePriorityRecords(e, "contextAwareness adaptationRecord");
        return a.each(t, function(e) {
            var t = a.contextAware.checkOne(n, e);
            r = r.concat(a.makeArray(t));
        }), r;
    }, a.contextAware.makeAdaptation = function(e) {
        a.expect("fluid.contextAware.makeAdaptation", e, [ "distributionName", "targetName", "adaptationName", "checkName", "record" ]), 
        a.defaults(e.distributionName, {
            gradeNames: [ "fluid.component" ],
            distributeOptions: {
                target: "{/ " + e.targetName + "}.options.contextAwareness." + e.adaptationName + ".checks." + e.checkName,
                record: e.record
            }
        }), a.constructSingle([], e.distributionName);
    }, a.contextAware.isBrowser = function() {
        return "undefined" != typeof window && !!window.document;
    }, a.contextAware.makeChecks({
        "fluid.browser": {
            funcName: "fluid.contextAware.isBrowser"
        }
    }), a.registerNamespace("fluid.contextAware.browser"), a.contextAware.browser.getPlatformName = function() {
        return "undefined" != typeof navigator && navigator.platform ? navigator.platform : void 0;
    }, a.contextAware.browser.getUserAgent = function() {
        return "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent : void 0;
    }, a.contextAware.makeChecks({
        "fluid.browser.platformName": {
            funcName: "fluid.contextAware.browser.getPlatformName"
        },
        "fluid.browser.userAgent": {
            funcName: "fluid.contextAware.browser.getUserAgent"
        }
    });
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(r, n) {
    "use strict";
    var e, t;
    n.uaMatch = function(e) {
        e = e.toLowerCase();
        var t = /(chrome)[ \/]([\w.]+)/.exec(e) || /(webkit)[ \/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e) || /(msie) ([\w.]+)/.exec(e) || e.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e) || [];
        return {
            browser: t[1] || "",
            version: t[2] || "0"
        };
    }, r.browser || (navigator.userAgent.match(/Trident\/7\./) ? t = {
        msie: !0,
        version: 11
    } : (t = {}, (e = n.uaMatch(navigator.userAgent)).browser && (t[e.browser] = !0, 
    t.version = e.version), t.chrome ? t.webkit = !0 : t.webkit && (t.safari = !0)), 
    r.browser = t);
    var o = "fluid-scoped-data";
    n.getScopedData = function(e, t) {
        var n = r(e).data(o);
        return n ? n[t] : void 0;
    }, n.setScopedData = function(e, t, n) {
        r(e).each(function() {
            var e = r.data(this, o) || {};
            e[t] = n, r.data(this, o, e);
        });
    };
    var a = null;
    r(document).on("focusin", function(e) {
        a = e.target;
    }), n.getLastFocusedElement = function() {
        return a;
    };
    var i = "enablement";
    n.enabled = function(e, t) {
        if (e = r(e), void 0 === t) return !1 !== n.getScopedData(e, i);
        r("*", e).add(e).each(function() {
            void 0 !== n.getScopedData(this, i) ? n.setScopedData(this, i, t) : /select|textarea|input/i.test(this.nodeName) && r(this).prop("disabled", !t);
        }), n.setScopedData(e, i, t);
    }, n.initEnablement = function(e) {
        n.setScopedData(e, i, !0);
    }, n.resolveEventTarget = function(e) {
        for (;e.originalEvent && e.originalEvent.target; ) e = e.originalEvent;
        return e.target;
    }, r.each([ "focus", "blur" ], function(e, t) {
        n[t] = function(e) {
            return function(e, t) {
                return (e = r(e)).trigger("fluid-" + t), e.triggerHandler(t), e[t](), e;
            }(e, t);
        };
    }), n.changeElementValue = function(e, t) {
        (e = r(e)).val(t).change();
    };
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(e, i) {
    "use strict";
    i.dom = i.dom || {};
    function s(e) {
        if (e.node.firstChild) return e.node = e.node.firstChild, e.depth += 1, e;
        for (;e.node; ) {
            if (e.node.nextSibling) return e.node = e.node.nextSibling, e;
            e.node = e.node.parentNode, e.depth -= 1;
        }
        return e;
    }
    i.dom.iterateDom = function(e, t, n) {
        for (var r, o = {
            node: e,
            depth: 0
        }, a = e; null !== o.node && 0 <= o.depth && o.depth < i.dom.iterateDom.DOM_BAIL_DEPTH; ) {
            if (r = null, 1 !== o.node.nodeType && !n || (r = t(o.node, o.depth)), r) if ("delete" === r) o.node.parentNode.removeChild(o.node), 
            o.node = a; else if ("stop" === r) return o.node;
            a = o.node, o = s(o);
        }
    }, i.dom.iterateDom.DOM_BAIL_DEPTH = 256, i.dom.isContainer = function(e, t) {
        for (;t; t = t.parentNode) if (e === t) return !0;
        return !1;
    }, i.dom.getElementText = function(e) {
        for (var t = e.childNodes, n = "", r = 0; r < t.length; ++r) {
            var o = t[r];
            3 === o.nodeType && (n += o.nodeValue);
        }
        return n;
    };
}(jQuery, fluid_3_0_0);

fluid_3_0_0 = fluid_3_0_0 || {};

!function(c, d) {
    "use strict";
    d.defaults("fluid.viewComponent", {
        gradeNames: [ "fluid.modelComponent" ],
        initFunction: "fluid.initView",
        argumentMap: {
            container: 0,
            options: 1
        },
        members: {
            dom: "@expand:fluid.initDomBinder({that}, {that}.options.selectors)"
        }
    }), d.dumpSelector = function(e) {
        return "string" == typeof e ? e : e.selector ? e.selector : "";
    }, d.diagnoseFailedView = function(e, t, n, r) {
        if (!t && d.hasGrade(n, "fluid.viewComponent")) {
            var o = d.wrap(r[1]), a = "Instantiation of view component with type " + e + " failed, since ";
            o ? 0 === o.length ? d.fail(a + 'selector "', d.dumpSelector(r[1]), '" did not match any markup in the document') : d.fail(a + " component creator function did not return a value") : d.fail(a + " container argument is empty");
        }
    }, d.checkTryCatchParameter = function() {
        var e = (window.location || {
            search: "",
            protocol: "file:"
        }).search.slice(1).split("&");
        return !0 === d.find(e, function(e) {
            if (0 === e.indexOf("notrycatch")) return !0;
        });
    }, d.notrycatch = d.checkTryCatchParameter(), d.wrap = function(e, t) {
        return t = t || c, !e || e.jquery ? e : t(e);
    }, d.unwrap = function(e) {
        return e && e.jquery ? e[0] : e;
    }, d.container = function(e, t, n) {
        var r = e.selector || e;
        n && (e = d.unwrap(e));
        var o = d.wrap(e, n);
        if (t && (!o || 0 === o.length)) return null;
        if (!o || !o.jquery || 1 !== o.length) {
            "string" != typeof e && (e = o.selector);
            var a = void 0 !== o.length ? o.length : 0;
            d.fail((1 < a ? "More than one (" + a + ") container elements were" : "No container element was") + " found for selector " + e);
        }
        return d.isDOMNode(o[0]) || d.fail("fluid.container was supplied a non-jQueryable element"), 
        o.selector = r, o.context = o.context || e.ownerDocument || document, o;
    }, d.createDomBinder = function(a, i) {
        var s = {
            id: d.allocateGuid(),
            cache: {}
        }, l = a.constructor;
        function u(e, t) {
            return d.allocateSimpleId(t) + "-" + e;
        }
        return s.locate = function(e, t) {
            var n, r, o;
            if (void 0 !== (n = i[e])) return (r = t ? c(t) : a) || d.fail("DOM binder invoked for selector " + e + " without container"), 
            (o = "" === n ? r : n ? "function" == typeof n ? l(n.call(null, d.unwrap(r))) : l(n, r) : l()).selector || (o.selector = n, 
            o.context = r), function(e, t, n) {
                s.cache[u(e, t)] = n;
            }(o.selectorName = e, r, o), o;
        }, s.fastLocate = function(e, t) {
            var n = u(e, t || a), r = s.cache[n];
            return r || s.locate(e, t);
        }, s.clear = function() {
            s.cache = {};
        }, s.refresh = function(e, t) {
            var n = t || a;
            "string" == typeof e && (e = [ e ]), void 0 === n.length && (n = [ n ]);
            for (var r = 0; r < e.length; ++r) for (var o = 0; o < n.length; ++o) s.locate(e[r], n[o]);
        }, s.resolvePathSegment = s.locate, s;
    }, d.expectFilledSelector = function(e, t) {
        e && 0 === e.length && e.jquery && d.fail(t + ': selector "' + e.selector + '" with name ' + e.selectorName + " returned no results in context " + d.dumpEl(e.context));
    }, d.initView = function(e, t, n, r) {
        var o = d.container(t, !0);
        if (d.expectFilledSelector(o, 'Error instantiating component with name "' + e), 
        !o) return null;
        var a = d.initLittleComponent(e, n, r || {
            gradeNames: [ "fluid.viewComponent" ]
        }, function(e) {
            e.container = o;
        });
        a.dom || d.initDomBinder(a);
        var i = a.options.jQuery;
        return d.log("Constructing view component " + e + " with container " + o.constructor.expando + (i ? " user jQuery " + i.expando : "") + " env: " + c.expando), 
        a;
    }, d.initDomBinder = function(e, t) {
        return e.container || d.fail("fluid.initDomBinder called for component with typeName " + e.typeName + ' without an initialised container - this has probably resulted from placing "fluid.viewComponent" in incorrect position in grade merging order.  Make sure to place it to the right of any non-view grades in the gradeNames list to ensure that it overrides properly: resolved gradeNames is ', e.options.gradeNames, " for component ", e), 
        e.dom = d.createDomBinder(e.container, t || e.options.selectors || {}), e.locate = e.dom.locate, 
        e.dom;
    }, d.findAncestor = function(e, t) {
        for (e = d.unwrap(e); e; ) {
            if (t(e)) return e;
            e = e.parentNode;
        }
    }, d.findForm = function(e) {
        return d.findAncestor(e, function(e) {
            return "form" === e.nodeName.toLowerCase();
        });
    }, d.each([ "text", "html" ], function(n) {
        d[n] = function(e, t) {
            return e = c(e), void 0 === t ? e[n]() : e[n](t);
        };
    }), d.value = function(e, t) {
        var n = d.unwrap(e), r = !1;
        if (void 0 === n.nodeType && 1 < n.length && (n = n[0], r = !0), "input" !== n.nodeName.toLowerCase() || !/radio|checkbox/.test(n.type)) return void 0 === t ? c(n).val() : c(n).val(t);
        var o, a = n.name;
        if (void 0 === a && d.fail("Cannot acquire value from node " + d.dumpEl(n) + " which does not have name attribute set"), 
        r) o = e; else {
            o = n.ownerDocument.getElementsByName(a);
            var i = d.findForm(n);
            o = c.grep(o, function(e) {
                return e.name === a && (!i || d.dom.isContainer(i, e));
            });
        }
        if (void 0 === t) {
            var s = c.map(o, function(e) {
                return e.checked ? e.value : null;
            });
            return "radio" === n.type ? s[0] : s;
        }
        "boolean" == typeof t && (t = t ? "true" : "false"), c.each(o, function() {
            this.checked = t instanceof Array ? -1 !== t.indexOf(this.value) : t === this.value;
        });
    }, d.BINDING_ROOT_KEY = "fluid-binding-root", d.findData = function(e, t) {
        for (;e; ) {
            var n = c.data(e, t);
            if (n) return n;
            e = e.parentNode;
        }
    }, d.bindFossils = function(e, t, n) {
        c.data(e, d.BINDING_ROOT_KEY, {
            data: t,
            fossils: n
        });
    }, d.boundPathForNode = function(e, t) {
        var n = t[(e = d.unwrap(e)).name || e.id];
        return n ? n.EL : null;
    }, d.applyBoundChange = function(e, t, n) {
        e = d.unwrap(e), void 0 === t && (t = d.value(e)), void 0 === e.nodeType && 0 < e.length && (e = e[0]);
        var r = d.findData(e, d.BINDING_ROOT_KEY);
        r || d.fail("Bound data could not be discovered in any node above " + d.dumpEl(e));
        var o = e.name, a = r.fossils[o];
        a || d.fail("No fossil discovered for name " + o + " in fossil record above " + d.dumpEl(e)), 
        "boolean" == typeof a.oldvalue && (t = !!t[0]);
        var i = r.fossils[o].EL;
        n ? n.fireChangeRequest({
            path: i,
            value: t,
            source: "DOM:" + e.id
        }) : d.set(r.data, i, t);
    }, d.jById = function(e, t) {
        t = t && 9 === t.nodeType ? t : document;
        var n = d.byId(e, t), r = n ? c(n) : [];
        return r.selector = "#" + e, r.context = t, r;
    }, d.byId = function(e, t) {
        var n = (t = t && 9 === t.nodeType ? t : document).getElementById(e);
        return n ? (n.id !== e && d.fail("Problem in document structure - picked up element " + d.dumpEl(n) + " for id " + e + " without this id - most likely the element has a name which conflicts with this id"), 
        n) : null;
    }, d.getId = function(e) {
        return d.unwrap(e).id;
    }, d.allocateSimpleId = function(e) {
        if (!(e = d.unwrap(e)) || d.isPrimitive(e)) return null;
        if (!e.id) {
            var t = "fluid-id-" + d.allocateGuid();
            e.id = t;
        }
        return e.id;
    }, d.getDocument = function(e) {
        var t = d.unwrap(e);
        return 9 === t.nodeType ? t : t.ownerDocument;
    }, d.defaults("fluid.ariaLabeller", {
        gradeNames: [ "fluid.viewComponent" ],
        labelAttribute: "aria-label",
        liveRegionMarkup: '<div class="liveRegion fl-hidden-accessible" aria-live="polite"></div>',
        liveRegionId: "fluid-ariaLabeller-liveRegion",
        invokers: {
            generateLiveElement: {
                funcName: "fluid.ariaLabeller.generateLiveElement",
                args: "{that}"
            },
            update: {
                funcName: "fluid.ariaLabeller.update",
                args: [ "{that}", "{arguments}.0" ]
            }
        },
        listeners: {
            onCreate: {
                func: "{that}.update",
                args: [ null ]
            }
        }
    }), d.ariaLabeller.update = function(e, t) {
        if (t = t || e.options, e.container.attr(e.options.labelAttribute, t.text), t.dynamicLabel) {
            var n = d.jById(e.options.liveRegionId);
            0 === n.length && (n = e.generateLiveElement()), n.text(t.text);
        }
    }, d.ariaLabeller.generateLiveElement = function(e) {
        var t = c(e.options.liveRegionMarkup);
        return t.prop("id", e.options.liveRegionId), c("body").append(t), t;
    };
    var o = "aria-labelling";
    d.getAriaLabeller = function(e) {
        return e = c(e), d.getScopedData(e, o);
    }, d.updateAriaLabel = function(e, t, n) {
        n = c.extend({}, n || {}, {
            text: t
        });
        var r = d.getAriaLabeller(e);
        return r ? r.update(n) : (r = d.ariaLabeller(e, n), d.setScopedData(e, o, r)), r;
    };
    var r = {};
    c(document).click(function(n) {
        for (var e = d.resolveEventTarget(n); e; ) {
            if (r[e.id]) return;
            e = e.parentNode;
        }
        d.each(r, function(e, t) {
            e(n), delete r[t];
        });
    }), d.globalDismissal = function(e, n) {
        d.each(e, function(e) {
            var t = d.unwrap(e).ownerDocument === document ? d.allocateSimpleId(e) : d.allocateGuid();
            n ? r[t] = n : delete r[t];
        });
    }, d.now = function() {
        return Date.now ? Date.now() : new Date().getTime();
    }, d.deadMansBlur = function(n, e) {
        var r = {
            options: c.extend(!0, {}, d.defaults("fluid.deadMansBlur"), e),
            blurPending: !1,
            lastCancel: 0,
            canceller: function(e) {
                d.log("Cancellation through " + e.type + " on " + d.dumpEl(e.target)), r.lastCancel = d.now(), 
                r.blurPending = !1;
            },
            noteProceeded: function() {
                d.globalDismissal(r.options.exclusions);
            },
            reArm: function() {
                d.globalDismissal(r.options.exclusions, r.proceed);
            },
            addExclusion: function(e) {
                d.globalDismissal(e, r.proceed);
            },
            proceed: function(e) {
                d.log("Direct proceed through " + e.type + " on " + d.dumpEl(e.target)), r.blurPending = !1, 
                r.options.handler(n);
            }
        };
        return d.each(r.options.exclusions, function(e) {
            e = c(e), d.each(e, function(e) {
                c(e).on("focusin", r.canceller).on("fluid-focus", r.canceller).click(r.canceller).mousedown(r.canceller);
            });
        }), r.options.cancelByDefault ? r.reArm() : c(n).on("focusout", function(e) {
            d.log("Starting blur timer for element " + d.dumpEl(e.target));
            var t = d.now();
            d.log("back delay: " + (t - r.lastCancel)), t - r.lastCancel > r.options.backDelay && (r.blurPending = !0), 
            setTimeout(function() {
                r.blurPending && r.options.handler(n);
            }, r.options.delay);
        }), r;
    }, d.defaults("fluid.deadMansBlur", {
        gradeNames: "fluid.function",
        delay: 150,
        backDelay: 100
    });
}(jQuery, fluid_3_0_0);