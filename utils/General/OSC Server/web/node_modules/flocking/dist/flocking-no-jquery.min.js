/*! Flocking 2.0.1, Copyright 2019 Colin Clark | flockingjs.org */


!function(n, r) {
    "object" == typeof exports ? (n.flock = exports, r(exports, require("jquery"))) : "function" == typeof define && define.amd ? define([ "exports", "jquery" ], function(e, t) {
        return n.flock = e, n.flock, r(e, t);
    }) : (n.flock = {}, r(n.flock, jQuery));
}(this, function(e, t) {
    window.jQuery = t;
    var n = n || {}, m = m || n;
    !function(y, b) {
        "use strict";
        b.version = "Infusion 3.0.0", b.Error = Error, b.environment = {
            fluid: b
        }, b.global = b.global || "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}, 
        b.invokeLater = function(e) {
            return setTimeout(e, 1);
        }, b.defeatLogging = !0, b.activityTracing = !1, b.activityTrace = [];
        var u = /(%\w+)/g;
        function a(e, t, n, r) {
            for (var a = e[n], o = 0; o < r.length - 1; ++o) a = r[o + 1](a, n);
            t[n] = a;
        }
        b.renderOneActivity = function(e, t) {
            for (var n = !0 === t ? [] : [ "    while " ], r = e.message, a = u.lastIndex = 0; ;) {
                var o = u.exec(r);
                if (!o) break;
                var i = o[1].substring(1);
                n.push(r.substring(a, o.index)), n.push(e.args[i]), a = u.lastIndex;
            }
            return a < r.length && n.push(r.substring(a)), n;
        }, b.renderActivity = function(e, t) {
            return t = t || b.renderOneActivity, b.transform(e, t);
        }, b.singleThreadLocal = function(e) {
            var t = e();
            return function(e) {
                return void 0 === e ? t : t = e;
            };
        }, b.threadLocal = b.singleThreadLocal, b.globalThreadLocal = b.threadLocal(function() {
            return {};
        }), b.getActivityStack = function() {
            var e = b.globalThreadLocal();
            return e.activityStack || (e.activityStack = []), e.activityStack;
        }, b.describeActivity = b.getActivityStack, b.logActivity = function(e) {
            e = e || b.describeActivity();
            var t = b.renderActivity(e).reverse();
            0 < t.length && (b.log("Current activity: "), b.each(t, function(e) {
                b.log.apply(null, e);
            }));
        }, b.pushActivity = function(e, t, n) {
            var r = {
                type: e,
                message: t,
                args: n,
                time: new Date().getTime()
            };
            b.activityTracing && b.activityTrace.push(r), b.passLogLevel(b.logLevel.TRACE) && b.log.apply(null, b.renderOneActivity(r, !0)), 
            b.getActivityStack().push(r);
        }, b.popActivity = function(e) {
            e = e || 1, b.activityTracing && b.activityTrace.push({
                pop: e
            });
            var t = b.getActivityStack(), n = t.length - e;
            t.length = n < 0 ? 0 : n;
        }, b.FluidError = function() {
            var e = Error.apply(this, arguments);
            this.message = e.message;
            try {
                throw e;
            } catch (e) {
                this.stack = e.stack;
            }
            return this;
        }, b.FluidError.prototype = Object.create(Error.prototype), b.logFailure = function(e, t) {
            b.log.apply(null, [ b.logLevel.FAIL, "ASSERTION FAILED: " ].concat(e)), b.logActivity(t);
        }, b.renderLoggingArg = function(e) {
            return void 0 === e ? "undefined" : b.isPrimitive(e) || !b.isPlainObject(e) ? e : JSON.stringify(e);
        }, b.builtinFail = function(e) {
            var t = b.transform(e, b.renderLoggingArg).join("");
            throw new b.FluidError("Assertion failure - check console for more details: " + t);
        }, b.fail = function() {
            var e = b.makeArray(arguments), t = b.makeArray(b.describeActivity());
            b.popActivity(t.length), b.failureEvent ? b.failureEvent.fire(e, t) : (b.logFailure(e, t), 
            b.builtinFail(e, t));
        }, b.expect = function(t, n, e) {
            b.transform(b.makeArray(e), function(e) {
                void 0 === n[e] && b.fail(t + " missing required parameter " + e);
            });
        }, b.isLogging = function() {
            return n[0].priority > b.logLevel.IMPORTANT.priority;
        }, b.isLogLevel = function(e) {
            return b.isMarker(e) && void 0 !== e.priority;
        }, b.passLogLevel = function(e) {
            return e.priority <= n[0].priority;
        }, b.setLogging = function(e) {
            var t;
            "boolean" == typeof e ? t = b.logLevel[e ? "INFO" : "IMPORTANT"] : b.isLogLevel(e) ? t = e : b.fail("Unrecognised fluid logging level ", e), 
            n.unshift(t), b.defeatLogging = !b.isLogging();
        }, b.setLogLevel = b.setLogging, b.popLogging = function() {
            var e = 1 === n.length ? n[0] : n.shift();
            return b.defeatLogging = !b.isLogging(), e;
        }, b.doBrowserLog = function(e) {
            "undefined" != typeof console && (console.debug ? console.debug.apply(console, e) : "function" == typeof console.log && console.log.apply(console, e));
        }, b.log = function() {
            var e = b.makeArray(arguments), t = b.logLevel.INFO;
            b.isLogLevel(e[0]) && (t = e.shift()), b.passLogLevel(t) && b.loggingEvent.fire(e);
        }, b.isValue = function(e) {
            return null != e;
        }, b.isPrimitive = function(e) {
            var t = typeof e;
            return !e || "string" == t || "boolean" == t || "number" == t || "function" == t;
        }, b.isJQuery = function(e) {
            return Boolean(e && e.jquery && e.constructor && e.constructor.prototype && e.constructor.prototype.jquery);
        }, b.isArrayable = function(e) {
            return Boolean(e) && ("[object Array]" === Object.prototype.toString.call(e) || b.isJQuery(e));
        }, b.isPlainObject = function(e, t) {
            var n = Object.prototype.toString.call(e);
            return "[object Array]" === n ? !t : "[object Object]" === n && (!e.constructor || !e.constructor.prototype || Object.prototype.hasOwnProperty.call(e.constructor.prototype, "isPrototypeOf"));
        }, b.typeCode = function(e) {
            return b.isPrimitive(e) || !b.isPlainObject(e) ? "primitive" : b.isArrayable(e) ? "array" : "object";
        }, b.isIoCReference = function(e) {
            return "string" == typeof e && "{" === e.charAt(0) && 0 < e.indexOf("}");
        }, b.isDOMNode = function(e) {
            return e && "number" == typeof e.nodeType;
        }, b.isComponent = function(e) {
            return e && e.constructor === b.componentConstructor;
        }, b.isUncopyable = function(e) {
            return b.isPrimitive(e) || !b.isPlainObject(e);
        }, b.isApplicable = function(e) {
            return e.apply && "function" == typeof e.apply;
        }, b.identity = function(e) {
            return e;
        }, b.notImplemented = function() {
            b.fail("This operation is not implemented");
        }, b.firstDefined = function(e, t) {
            return void 0 === e ? t : e;
        }, b.freshContainer = function(e) {
            return b.isArrayable(e) ? [] : {};
        }, b.copyRecurse = function(e, r) {
            return r.length > b.strategyRecursionBailout && b.fail("Runaway recursion encountered in fluid.copy - reached path depth of " + b.strategyRecursionBailout + " via path of " + r.join(".") + "this object is probably circularly connected. Either adjust your object structure to remove the circularity or increase fluid.strategyRecursionBailout"), 
            b.isUncopyable(e) ? e : b.transform(e, function(e, t) {
                r.push(t);
                var n = b.copyRecurse(e, r);
                return r.pop(), n;
            });
        }, b.copy = function(e) {
            return b.copyRecurse(e, []);
        }, b.extend = y.extend, b.makeArray = function(e) {
            var t = [];
            if (null != e) if (b.isPrimitive(e) || b.isPlainObject(e, !0) || "number" != typeof e.length) t.push(e); else for (var n = 0; n < e.length; ++n) t[n] = e[n];
            return t;
        }, b.pushArray = function(e, t, n) {
            var r = e[t] ? e[t] : e[t] = [];
            b.isArrayable(n) ? r.push.apply(r, n) : r.push(n);
        }, b.transform = function(e) {
            if (b.isPrimitive(e)) return e;
            var t = b.freshContainer(e);
            if (b.isArrayable(e)) for (var n = 0; n < e.length; ++n) a(e, t, n, arguments); else for (var r in e) a(e, t, r, arguments);
            return t;
        }, b.each = function(e, t) {
            if (b.isArrayable(e)) for (var n = 0; n < e.length; ++n) t(e[n], n); else for (var r in e) t(e[r], r);
        }, b.make_find = function(i) {
            var u = !i && void 0;
            return function(e, t, n) {
                var r;
                if (b.isArrayable(e)) {
                    for (var a = 0; a < e.length; ++a) if ((r = t(e[a], a)) !== u) return i ? e[a] : r;
                } else for (var o in e) if ((r = t(e[o], o)) !== u) return i ? e[o] : r;
                return n;
            };
        }, b.find = b.make_find(!1), b.find_if = b.make_find(!0), b.accumulate = function(e, t, n) {
            for (var r = 0; r < e.length; ++r) n = t(e[r], n, r);
            return n;
        }, b.add = function(e, t) {
            return e + t;
        }, b.remove_if = function(e, t, n) {
            if (b.isArrayable(e)) for (var r = e.length - 1; 0 <= r; --r) t(e[r], r) && (n && n.unshift(e[r]), 
            e.splice(r, 1)); else for (var a in e) t(e[a], a) && (n && (n[a] = e[a]), delete e[a]);
            return n || e;
        }, b.generate = function(e, t, n) {
            for (var r = [], a = 0; a < e; ++a) r[a] = n ? t(a) : t;
            return r;
        }, b.iota = function(e, t) {
            t = t || 0;
            for (var n = [], r = 0; r < e; ++r) n[n.length] = t++;
            return n;
        }, b.getMembers = function(e, t) {
            return b.transform(e, function(e) {
                return b.get(e, t);
            });
        }, b.filterKeys = function(e, n, r) {
            return b.remove_if(y.extend({}, e), function(e, t) {
                return r ^ -1 === n.indexOf(t);
            });
        }, b.censorKeys = function(e, t) {
            return b.filterKeys(e, t, !0);
        }, b.keys = function(e) {
            var t = [];
            for (var n in e) t.push(n);
            return t;
        }, b.values = function(e) {
            var t = [];
            for (var n in e) t.push(e[n]);
            return t;
        }, b.contains = function(e, t) {
            return e ? b.isArrayable(e) ? -1 !== e.indexOf(t) : b.find(e, function(e) {
                if (t === e) return !0;
            }) : void 0;
        }, b.keyForValue = function(e, n) {
            return b.find(e, function(e, t) {
                if (n === e) return t;
            });
        }, b.arrayToHash = function(e) {
            var t = {};
            return b.each(e, function(e) {
                t[e] = !0;
            }), t;
        }, b.stableSort = function(e, t) {
            for (var n = 0; n < e.length; n++) {
                var r, a = e[n];
                for (r = n; 0 < r && t(a, e[r - 1]) < 0; r--) e[r] = e[r - 1];
                e[r] = a;
            }
        }, b.hashToArray = function(e, r, a) {
            var o = [];
            return b.each(e, function(e, t) {
                var n = {};
                n[r] = t, a ? n = a(n, e, t) || n : y.extend(!0, n, e), o.push(n);
            }), o;
        }, b.flatten = function(e) {
            var t = [];
            return b.each(e, function(e) {
                b.isArrayable(e) ? t = t.concat(e) : t.push(e);
            }), t;
        }, b.clear = function(e) {
            if (b.isArrayable(e)) e.length = 0; else for (var t in e) delete e[t];
        }, b.compareStringLength = function(e) {
            return e ? function(e, t) {
                return e.length - t.length;
            } : function(e, t) {
                return t.length - e.length;
            };
        }, b.parseInteger = function(e) {
            return isFinite(e) && e % 1 == 0 ? Number(e) : NaN;
        }, b.roundToDecimal = function(e, t, n) {
            return t = t && 0 <= t ? Math.round(t) : 0, "ceil" === n || "floor" === n ? Number(Math[n](e + "e" + t) + "e-" + t) : Number((0 <= e ? 1 : -1) * (Math.round(Math.abs(e) + "e" + t) + "e-" + t));
        }, b.debounce = function(r, a, o) {
            var i, u;
            return function() {
                var e = this, t = arguments, n = o && !i;
                return clearTimeout(i), i = setTimeout(function() {
                    i = null, o || (u = r.apply(e, t));
                }, a), n && (u = r.apply(e, t)), u;
            };
        }, b.freezeRecursive = function(e) {
            return b.isPlainObject(e) ? (b.each(e, function(e) {
                b.freezeRecursive(e);
            }), Object.freeze(e)) : e;
        }, b.marker = function() {}, b.makeMarker = function(e, t) {
            var n = Object.create(b.marker.prototype);
            return n.value = e, y.extend(n, t), Object.freeze(n);
        }, b.VALUE = b.makeMarker("VALUE"), b.NO_VALUE = b.makeMarker("NO_VALUE"), b.EXPAND = b.makeMarker("EXPAND"), 
        b.isMarker = function(e, t) {
            return e instanceof b.marker && (!t || e.value === t.value);
        }, b.logLevelsSpec = {
            FATAL: 0,
            FAIL: 5,
            WARN: 10,
            IMPORTANT: 12,
            INFO: 15,
            TRACE: 20
        }, b.logLevel = b.transform(b.logLevelsSpec, function(e, t) {
            return b.makeMarker(t, {
                priority: e
            });
        });
        var n = [ b.logLevel.IMPORTANT ];
        b.model = {}, b.model.copyModel = function(e, t) {
            b.clear(e), y.extend(!0, e, t);
        }, b.model.parseEL = function(e) {
            return "" === e ? [] : String(e).split(".");
        }, b.model.composePath = function(e, t) {
            return "" === e ? t : "" === t ? e : e + "." + t;
        }, b.model.composeSegments = function() {
            return b.makeArray(arguments).join(".");
        }, b.lastDotIndex = function(e) {
            return e.lastIndexOf(".");
        }, b.model.getToTailPath = function(e) {
            var t = b.lastDotIndex(e);
            return -1 === t ? "" : e.substring(0, t);
        }, b.model.getTailPath = function(e) {
            var t = b.lastDotIndex(e);
            return e.substring(t + 1);
        }, b.path = b.model.composeSegments, b.composePath = b.model.composePath, b.requireDataBinding = function() {
            b.fail("Please include DataBinding.js in order to operate complex model accessor configuration");
        }, b.model.setWithStrategy = b.model.getWithStrategy = b.requireDataBinding, b.model.resolvePathSegment = function(e, t, n, r) {
            if (!r && e.resolvePathSegment) {
                var a = e.resolvePathSegment(t);
                if (void 0 !== a) return a;
            }
            return n && void 0 === e[t] ? e[t] = {} : e[t];
        }, b.model.parseToSegments = function(e, t, n) {
            return "number" == typeof e || "string" == typeof e ? t(e) : n ? b.makeArray(e) : e;
        }, b.model.pathToSegments = function(e, t) {
            var n = t && t.parser ? t.parser.parse : b.model.parseEL;
            return b.model.parseToSegments(e, n);
        }, b.model.accessImpl = function(e, t, n, r, a, o, i) {
            var u = b.model.pathToSegments(t, r), s = 0;
            if (a && (s = a.length, u = a.concat(u)), e = i(e, u, s, r, n === b.NO_VALUE ? 0 : 1), 
            n === b.NO_VALUE || n === b.VALUE) return o ? {
                root: e,
                segs: u
            } : e;
            e[u[u.length - 1]] = n;
        }, b.model.accessSimple = function(e, t, n, r, a, o) {
            return b.model.accessImpl(e, t, n, r, a, o, b.model.traverseSimple);
        }, b.model.traverseSimple = function(e, t, n, r, a) {
            for (var o = r, i = t.length - a, u = 0; u < i; ++u) {
                if (!e) return;
                var s = t[u];
                e = r && r[s] ? r[s] : b.model.resolvePathSegment(e, s, 1 === a, o), r = null;
            }
            return e;
        }, b.model.setSimple = function(e, t, n, r, a) {
            b.model.accessSimple(e, t, n, r, a, !1);
        }, b.model.getSimple = function(e, t, n, r) {
            return null == t || 0 === t.length ? e : b.model.accessSimple(e, t, b.NO_VALUE, n, r, !1);
        }, b.getImmediate = function(e, t, n) {
            for (var r = void 0 === n ? t.length : n + 1, a = 0; a < r; ++a) e = e ? e[t[a]] : void 0;
            return e;
        }, b.decodeAccessorArg = function(e) {
            return e && e !== b.model.defaultGetConfig && e !== b.model.defaultSetConfig ? "environment" === e.type ? e.value : void 0 : null;
        }, b.set = function(e, t, n, r, a) {
            var o = b.decodeAccessorArg(r);
            void 0 === o ? b.model.setWithStrategy(e, t, n, r, a) : b.model.setSimple(e, t, n, o, a);
        }, b.get = function(e, t, n, r) {
            var a = b.decodeAccessorArg(n);
            return void 0 === a ? b.model.getWithStrategy(e, t, n, r) : b.model.accessImpl(e, t, b.NO_VALUE, a, null, !1, b.model.traverseSimple);
        }, b.getGlobalValue = function(e, t) {
            if (e) return t = t || b.environment, b.get(b.global, e, {
                type: "environment",
                value: t
            });
        }, b.bind = function(e, t, n) {
            return e[t].apply(e, b.makeArray(n));
        }, b.invokeGlobalFunction = function(e, t, n) {
            var r = b.getGlobalValue(e, n);
            if (r) return r.apply(null, b.isArrayable(t) ? t : b.makeArray(t));
            b.fail("Error invoking global function: " + e + " could not be located");
        }, b.registerGlobalFunction = function(e, t, n) {
            n = n || b.environment, b.set(b.global, e, t, {
                type: "environment",
                value: n
            });
        }, b.setGlobalValue = b.registerGlobalFunction, b.registerNamespace = function(e, t) {
            t = t || b.environment;
            var n = b.getGlobalValue(e, t);
            return n || (n = {}, b.setGlobalValue(e, n, t)), n;
        }, b.dumpEl = b.identity, b.renderTimestamp = b.identity, b.generateUniquePrefix = function() {
            return Math.floor(1e12 * Math.random()).toString(36) + "-";
        };
        var e = b.generateUniquePrefix();
        b.fluidInstance = e;
        var t = 1;
        b.allocateGuid = function() {
            return e + t++;
        }, b.registerNamespace("fluid.event"), b.extremePriority = 4e9, b.priorityTypes = {
            first: -1,
            last: 1,
            before: 0,
            after: 0
        }, b.extremalPriorities = {
            none: 0,
            testing: 10,
            authoring: 20
        }, b.parsePriorityConstraint = function(e, t, n) {
            var r = e.split(":"), a = r[0], o = b.priorityTypes[a];
            return void 0 === o && b.fail("Invalid constraint type in priority field " + e + ": the only supported values are " + b.keys(b.priorityTypes).join(", ") + " or numeric"), 
            t && 0 === o && b.fail("Constraint type in priority field " + e + " is not supported in a " + n + " record - you must use either a numeric value or first, last"), 
            {
                type: r[0],
                target: r[1]
            };
        }, b.parsePriority = function(e, t, n, r) {
            var a = {
                count: t || 0,
                fixed: null,
                constraint: null,
                site: r
            };
            "number" == typeof (e = e || 0) ? a.fixed = -e : a.constraint = b.parsePriorityConstraint(e, n, r);
            var o = a.constraint ? b.priorityTypes[a.constraint.type] : 0;
            if (0 !== o) {
                var i = a.constraint.target || "none", u = b.extremalPriorities[i];
                void 0 === u && b.fail("Unrecognised extremal priority target " + i + ": the currently supported values are " + b.keys(b.extremalPriorities).join(", ") + ": register your value in fluid.extremalPriorities"), 
                a.fixed = o * (b.extremePriority + u);
            }
            return null !== a.fixed && (a.fixed += a.count / 1024), a;
        }, b.renderPriority = function(e) {
            return e.constraint ? e.constraint.target ? e.constraint.type + ":" + e.constraint.target : e.constraint.type : Math.floor(e.fixed);
        }, b.compareByPriority = function(e, t) {
            return null !== e.priority.fixed && null !== t.priority.fixed ? e.priority.fixed - t.priority.fixed : (null === e.priority.fixed) - (null === t.priority.fixed);
        }, b.honourConstraint = function(e, t, n) {
            var r = e[n].priority.constraint, a = b.find(e, function(e, t) {
                return e.namespace === r.target ? t : void 0;
            }, -1);
            if (-1 === a) return !0;
            if (t <= a) return !1;
            for (var o = a + ("after" === r.type ? 1 : 0), i = e[n], u = n; o <= u; --u) e[u] = e[u - 1];
            return e[o] = i, !0;
        }, b.sortByPriority = function(e) {
            b.stableSort(e, b.compareByPriority);
            for (var t = b.find(e, function(e, t) {
                return e.priority.constraint && 0 === b.priorityTypes[e.priority.constraint.type] ? t : void 0;
            }, e.length); ;) {
                if (t === e.length) return e;
                for (var n = t, r = t; r < e.length; ++r) {
                    b.honourConstraint(e, t, r) && ++t;
                }
                if (t === n) {
                    var a = e.slice(t);
                    b.fail("Could not find targets for any constraints in " + a[0].priority.site + " ", a, ": none of the targets (" + b.getMembers(a, "priority.constraint.target").join(", ") + ") matched any namespaces of the elements in (", e.slice(0, t), ") - this is caused by either an invalid or circular reference");
                }
            }
        }, b.parsePriorityRecords = function(e, r) {
            var t = b.hashToArray(e, "namespace", function(e, t, n) {
                y.extend(e, t), e.priority = b.parsePriority(t.priority, n, !1, r);
            });
            return b.sortByPriority(t), t;
        }, b.event.identifyListener = function(e, t) {
            return "string" == typeof e || e.$$fluid_guid || t || (e.$$fluid_guid = b.allocateGuid()), 
            e.$$fluid_guid;
        }, b.event.impersonateListener = function(e, t) {
            b.event.identifyListener(e), t.$$fluid_guid = e.$$fluid_guid;
        }, b.event.sortListeners = function(e) {
            var a = [];
            return b.each(e, function(e) {
                for (var t, n = 0; n < e.length; ++n) {
                    var r = e[n];
                    r.softNamespace || t || (t = r);
                }
                t ? a.push(t) : a = a.concat(e);
            }), b.sortByPriority(a);
        }, b.event.resolveListener = function(e) {
            var t = e.globalName || ("string" == typeof e ? e : null);
            if (t) {
                var n = b.getGlobalValue(t);
                n ? e = n : b.fail("Unable to look up name " + t + " as a global function");
            }
            return e;
        }, b.nameComponent = function(e) {
            return e ? "component with typename " + e.typeName + " and id " + e.id : "[unknown component]";
        }, b.event.nameEvent = function(e, t) {
            return t + " of " + b.nameComponent(e);
        }, b.makeEventFirer = function(o) {
            var u, e = (o = o || {}).name || "<anonymous>";
            return u = {
                eventId: b.allocateGuid(),
                name: e,
                ownerId: o.ownerId,
                typeName: "fluid.event.firer",
                destroy: function() {
                    u.destroyed = !0;
                },
                addListener: function() {
                    (function() {
                        u.listeners = {}, u.byId = {}, u.sortedListeners = [], u.addListener = function(e, t, n, r, a) {
                            var o;
                            if (u.destroyed && b.fail("Cannot add listener to destroyed event firer " + u.name), 
                            e) {
                                b.isPlainObject(e, !0) && !b.isApplicable(e) && (e = (o = e).listener, t = o.namespace, 
                                n = o.priority, r = o.softNamespace, a = o.listenerId), "string" == typeof e && (e = {
                                    globalName: e
                                });
                                var i = a || b.event.identifyListener(e);
                                t = t || i, o = y.extend(o || {}, {
                                    namespace: t,
                                    listener: e,
                                    softNamespace: r,
                                    listenerId: a,
                                    priority: b.parsePriority(n, u.sortedListeners.length, !1, "listeners")
                                }), u.byId[i] = o, (u.listeners[t] = b.makeArray(u.listeners[t]))[r ? "push" : "unshift"](o), 
                                u.sortedListeners = b.event.sortListeners(u.listeners);
                            }
                        }, u.addListener.apply(null, arguments);
                    }).apply(null, arguments);
                },
                removeListener: function(e) {
                    if (u.listeners) {
                        var t, n, r;
                        "string" == typeof e ? (t = e, (r = u.listeners[t]) || (n = t, t = null)) : "function" == typeof e && ((n = b.event.identifyListener(e, !0)) || b.fail("Cannot remove unregistered listener function ", e, " from event " + u.name));
                        var a = u.byId[n], o = a && a.softNamespace;
                        t = t || a && a.namespace || n, delete u.byId[n], (r = u.listeners[t]) && (o ? b.remove_if(r, function(e) {
                            return e.listener.$$fluid_guid === n || e.listenerId === n;
                        }) : r.shift(), 0 === r.length && delete u.listeners[t]), u.sortedListeners = b.event.sortListeners(u.listeners);
                    }
                },
                fire: function() {
                    var e = u.sortedListeners;
                    if (e && !u.destroyed) for (var t = 0; t < e.length; ++t) {
                        var n = e[t];
                        "function" != typeof n.listener && (n.listener = b.event.resolveListener(n.listener));
                        var r, a = n.listener.apply(null, arguments);
                        if ((o.preventable && !1 === a || u.destroyed) && (r = !1), void 0 !== r) return r;
                    }
                }
            };
        }, b.fireEvent = function(e, t, n) {
            var r = e.events[t];
            r && r.fire.apply(null, b.makeArray(n));
        }, b.event.addListenerToFirer = function(e, t, n, r) {
            if (r = r || b.identity, b.isArrayable(t)) for (var a = 0; a < t.length; ++a) b.event.addListenerToFirer(e, t[a], n, r); else "function" == typeof t || "string" == typeof t ? r(e).addListener(t, n) : t && "object" == typeof t && r(e).addListener(t.listener, n || t.namespace, t.priority, t.softNamespace, t.listenerId);
        }, b.event.resolveListenerRecord = function(e) {
            return {
                records: e
            };
        }, b.expandImmediate = function(e) {
            b.fail("fluid.expandImmediate could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor " + e);
        }, b.mergeListeners = function(i, u, e) {
            b.each(e, function(e, t) {
                var n, r;
                if (b.isIoCReference(t)) (n = b.expandImmediate(t, i)) || b.fail("Error in listener record: key " + t + ' could not be looked up to an event firer - did you miss out "events." when referring to an event firer?'); else {
                    var a = t.indexOf(".");
                    -1 !== a && (r = t.substring(a + 1), t = t.substring(0, a)), u[t] || b.fail("Listener registered for event " + t + " which is not defined for this component"), 
                    n = u[t];
                }
                var o = b.event.resolveListenerRecord(e, i, t, r, !0);
                b.event.addListenerToFirer(n, o.records, r, o.adderWrapper);
            });
        }, b.eventFromRecord = function(e, t, n) {
            var r;
            return e && ("string" != typeof e || b.isIoCReference(e)) ? b.event.resolveEvent ? r = b.event.resolveEvent(n, t, e) : b.fail("fluid.event.resolveEvent could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor ", e) : r = b.makeEventFirer({
                name: b.event.nameEvent(n, t),
                preventable: "preventable" === e,
                ownerId: n.id
            }), r;
        }, b.instantiateFirers = function(n, e) {
            b.each(e.events, function(e, t) {
                n.events[t] = b.eventFromRecord(e, t, n);
            });
        }, b.mergeListenerPolicy = function(e, t, n) {
            return "string" != typeof n && b.fail("Error in listeners declaration - the keys in this structure must resolve to event names - got " + n + " from ", t), 
            !b.isIoCReference(n) && -1 !== n.indexOf(".") ? t || e : b.arrayConcatPolicy(e, t);
        }, b.makeMergeListenersPolicy = function(r, t) {
            return function(n, e) {
                return n = n || {}, t && (b.isArrayable(e) || "string" == typeof e.target) ? n[""] = r(n[""], e, "") : b.each(e, function(e, t) {
                    n[t] = r(n[t], e, t);
                }), n;
            };
        }, b.validateListenersImplemented = function(n) {
            var r = [];
            return b.each(n.events, function(e, t) {
                b.each(e.sortedListeners, function(e) {
                    e.listener !== b.notImplemented && "fluid.notImplemented" !== e.listener.globalName || r.push({
                        name: t,
                        namespace: e.namespace,
                        componentSource: b.model.getSimple(n.options.listeners, [ t + "." + e.namespace, 0, "componentSource" ])
                    });
                });
            }), r;
        }, b.unique = function(n) {
            return b.remove_if(n, function(e, t) {
                return !e || 0 < t && e === n[t - 1];
            });
        }, b.arrayConcatPolicy = function(e, t) {
            return b.makeArray(e).concat(b.makeArray(t));
        }, b.loggingEvent = b.makeEventFirer({
            name: "logging event"
        }), b.addTimestampArg = function(e) {
            var t = b.renderTimestamp(new Date()) + ":  ";
            e.unshift(t);
        }, b.loggingEvent.addListener(b.doBrowserLog, "log"), b.loggingEvent.addListener(b.identity, "filterArgs", "before:log"), 
        b.loggingEvent.addListener(b.addTimestampArg, "addTimestampArg", "after:filterArgs"), 
        b.failureEvent = b.makeEventFirer({
            name: "failure event"
        }), b.failureEvent.addListener(b.builtinFail, "fail"), b.failureEvent.addListener(b.logFailure, "log", "before:fail"), 
        b.pushSoftFailure = function(e) {
            "function" == typeof e ? b.failureEvent.addListener(e, "fail") : -1 === e ? b.failureEvent.removeListener("fail") : "boolean" == typeof e && b.fail("pushSoftFailure with boolean value is no longer supported");
        }, b.componentConstructor = function() {}, b.typeTag = function(e) {
            var t = Object.create(b.componentConstructor.prototype);
            return t.typeName = e, t.id = b.allocateGuid(), t;
        };
        var s = 1, l = {};
        function k(e, t, n, r) {
            for (var a = 0; a < n; ++a) e = r(e, t[a], a, b.makeArray(t));
            return e;
        }
        b.defaultsStore = {}, b.resolveGradesImpl = function(e, t) {
            for (var n = (t = b.makeArray(t)).length - 1; 0 <= n; --n) {
                var r = t[n];
                if (r && !e.gradeHash[r]) {
                    var a = (b.isIoCReference(r) ? null : b.rawDefaults(r)) || {}, o = l[r] || s - 1;
                    e.lastTick = Math.max(e.lastTick, o), e.gradeHash[r] = !0, e.gradeChain.push(r);
                    for (var i = b.makeArray(a.gradeNames), u = i.length - 1; 0 <= u; --u) b.resolveGradesImpl(e, i[u]);
                }
            }
            return e;
        }, b.resolveGradeStructure = function(e, t) {
            var n = {
                lastTick: 0,
                gradeChain: [],
                gradeHash: {}
            };
            return b.resolveGradesImpl(n, [ e ].concat(b.makeArray(t))), n.gradeChain.reverse(), 
            n;
        }, b.hasGrade = function(e, t) {
            return !(!e || !e.gradeNames) && b.contains(e.gradeNames, t);
        }, b.resolveGrade = function(e, t, n) {
            var r = b.resolveGradeStructure(t, n), a = b.transform(r.gradeChain, b.rawDefaults, b.copy);
            b.remove_if(a, function(e) {
                return !e;
            });
            for (var o = {}, i = 0; i < a.length; ++i) a[i] && a[i].mergePolicy && (o = y.extend(!0, o, a[i].mergePolicy));
            a = [ o, {} ].concat(a);
            var u = b.merge.apply(null, a);
            return u.gradeNames = r.gradeChain, b.freezeRecursive(u), {
                defaults: u,
                lastTick: r.lastTick
            };
        }, b.mergedDefaultsCache = {}, b.gradeNamesToKey = function(e, t) {
            return e + "|" + t.join("|");
        }, b.getMergedDefaults = function(e, t) {
            t = b.makeArray(t);
            var n = b.gradeNamesToKey(e, t), r = b.mergedDefaultsCache[n];
            if (r) {
                for (var a = 0, o = r.defaults.gradeNames || [], i = 0; i < o.length; ++i) a = Math.max(a, l[o[i]] || 0);
                a > r.lastTick && (b.passLogLevel(b.logLevel.TRACE) && b.log(b.logLevel.TRACE, "Clearing cache for component " + e + " with gradeNames ", o), 
                r = null);
            }
            if (!r) {
                var u = b.rawDefaults(e);
                if (!u) return u;
                r = b.mergedDefaultsCache[n] = b.resolveGrade(u, e, t);
            }
            return r.defaults;
        }, b.upgradePrimitiveFunc = function(e, t) {
            if (e && b.isPrimitive(e)) {
                var n = {};
                return n[t || ("string" == typeof e && "{" !== e.charAt(0) ? "funcName" : "func")] = e, 
                n.args = b.NO_VALUE, n;
            }
            return e;
        }, b.annotateListeners = function(n, e) {
            e.listeners = b.transform(e.listeners, function(e) {
                var t = b.makeArray(e);
                return b.transform(t, function(e) {
                    return (e = b.upgradePrimitiveFunc(e, "listener")).componentSource = n, e;
                });
            }), e.invokers = b.transform(e.invokers, function(e) {
                return (e = b.upgradePrimitiveFunc(e)) && (e.componentSource = n), e;
            });
        }, b.rawDefaults = function(e) {
            var t = b.defaultsStore[e];
            return t && t.options;
        }, b.registerRawDefaults = function(e, t) {
            b.pushActivity("registerRawDefaults", "registering defaults for grade %componentName with options %options", {
                componentName: e,
                options: t
            });
            var n = b.expandCompact ? b.expandCompact(t) : b.copy(t);
            b.annotateListeners(e, n);
            var r = b.getCallerInfo && b.getCallerInfo(6);
            b.defaultsStore[e] = {
                options: n,
                callerInfo: r
            }, l[e] = s++, b.popActivity();
        }, b.doIndexDefaults = function(e, t, n, r) {
            for (var a = b.makeArray(r.gradeNames), o = 0; o < a.length; ++o) if (!b.hasGrade(t, a[o])) return;
            for (var i = ("function" == typeof r.indexFunc ? r.indexFunc : b.getGlobalValue(r.indexFunc))(t) || [], u = 0; u < i.length; ++u) b.pushArray(n, i[u], e);
        }, b.indexDefaults = function(e, t) {
            var n = {};
            for (var r in b.defaultsStore) {
                var a = b.getMergedDefaults(r);
                b.doIndexDefaults(r, a, n, t);
            }
            return n;
        }, b.defaults = function(e, t) {
            if (void 0 === t) return b.getMergedDefaults(e);
            t && t.options && b.fail("Probable error in options structure for " + e + ' with option named "options" - perhaps you meant to write these options at top level in fluid.defaults? - ', t), 
            b.registerRawDefaults(e, t);
            var n = b.getMergedDefaults(e);
            b.hasGrade(n, "fluid.function") || b.makeComponentCreator(e);
        }, b.makeComponentCreator = function(a) {
            function e() {
                var e = b.getMergedDefaults(a);
                if (e.gradeNames && 0 !== e.gradeNames.length) {
                    if (e.initFunction) return b.initComponent(a, arguments);
                    for (var t = [], n = 0; n < e.gradeNames.length; ++n) {
                        var r = e.gradeNames[n];
                        b.rawDefaults(r) || t.push(r);
                    }
                    0 === t.length ? b.fail("Cannot make component creator for type " + a + " which does not have an initFunction defined") : b.fail("The grade hierarchy of component with type " + a + " is incomplete - it inherits from the following grade(s): " + t.join(", ") + " for which the grade definitions are corrupt or missing. Please check the files which might include these grades and ensure they are readable and have been loaded by this instance of Infusion");
                } else b.fail("Cannot make component creator for type " + a + " which does not have any gradeNames defined");
            }
            var t = b.getGlobalValue(a);
            t && y.extend(e, t), b.setGlobalValue(a, e);
        }, b.emptyPolicy = b.freezeRecursive({}), b.derefMergePolicy = function(e) {
            return (e ? e["*"] : b.emptyPolicy) || b.emptyPolicy;
        }, b.compileMergePolicy = function(e) {
            var i = {}, u = {}, s = {
                builtins: i,
                defaultValues: u
            };
            return e && b.each(e, function(e, t) {
                var n = {}, r = !0;
                if ("function" == typeof e) n.func = e; else if ("object" == typeof e) n = e; else if (b.isDefaultValueMergePolicy(e)) b.set(u, t, "{that}.options." + e), 
                r = !(s.hasDefaults = !0); else for (var a = e.split(/\s*,\s*/), o = 0; o < a.length; ++o) n[a[o]] = !0;
                r && b.set(i, b.composePath(t, "*"), n);
            }), s;
        }, b.isDefaultValueMergePolicy = function(e) {
            return "string" == typeof e && -1 === e.indexOf(",") && !/replace|nomerge|noexpand/.test(e);
        }, b.mergeOneImpl = function(e, t, n, r, a, o, i) {
            var u = e, s = b.isPrimitive(e);
            return void 0 !== t && (a.func || null === t || !b.isPlainObject(t) || a.nomerge ? (r[n] = void 0, 
            u = a.func ? a.func.call(null, e, t, i[o - 1], i, o) : t) : s && (u = e = b.freshContainer(t))), 
            u;
        }, b.fetchMergeChildren = function(r, a, o, i, u, s) {
            for (var e = b.derefMergePolicy(u), t = i.length - 1; 0 <= t; --t) {
                var n = i[t];
                if (void 0 !== n && (b.each(n, function(e, t) {
                    var n = b.concreteTrundler(u, t);
                    t in r && (!s.evaluateFully || void 0 !== n || b.isPrimitive(r[t])) || (o[a] = t, 
                    s.strategy(r, t, a + 1, o, i, u));
                }), e.replace)) break;
            }
            return r;
        }, b.inEvaluationMarker = Object.freeze({
            __CURRENTLY_IN_EVALUATION__: !0
        }), b.strategyRecursionBailout = 50, b.makeMergeStrategy = function(v) {
            function e(e, t, n, r, a, o) {
                if (n > b.strategyRecursionBailout && b.fail("Overflow/circularity in options merging, current path is ", r, " at depth ", n, ' - please protect components from merging using the "nomerge" merge policy'), 
                !b.isPrimitive(e)) {
                    var i;
                    if (b.isTracing && b.tracing.pathCount.push(b.path(r.slice(0, n))), t in e) {
                        if (i = e[t], !v.evaluateFully) return i;
                    } else e !== b.inEvaluationMarker && (e[t] = b.inEvaluationMarker);
                    void 0 === a && (r = b.makeArray(r), a = function(e, t, n, r) {
                        for (var a = [], o = 0; o < e.length; ++o) {
                            var i = k(e[o], t, n, r[o]);
                            void 0 !== i && a.push(i);
                        }
                        return a;
                    }(v.sources, r, n - 1, v.sourceStrategies), o = k(v.mergePolicy, r, n - 1, b.concreteTrundler));
                    var u, s, l, c = b.concreteTrundler(o, t), d = b.derefMergePolicy(c);
                    l = d.replace ? (u = 1 - a.length, s = 0, -1) : (u = 0, s = a.length - 1, 1);
                    for (var f, p = [], m = u; m <= s; ++m) {
                        var g = l * m, h = v.sourceStrategies[g](a[g], t, n, r);
                        if (void 0 !== h && (b.isPrimitive(h) || (p[g] = h), void 0 === i)) {
                            if (-1 === l) {
                                f = e[t] = h;
                                break;
                            }
                            f = b.mergeOneImpl(f, h, m, p, d, n, r, v), e !== b.inEvaluationMarker && (e[t] = f);
                        }
                    }
                    return void 0 !== i && (f = i), 0 < p.length && b.isPlainObject(f) && b.fetchMergeChildren(f, n, r, p, c, v), 
                    void 0 === i && 0 === p.length && delete e[t], f;
                }
            }
            return v.strategy = e;
        }, b.driveStrategy = function(e, t, n) {
            t = b.makeArray(t);
            for (var r = 0; r < t.length; ++r) {
                if (!e) return;
                e = n(e, t[r], r + 1, t);
            }
            return e;
        }, b.concreteTrundler = function(e, t) {
            return e ? e[t] : void 0;
        }, b.merge = function(e) {
            var t = Array.prototype.slice.call(arguments, 1), n = b.compileMergePolicy(e).builtins, r = b.makeMergeOptions(n, t, {});
            return r.initter(), r.target;
        }, b.simpleGingerBlock = function(e, t) {
            return {
                target: e,
                simple: !0,
                strategy: b.concreteTrundler,
                initter: b.identity,
                recordType: t,
                priority: b.mergeRecordTypes[t]
            };
        }, b.makeMergeOptions = function(e, t, n) {
            var r = {
                mergePolicy: e,
                sources: t
            };
            return (r = y.extend(r, n)).target = r.target || b.freshContainer(r.sources[0]), 
            r.sourceStrategies = r.sourceStrategies || b.generate(r.sources.length, b.concreteTrundler), 
            r.initter = function() {
                r.evaluateFully = !0, b.fetchMergeChildren(r.target, 0, [], r.sources, r.mergePolicy, r);
            }, b.makeMergeStrategy(r), r;
        }, b.transformOptions = function(e, t) {
            return b.expect("Options transformation record", t, [ "transformer", "config" ]), 
            b.getGlobalValue(t.transformer).call(null, e, t.config);
        }, b.findMergeBlocks = function(e, t) {
            return b.remove_if(b.makeArray(e), function(e) {
                return e.recordType !== t;
            });
        }, b.transformOptionsBlocks = function(n, r, e) {
            b.each(e, function(e) {
                var t = b.findMergeBlocks(n, e);
                b.each(t, function(e) {
                    var t = e.source ? "source" : "target";
                    e[e.simple || "target" == t ? "target" : "source"] = b.transformOptions(e[t], r);
                });
            });
        }, b.dedupeDistributionNamespaces = function(e) {
            var n = {};
            b.remove_if(e, function(e) {
                var t = e.namespace;
                if (t) {
                    if (n[t] && n[t] !== e.contextThat.id) return !0;
                    n[t] = e.contextThat.id;
                }
            });
        }, b.deliverOptionsStrategy = b.identity, b.computeComponentAccessor = b.identity, 
        b.computeDynamicComponents = b.identity, b.mergeRecordTypes = {
            defaults: 1e3,
            defaultValueMerge: 900,
            subcomponentRecord: 800,
            user: 700,
            distribution: 100
        }, b.model.applyChangeRequest = function(e, t) {
            var n = t.segs;
            if (0 === n.length) "ADD" === t.type ? y.extend(!0, e, t.value) : b.clear(e); else if ("ADD" === t.type) b.model.setSimple(e, t.segs, t.value); else {
                for (var r = 0; r < n.length - 1; ++r) if (!(e = e[n[r]])) return;
                delete e[n[n.length - 1]];
            }
        }, b.destroyValue = function(e, t) {
            e && b.model.applyChangeRequest(e, {
                type: "DELETE",
                segs: t
            });
        }, b.mergeComponentOptions = function(e, t, n, r) {
            var a = b.rawDefaults(t), o = b.getMergedDefaults(t, a && a.gradeNames ? null : r.gradeNames), i = {}, u = [];
            u = b.expandComponentOptions ? u.concat(b.expandComponentOptions(i, o, n, e)) : u.concat([ b.simpleGingerBlock(o, "defaults"), b.simpleGingerBlock(n, "user") ]);
            function s() {
                b.each(u, function(e) {
                    b.isPrimitive(e.priority) && (e.priority = b.parsePriority(e.priority, 0, !1, "options distribution"));
                }), b.sortByPriority(u), b.dedupeDistributionNamespaces(u), c.length = 0, d.length = 0, 
                b.each(u, function(e) {
                    c.push(e.strategy), d.push(e.target);
                });
            }
            var l = {}, c = [], d = [], f = {
                target: l,
                sourceStrategies: c
            };
            s();
            var p, m, g = b.makeMergeOptions(i, d, f);
            function h() {
                m = b.driveStrategy(l, "mergePolicy", g.strategy), m = y.extend({}, b.rootMergePolicy, m), 
                p = b.compileMergePolicy(m), y.extend(!0, i, p.builtins);
            }
            g.mergeBlocks = u, g.updateBlocks = s, g.destroyValue = function(e) {
                for (var t = 0; t < u.length; ++t) u[t].immutableTarget || b.destroyValue(u[t].target, e);
                b.destroyValue(f.target, e);
            }, h(), g.computeMergePolicy = h, p.hasDefaults && (b.generateExpandBlock ? (u.push(b.generateExpandBlock({
                options: p.defaultValues,
                recordType: "defaultValueMerge",
                priority: b.mergeRecordTypes.defaultValueMerge
            }, e, {})), s()) : b.fail("Cannot operate mergePolicy ", m, " for component ", e, " without including FluidIoC.js")), 
            e.options = l, b.driveStrategy(l, "gradeNames", g.strategy), b.deliverOptionsStrategy(e, l, g), 
            b.computeComponentAccessor(e, n && n.localRecord);
            var v = b.driveStrategy(l, "transformOptions", g.strategy);
            return v && (b.transformOptionsBlocks(u, v, [ "user", "subcomponentRecord" ]), s()), 
            f.target.mergePolicy || h(), g;
        }, b.defaults("fluid.function", {}), b.invokeGradedFunction = function(e, n) {
            var t = b.defaults(e);
            t && t.argumentMap && b.hasGrade(t, "fluid.function") || b.fail("Cannot look up name " + e + " to a function with registered argumentMap - got defaults ", t);
            var r = [];
            return b.each(t.argumentMap, function(e, t) {
                r[e] = n[t];
            }), b.invokeGlobalFunction(e, r);
        }, b.noNamespaceDistributionPrefix = "no-namespace-distribution-", b.mergeOneDistribution = function(e, t, n) {
            var r = t.namespace || n || b.noNamespaceDistributionPrefix + b.allocateGuid();
            e[t.namespace = r] = y.extend(!0, {}, e[r], t);
        }, b.distributeOptionsPolicy = function(n, e) {
            if (n = n || {}, b.isArrayable(e)) for (var t = 0; t < e.length; ++t) b.mergeOneDistribution(n, e[t]); else "string" == typeof e.target ? b.mergeOneDistribution(n, e) : b.each(e, function(e, t) {
                b.mergeOneDistribution(n, e, t);
            });
            return n;
        }, b.mergingArray = function() {}, b.mergingArray.prototype = [], b.membersMergePolicy = function(n, e) {
            return n = n || {}, b.each(e, function(e, t) {
                n[t] || (n[t] = new b.mergingArray()), e instanceof b.mergingArray ? n[t].push.apply(n[t], e) : void 0 !== e && n[t].push(e);
            }), n;
        }, b.invokerStrategies = b.arrayToHash([ "func", "funcName", "listener", "this", "method", "changePath", "value" ]), 
        b.invokersMergePolicy = function(o, e) {
            return o = o || {}, b.each(e, function(e, t) {
                if (e) {
                    e = b.upgradePrimitiveFunc(e);
                    var n = o[t];
                    for (var r in n || (n = o[t] = {}), b.invokerStrategies) if (r in e) for (var a in b.invokerStrategies) n[a] = void 0;
                    y.extend(n, e);
                } else o[t] = e;
            }), o;
        }, b.rootMergePolicy = {
            gradeNames: b.arrayConcatPolicy,
            distributeOptions: b.distributeOptionsPolicy,
            members: {
                noexpand: !0,
                func: b.membersMergePolicy
            },
            invokers: {
                noexpand: !0,
                func: b.invokersMergePolicy
            },
            transformOptions: "replace",
            listeners: b.makeMergeListenersPolicy(b.mergeListenerPolicy)
        }, b.defaults("fluid.component", {
            initFunction: "fluid.initLittleComponent",
            mergePolicy: b.rootMergePolicy,
            argumentMap: {
                options: 0
            },
            events: {
                onCreate: null,
                onDestroy: null,
                afterDestroy: null
            }
        }), b.defaults("fluid.emptySubcomponent", {
            gradeNames: [ "fluid.component" ]
        }), b.computeNickName = function(e) {
            var t = b.model.parseEL(e);
            return t[t.length - 1];
        }, b.defaults("fluid.typeFount", {
            gradeNames: [ "fluid.component" ]
        }), b.initLittleComponent = function(e, t, n, r) {
            var a = b.typeTag(e);
            a.lifecycleStatus = "constructing", n = n || {
                gradeNames: "fluid.component"
            }, a.destroy = b.makeRootDestroy(a);
            var o = b.mergeComponentOptions(a, e, t, n);
            o.exceptions = {
                members: {
                    model: !0,
                    modelRelay: !0
                }
            };
            var i = a.options;
            a.events = {}, (r || b.identity)(a, i, o.strategy), b.computeDynamicComponents(a, o);
            for (var u = 0; u < o.mergeBlocks.length; ++u) o.mergeBlocks[u].initter();
            return o.initter(), delete i.mergePolicy, b.instantiateFirers(a, i), b.mergeListeners(a, a.events, i.listeners), 
            a;
        }, b.diagnoseFailedView = b.identity, b.makeRootDestroy = function(e) {
            return function() {
                b.doDestroy(e), b.fireEvent(e, "afterDestroy", [ e, "", null ]);
            };
        }, b.isDestroyed = function(e) {
            return "destroyed" === e.lifecycleStatus;
        }, b.doDestroy = function(e, t, n) {
            for (var r in b.fireEvent(e, "onDestroy", [ e, t || "", n ]), e.lifecycleStatus = "destroyed", 
            e.events) "afterDestroy" !== r && "function" == typeof e.events[r].destroy && e.events[r].destroy();
            e.applier && e.applier.destroy();
        }, b.initComponent = function(e, t) {
            var n = b.defaults(e);
            n.gradeNames || b.fail("Cannot initialise component " + e + " which has no gradeName registered");
            var r, a = [ e ].concat(b.makeArray(t));
            b.pushActivity("initComponent", "constructing component of type %componentName with arguments %initArgs", {
                componentName: e,
                initArgs: t
            }), r = b.invokeGlobalFunction(n.initFunction, a), b.diagnoseFailedView(e, r, n, a), 
            b.initDependents && b.initDependents(r);
            var o = b.validateListenersImplemented(r);
            return 0 < o.length && b.fail(b.transform(o, function(e) {
                return [ "Error constructing component ", r, " - the listener for event " + e.name + " with namespace " + e.namespace + (e.componentSource ? " which was defined in grade " + e.componentSource : "") + " needs to be overridden with a concrete implementation" ];
            })).join("\n"), "constructing" === r.lifecycleStatus && (r.lifecycleStatus = "constructed"), 
            r.events.onCreate.fire(r), b.popActivity(), r;
        }, b.initSubcomponentImpl = function(e, t, n) {
            var r;
            if ("function" != typeof t) {
                var a = "string" == typeof t ? t : t.type;
                r = "fluid.emptySubcomponent" === a ? null : b.invokeGlobalFunction(a, n);
            } else r = t.apply(null, n);
            return r;
        };
        var r = "(?:[\\w\\u00c0-\\uFFFF*_-";
        b.simpleCSSMatcher = {
            regexp: new RegExp("([#.]?)(" + r + "]|\\\\.)+)", "g"),
            charToTag: {
                "": "tag",
                "#": "id",
                ".": "clazz"
            }
        }, b.IoCSSMatcher = {
            regexp: new RegExp("([&#]?)(" + r + "]|\\.|\\/)+)", "g"),
            charToTag: {
                "": "context",
                "&": "context",
                "#": "id"
            }
        };
        var p = new RegExp("\\s*(>)?\\s*", "g");
        b.parseSelector = function(e, t) {
            var n = [];
            e = e.trim();
            for (var r = t.regexp, a = r.lastIndex = 0; ;) {
                for (var o = [], i = !0; ;) {
                    var u = r.exec(e);
                    if (!u) break;
                    if (u.index !== a) {
                        if (!i) break;
                        b.fail("Error in selector string - cannot match child selector expression starting at " + e.substring(a));
                    }
                    var s = {}, l = u[2], c = t.charToTag[u[1]];
                    c && (s[c] = l), o[o.length] = s, a = r.lastIndex, i = !1;
                }
                p.lastIndex = a;
                var d = {
                    predList: o
                }, f = p.exec(e);
                if (f && f.index === a || b.fail("Error in selector string - can not match child selector expression at " + e.substring(a)), 
                ">" === f[1] && (d.child = !0), n[n.length] = d, p.lastIndex >= e.length) break;
                a = p.lastIndex, r.lastIndex = p.lastIndex;
            }
            return n;
        }, b.flattenObjectPaths = function(e) {
            var r = {};
            return b.each(e, function(e, n) {
                if (null !== e && "object" == typeof e) {
                    var t = b.flattenObjectPaths(e);
                    b.each(t, function(e, t) {
                        r[n + "." + t] = e;
                    }), "function" == typeof b.get(e, "toString") && (r[n] = e.toString());
                } else r[n] = e;
            }), r;
        }, b.stringTemplate = function(e, t) {
            var n = b.flattenObjectPaths(t), r = b.keys(n);
            r = r.sort(b.compareStringLength());
            for (var a = 0; a < r.length; ++a) for (var o = r[a], i = "%" + o, u = n[o], s = -1; -1 !== (s = e.indexOf(i)); ) e = e.slice(0, s) + u + e.slice(s + i.length);
            return e;
        };
    }(t, n), function(r, d) {
        "use strict";
        d.renderTimestamp = function(e) {
            function t(e, t) {
                t || (t = 2);
                var n = void 0 === e ? "" : e.toString();
                return "00000".substring(5 - t + n.length) + n;
            }
            return t(e.getHours()) + ":" + t(e.getMinutes()) + ":" + t(e.getSeconds()) + "." + t(e.getMilliseconds(), 3);
        }, d.isTracing = !1, d.registerNamespace("fluid.tracing"), d.tracing.pathCount = [], 
        d.tracing.summarisePathCount = function(e) {
            e = e || d.tracing.pathCount;
            for (var t = {}, n = 0; n < e.length; ++n) {
                var r = e[n];
                t[r] ? ++t[r] : t[r] = 1;
            }
            var a = [];
            return d.each(t, function(e, t) {
                a.push({
                    path: t,
                    count: e
                });
            }), a.sort(function(e, t) {
                return t.count - e.count;
            }), a;
        }, d.tracing.condensePathCount = function(e, t) {
            e = d.makeArray(e);
            var r = {};
            d.each(e, function(e) {
                r[e] = 0;
            });
            var a = [];
            return d.each(t, function(t) {
                var n = t.path;
                d.find(e, function(e) {
                    if (0 === n.indexOf(e)) return r[e] += t.count, !0;
                }) || a.push(t);
            }), d.each(r, function(e, t) {
                a.unshift({
                    path: t,
                    count: e
                });
            }), a;
        }, d.detectStackStyle = function(e) {
            var t = "other", n = {
                offset: 0
            };
            return e.arguments ? t = "chrome" : "undefined" != typeof window && window.opera && e.stacktrace ? t = "opera10" : e.stack ? (t = "firefox", 
            n.offset = -1 === e.stack.indexOf("Trace exception") ? 1 : 0) : "undefined" == typeof window || !window.opera || "stacktrace" in e || (t = "opera"), 
            n.style = t, n;
        }, d.obtainException = function() {
            try {
                throw new Error("Trace exception");
            } catch (e) {
                return e;
            }
        };
        var o = d.detectStackStyle(d.obtainException());
        d.registerNamespace("fluid.exceptionDecoders"), d.decodeStack = function() {
            if ("firefox" !== o.style) return null;
            var e = d.obtainException();
            return d.exceptionDecoders[o.style](e);
        }, d.exceptionDecoders.firefox = function(e) {
            var t = e.stack.replace(/(?:\n@:0)?\s+$/m, "").replace(/^\(/gm, "{anonymous}(").split("\n");
            return d.transform(t, function(e) {
                var t = (e = e.replace(/\)/g, "")).indexOf("at ");
                return -1 === t ? [ e ] : [ e.substring(t + "at ".length), e.substring(0, t) ];
            });
        }, d.getCallerInfo = function(e) {
            e = (e || 3) - o.offset;
            var t = d.decodeStack(), n = t && t[e][0];
            if (n) {
                var r = n.lastIndexOf("/");
                -1 === r && (r = 0);
                var a = n.indexOf(":", r);
                return {
                    path: n.substring(0, r),
                    filename: n.substring(r + 1, a),
                    index: n.substring(a + 1)
                };
            }
            return null;
        }, d.generatePadding = function(e, t) {
            for (var n = "", r = 0; r < t; ++r) n += e;
            return n;
        }, d.SYNTHETIC_PROPERTY = Object.freeze({}), d.getSafeProperty = function(e, t) {
            var n = Object.getOwnPropertyDescriptor(e, t);
            return n && !n.get ? e[t] : d.SYNTHETIC_PROPERTY;
        }, d.prettyPrintJSON = function(e, t) {
            return (t = r.extend({
                indent: 4,
                stack: [],
                output: ""
            }, t)).indentChars = d.generatePadding(" ", t.indent), function e(t, n, r) {
                function a(e) {
                    r.output += e;
                }
                var o = n + r.indentChars, i = "function" == typeof t;
                if (void 0 !== r.maxRenderChars && r.output.length > r.maxRenderChars) return !0;
                if (null === t) a("null"); else if (void 0 === t) a("undefined"); else if (t === d.SYNTHETIC_PROPERTY) a("[Synthetic property]"); else if (d.isPrimitive(t) && !i) a(JSON.stringify(t)); else {
                    if (-1 !== r.stack.indexOf(t)) return void a("(CIRCULAR)");
                    var u;
                    if (r.stack.push(t), d.isArrayable(t)) if (0 === t.length) a("[]"); else {
                        for (a("[\n" + o), u = 0; u < t.length; ++u) {
                            if (e(t[u], o, r)) return !0;
                            u !== t.length - 1 && a(",\n" + o);
                        }
                        a("\n" + n + "]");
                    } else {
                        a("{" + (i ? " Function" : "") + "\n" + o);
                        var s = d.keys(t);
                        for (u = 0; u < s.length; ++u) {
                            var l = s[u], c = d.getSafeProperty(t, l);
                            if (a(JSON.stringify(l) + ": "), e(c, o, r)) return !0;
                            u !== s.length - 1 && a(",\n" + o);
                        }
                        a("\n" + n + "}");
                    }
                    r.stack.pop();
                }
            }(e, "", t), t.output;
        }, d.dumpEl = function(e) {
            var t;
            if (!e) return "null";
            if (3 === e.nodeType || 8 === e.nodeType) return "[data: " + e.data + "]";
            if (9 === e.nodeType) return "[document: location " + e.location + "]";
            if (e.nodeType || !d.isArrayable(e)) return t = (e = r(e)).get(0).tagName, e.id && (t += "#" + e.id), 
            e.attr("class") && (t += "." + e.attr("class")), t;
            t = "[";
            for (var n = 0; n < e.length; ++n) t += d.dumpEl(e[n]), n < e.length - 1 && (t += ", ");
            return t + "]";
        };
    }(t, n = n || {}), function(d, h) {
        "use strict";
        h.visitComponentChildren = function(e, t, n, r) {
            for (var a in r = r || [], e) {
                var o = e[a];
                if (!(!h.isComponent(o) || n.visited && n.visited[o.id])) {
                    if (r.push(a), n.visited && (n.visited[o.id] = !0), t(o, a, r, r.length - 1)) return !0;
                    n.flat || h.visitComponentChildren(o, t, n, r), r.pop();
                }
            }
        }, h.getContextHash = function(e, t) {
            var n = e.idToShadow[t.id];
            return n && n.contextHash;
        }, h.componentHasGrade = function(e, t) {
            var n = h.getContextHash(h.globalInstantiator, e);
            return !(!n || !n[t]);
        }, h.visitComponentsForMatching = function(e, t, o) {
            var i = h.getInstantiator(e);
            t = d.extend({
                visited: {},
                instantiator: i
            }, t);
            var u = [ e ], s = [ h.getContextHash(i, e) ];
            h.visitComponentChildren(e, function(e, t, n) {
                u.length = 1, s.length = 1;
                for (var r = 0; r < n.length; ++r) {
                    var a = u[r][n[r]];
                    u[r + 1] = a, s[r + 1] = h.getContextHash(i, a) || {};
                }
                return o(e, u, s, n, n.length);
            }, t, []);
        }, h.getMemberNames = function(e, t) {
            if (0 === t.length) return [];
            var n = e.idToPath(t[t.length - 1].id), r = e.parseEL(n);
            return r.unshift.apply(r, h.generate(t.length - r.length, "")), r;
        }, h.visitComponentsForVisibility = function(e, t, n, r) {
            r = r || {
                visited: {},
                flat: !0,
                instantiator: e
            };
            for (var a = h.getMemberNames(e, t), o = t.length - 1; 0 <= o; --o) {
                var i = t[o];
                if (r.visited[i.id] = !0, n(i, a[o], a, o)) return;
                if (h.visitComponentChildren(i, n, r, a)) return;
                a.pop();
            }
        }, h.mountStrategy = function(o, e, i) {
            var u = o.length;
            return function(e, t, n, r) {
                if (!(n <= o.length)) {
                    for (var a = 0; a < o.length; ++a) if (r[a] !== o[a]) return;
                    return i(e, t, n - o.length, r.slice(u));
                }
            };
        }, h.invokerFromRecord = function(e, t, n) {
            h.pushActivity("makeInvoker", "beginning instantiation of invoker with name %name and record %record as child of %that", {
                name: t,
                record: e,
                that: n
            });
            var r = e ? h.makeInvoker(n, e, t) : void 0;
            return h.popActivity(), r;
        }, h.memberFromRecord = function(e, t, n) {
            for (var r, a = 0; a < e.length; ++a) {
                var o = h.expandImmediate(e[a], n);
                r = h.isPlainObject(r) ? d.extend(!0, r, o) : o;
            }
            return r;
        }, h.recordStrategy = function(o, i, u, s, l, n, r) {
            return n = n || [], {
                strategy: function(e, t, n) {
                    if (1 === n) {
                        var r = h.driveStrategy(i, [ s, t ], u);
                        if (void 0 !== r) {
                            h.set(e, [ t ], h.inEvaluationMarker);
                            var a = l(r, t, o);
                            return h.set(e, [ t ], a), a;
                        }
                    }
                },
                initter: function() {
                    var e = h.driveStrategy(i, s, u) || {};
                    for (var t in e) r && r[t] || h.getForComponent(o, n.concat([ t ]));
                }
            };
        }, h.instantiateFirers = function(e) {
            var t = h.shadowForComponent(e);
            (h.get(t, [ "eventStrategyBlock", "initter" ]) || h.identity)();
        }, h.makeDistributionRecord = function(e, t, n, r, a, o) {
            o = o || "distribution", h.pushActivity("makeDistributionRecord", "Making distribution record from source record %sourceRecord path %sourcePath to target path %targetSegs", {
                sourceRecord: t,
                sourcePath: n,
                targetSegs: r
            });
            var i = h.copy(h.get(t, n));
            h.each(a, function(e) {
                h.model.applyChangeRequest(i, {
                    segs: e,
                    type: "DELETE"
                });
            });
            var u = {
                options: {}
            };
            return h.model.applyChangeRequest(u, {
                segs: r,
                type: "ADD",
                value: i
            }), h.checkComponentRecord(u), h.popActivity(), d.extend(u, {
                contextThat: e,
                recordType: o
            });
        }, h.filterBlocks = function(t, e, a, o, i, u) {
            var s = [];
            return h.each(e, function(n) {
                var e = h.get(n.source, a);
                if (void 0 !== e) {
                    s.push(h.makeDistributionRecord(t, n.source, a, o, i, n.recordType));
                    var r = d.extend({}, e);
                    u && h.model.applyChangeRequest(n.source, {
                        segs: a,
                        type: "DELETE"
                    }), h.each(i, function(e) {
                        var t = h.get(r, e);
                        h.set(n.source, a.concat(e), t);
                    });
                }
            }), s;
        }, h.noteCollectedDistribution = function(e, t, n) {
            h.model.setSimple(e, [ "collectedDistributions", t, n.id ], !0);
        }, h.isCollectedDistribution = function(e, t, n) {
            return h.model.getSimple(e, [ "collectedDistributions", t, n.id ]);
        }, h.clearCollectedDistributions = function(e, t) {
            h.model.applyChangeRequest(e, {
                segs: [ "collectedDistributions", t ],
                type: "DELETE"
            });
        }, h.collectDistributions = function(e, t, n, r, a, o, i) {
            var u = o[o.length - 1];
            !h.isCollectedDistribution(t, u, n) && h.matchIoCSelector(n.selector, r, a, o, i) && (e.push.apply(e, n.blocks), 
            h.noteCollectedDistribution(t, u, n));
        }, h.registerCollectedClearer = function(e, t, n) {
            !e.collectedClearer && t && (e.collectedClearer = function() {
                h.clearCollectedDistributions(t, n);
            });
        }, h.receiveDistributions = function(e, t, n, r) {
            var a = h.getInstantiator(e || r), o = a.getThatStack(e || r);
            o.unshift(h.rootComponent);
            var i = h.getMemberNames(a, o), u = h.transform(o, function(e) {
                return a.idToShadow[e.id];
            }), s = u[u.length - (e ? 1 : 2)], l = h.getMembers(u, "contextHash");
            e ? (i.push(n), l.push(h.gradeNamesToHash(t)), o.push(r)) : h.registerCollectedClearer(u[u.length - 1], s, i[i.length - 1]);
            for (var c = [], d = 0; d < o.length - 1; ++d) h.each(u[d].distributions, function(e) {
                h.collectDistributions(c, s, e, o, l, i, d);
            });
            return c;
        }, h.computeTreeDistance = function(e, t) {
            for (var n = 0; n < e.length && n < t.length && e[n] === t[n]; ) ++n;
            return e.length + t.length - 2 * n;
        }, h.computeDistributionPriority = function(e, t) {
            if (!t.priority) {
                var n = h.getInstantiator(e), r = n.getThatStack(e), a = h.getMemberNames(n, r), o = n.getThatStack(t.contextThat), i = h.getMemberNames(n, o), u = h.computeTreeDistance(a, i);
                t.priority = h.mergeRecordTypes.distribution - u;
            }
            return t;
        }, h.applyDistributions = function(t, e, n) {
            var r = h.transform(e, function(e) {
                return h.generateExpandBlock(e, t, n.mergePolicy);
            }, function(e) {
                return h.computeDistributionPriority(t, e);
            }), a = n.mergeOptions;
            return a.mergeBlocks.push.apply(a.mergeBlocks, r), a.updateBlocks(), r;
        }, h.matchIoCSelector = function(e, t, n, r, a) {
            for (var o = t.length - 1, i = e.length - 1; ;) {
                for (var u = e[i].child, s = o === t.length - 1 || u, l = t[o], c = e[i], d = !0, f = 0; f < c.predList.length; ++f) {
                    var p = c.predList[f], m = p.context;
                    if (m && "*" !== m && !n[o][m] && r[o] !== m) {
                        d = !1;
                        break;
                    }
                    if (p.id && l.id !== p.id) {
                        d = !1;
                        break;
                    }
                }
                if (0 === i && a < o && s && u && (d = !1), d) {
                    if (0 === i) return !0;
                    --o, --i;
                } else {
                    if (s) return !1;
                    --o;
                }
                if (o < a) return !1;
            }
        }, h.queryIoCSelector = function(e, t, n) {
            var r = h.parseSelector(t, h.IoCSSMatcher), a = [];
            return h.visitComponentsForMatching(e, {
                flat: n
            }, function(e, t, n) {
                h.matchIoCSelector(r, t, n, [], 1) && a.push(e);
            }), a;
        }, h.isIoCSSSelector = function(e) {
            return -1 !== e.indexOf(" ");
        }, h.pushDistributions = function(e, t, n, r) {
            var a = h.shadowForComponent(e), o = h.allocateGuid(), i = {
                id: o,
                target: n,
                selector: t,
                blocks: r
            };
            return Object.freeze(i), Object.freeze(i.blocks), h.pushArray(a, "distributions", i), 
            o;
        }, h.clearDistribution = function(e, t) {
            var n = h.globalInstantiator.idToShadow[e];
            n && h.remove_if(n.distributions, function(e) {
                return e.id === t;
            });
        }, h.clearDistributions = function(e) {
            h.each(e.outDistributions, function(e) {
                h.clearDistribution(e.targetHeadId, e.distributionId);
            });
        }, h.extractSelectorHead = function(e) {
            var t = e[0].predList, n = t[0].context;
            return t.length = 0, n;
        }, h.parseExpectedOptionsPath = function(e, t) {
            var n = h.model.parseEL(e);
            return "options" !== n[0] && h.fail("Error in options distribution path ", e, " - only " + t + ' paths beginning with "options" are supported'), 
            n.slice(1);
        }, h.replicateProperty = function(t, n, e) {
            void 0 !== t[n] && h.each(e, function(e) {
                e[n] = t[n];
            });
        }, h.undistributableOptions = [ "gradeNames", "distributeOptions", "argumentMap", "initFunction", "mergePolicy", "progressiveCheckerOptions" ], 
        h.distributeOptions = function(m, e) {
            var g = h.shadowForComponent(m), t = h.driveStrategy(m.options, "distributeOptions", e);
            h.each(t, function(e) {
                h.pushActivity("distributeOptions", "parsing distributeOptions block %record %that ", {
                    that: m,
                    record: e
                }), "string" != typeof e.target && h.fail("Error in options distribution record ", e, ' a member named "target" must be supplied holding an IoC reference'), 
                "string" == typeof e.source ^ void 0 === e.record && h.fail("Error in options distribution record ", e, ': must supply either a member "source" holding an IoC reference or a member "record" holding a literal record');
                var t, n, r, a = h.parseContextReference(e.target);
                if (h.isIoCSSSelector(a.context)) {
                    n = h.parseSelector(a.context, h.IoCSSMatcher);
                    var o = h.extractSelectorHead(n);
                    "/" === o ? t = h.rootComponent : r = o;
                } else r = a.context;
                (t = t || h.resolveContext(r, m)) || h.fail("Error in options distribution record ", e, " - could not resolve context {" + r + "} to a head component");
                var i, u = h.model.parseEL(a.path);
                if (void 0 !== e.record) i = [ h.makeDistributionRecord(m, e.record, [], u, []) ]; else {
                    var s = h.parseContextReference(e.source);
                    "that" !== s.context && h.fail("Error in options distribution record ", e, " only a context of {that} is supported");
                    var l = h.parseExpectedOptionsPath(s.path, "source"), c = h.makeArray(e.exclusions).concat(0 === l.length ? h.undistributableOptions : []), d = h.transform(c, function(e) {
                        return h.model.parseEL(e);
                    });
                    i = h.filterBlocks(m, g.mergeOptions.mergeBlocks, l, u, d, e.removeSource), g.mergeOptions.updateBlocks();
                }
                if (h.replicateProperty(e, "priority", i), h.replicateProperty(e, "namespace", i), 
                n) {
                    var f = h.pushDistributions(t, n, e.target, i);
                    g.outDistributions = g.outDistributions || [], g.outDistributions.push({
                        targetHeadId: t.id,
                        distributionId: f
                    });
                } else {
                    var p = h.shadowForComponent(t);
                    h.applyDistributions(m, i, p);
                }
                h.popActivity();
            });
        }, h.gradeNamesToHash = function(e) {
            var t = {};
            return h.each(e, function(e) {
                t[e] = !0, t[h.computeNickName(e)] = !0;
            }), t;
        }, h.cacheShadowGrades = function(n, r) {
            var e = h.gradeNamesToHash(n.options.gradeNames);
            e[r.memberName] || (e[r.memberName] = "memberName"), r.contextHash = e, h.each(e, function(e, t) {
                r.ownScope[t] = n, r.parentShadow && "fluid.rootComponent" !== r.parentShadow.that.type && (r.parentShadow.childrenScope[t] = n);
            });
        }, h.deliverOptionsStrategy = function(e, t, n) {
            var r = h.shadowForComponent(e, r);
            h.cacheShadowGrades(e, r), r.mergeOptions = n;
        }, h.collectDistributedGrades = function(e) {
            var t = h.receiveDistributions(null, null, null, e.that);
            if (0 < t.length) {
                var n = h.applyDistributions(e.that, t, e.shadow), r = h.transform(h.getMembers(n, [ "source", "gradeNames" ]), h.makeArray);
                h.accumulateDynamicGrades(e, h.flatten(r));
            }
        }, h.applyDynamicGrades = function(t) {
            t.oldGradeNames = h.makeArray(t.gradeNames);
            var e = h.copy(h.getMergedDefaults(t.that.typeName, t.gradeNames));
            t.gradeNames.length = 0, t.gradeNames.push.apply(t.gradeNames, e.gradeNames), h.each(t.gradeNames, function(e) {
                h.isIoCReference(e) || (t.seenGrades[e] = !0);
            });
            var n = t.shadow;
            h.cacheShadowGrades(t.that, n), n.mergeOptions.destroyValue([ "mergePolicy" ]), 
            n.mergeOptions.destroyValue([ "components" ]), n.mergeOptions.destroyValue([ "invokers" ]), 
            t.defaultsBlock.source = e, n.mergeOptions.updateBlocks(), n.mergeOptions.computeMergePolicy(), 
            h.accumulateDynamicGrades(t, e.gradeNames);
        }, h.accumulateDynamicGrades = function(t, e) {
            h.each(e, function(e) {
                t.seenGrades[e] || (h.isIoCReference(e) ? (t.rawDynamic.push(e), t.seenGrades[e] = !0) : h.contains(t.oldGradeNames, e) || t.plainDynamic.push(e));
            });
        }, h.computeDynamicGrades = function(e, t, n) {
            delete e.options.gradeNames;
            var r = h.driveStrategy(e.options, "gradeNames", n);
            r.length = 0;
            var a = {
                that: e,
                shadow: t,
                defaultsBlock: h.findMergeBlocks(t.mergeOptions.mergeBlocks, "defaults")[0],
                gradeNames: r,
                seenGrades: {},
                plainDynamic: [],
                rawDynamic: []
            };
            for (h.each(t.mergeOptions.mergeBlocks, function(e) {
                r.push.apply(r, h.makeArray(e.target && e.target.gradeNames)), h.applyDynamicGrades(a);
            }), h.collectDistributedGrades(a); ;) {
                for (;0 < a.plainDynamic.length; ) r.push.apply(r, a.plainDynamic), a.plainDynamic.length = 0, 
                h.applyDynamicGrades(a), h.collectDistributedGrades(a);
                if (!(0 < a.rawDynamic.length)) break;
                var o = h.expandImmediate(a.rawDynamic.shift(), e, t.localDynamic);
                "function" == typeof o && (o = o()), o && (a.plainDynamic = a.plainDynamic.concat(o));
            }
            t.collectedClearer && (t.collectedClearer(), delete t.collectedClearer);
        }, h.computeDynamicComponentKey = function(e, t) {
            return e + (0 === t ? "" : "-" + t);
        }, h.hasDynamicComponentCount = function(e, t) {
            var n = t.indexOf("-");
            if (-1 !== n) {
                var r = t.substring(0, n);
                return void 0 !== e.dynamicComponentCount && void 0 !== e.dynamicComponentCount[r];
            }
        }, h.clearDynamicParentRecord = function(e, t) {
            if (h.hasDynamicComponentCount(e, t)) {
                var n = h.get(e.that, [ "options", "components" ]);
                n && delete n[t];
            }
        }, h.registerDynamicRecord = function(e, t, n, r, a) {
            var o = h.computeDynamicComponentKey(t, n), i = h.copy(r);
            return delete i[a], h.set(e.options, [ "components", o ], i), o;
        }, h.computeDynamicComponents = function(o, e) {
            var i = h.shadowForComponent(o), u = i.subcomponentLocal = {}, t = h.driveStrategy(o.options, "dynamicComponents", e.strategy);
            h.each(t, function(r, a) {
                if (r.sources || r.createOnEvent || h.fail("Cannot process dynamicComponents record ", r, ' without a "sources" or "createOnEvent" entry'), 
                r.sources) {
                    var e = h.expandOptions(r.sources, o);
                    h.each(e, function(e, t) {
                        var n = h.registerDynamicRecord(o, a, t, r, "sources");
                        u[n] = {
                            source: e,
                            sourcePath: t
                        };
                    });
                } else if (r.createOnEvent) {
                    var t = h.event.expandOneEvent(o, r.createOnEvent);
                    h.set(i, [ "dynamicComponentCount", a ], 0);
                    var n = function() {
                        var e = h.registerDynamicRecord(o, a, i.dynamicComponentCount[a]++, r, "createOnEvent"), t = {
                            arguments: h.makeArray(arguments)
                        };
                        h.initDependent(o, e, t);
                    };
                    t.addListener(n), h.recordListener(t, n, i);
                }
            });
        }, h.computeComponentAccessor = function(e, t) {
            var n = h.globalInstantiator, r = h.shadowForComponent(e);
            r.localDynamic = t;
            var a = e.options, o = r.mergeOptions.strategy, i = h.mountStrategy([ "options" ], a, o);
            r.invokerStrategy = h.recordStrategy(e, a, o, "invokers", h.invokerFromRecord), 
            r.eventStrategyBlock = h.recordStrategy(e, a, o, "events", h.eventFromRecord, [ "events" ]);
            var u = h.mountStrategy([ "events" ], e, r.eventStrategyBlock.strategy, [ "events" ]);
            if (r.memberStrategy = h.recordStrategy(e, a, o, "members", h.memberFromRecord, null, {
                model: !0,
                modelRelay: !0
            }), r.getConfig = {
                strategies: [ h.model.funcResolverStrategy, h.makeGingerStrategy(e), i, r.invokerStrategy.strategy, r.memberStrategy.strategy, u ]
            }, h.computeDynamicGrades(e, r, o, r.mergeOptions.mergeBlocks), h.distributeOptions(e, o), 
            r.contextHash["fluid.resolveRoot"]) {
                var s;
                if (r.contextHash["fluid.resolveRootSingle"]) {
                    var l = h.getForComponent(e, [ "options", "singleRootType" ]);
                    l || h.fail("Cannot register object with grades " + Object.keys(r.contextHash).join(", ") + " as fluid.resolveRootSingle since it has not defined option singleRootType"), 
                    s = h.typeNameToMemberName(l);
                } else s = h.computeGlobalMemberName(e);
                var c = h.resolveRootComponent;
                c[s] && n.clearComponent(c, s), n.recordKnownComponent(c, e, s, !1);
            }
            return r.getConfig;
        }, h.shadowForComponent = function(e) {
            var t = h.getInstantiator(e);
            return t && e ? t.idToShadow[e.id] : null;
        }, h.getForComponent = function(e, t) {
            var n = h.shadowForComponent(e), r = n ? n.getConfig : void 0;
            return h.get(e, t, r);
        }, h.makeGingerStrategy = function(e) {
            var s = h.getInstantiator(e);
            return function(e, t, n, r) {
                var a = e[t];
                if (a === h.inEvaluationMarker && n === r.length && h.fail('Error in component configuration - a circular reference was found during evaluation of path segment "' + t + '": for more details, see the activity records following this message in the console, or issue fluid.setLogging(fluid.logLevel.TRACE) when running your application'), 
                1 < n) return a;
                if (void 0 === a && e.hasOwnProperty(t)) return h.NO_VALUE;
                if (void 0 === a) {
                    var o = s.idToShadow[e.id].path, i = s.composePath(o, t);
                    a = s.pathToComponent[i];
                }
                if (void 0 === a) {
                    var u = h.getForComponent(e, [ "options", "components", t ]);
                    u && (u.createOnEvent && h.fail('Error resolving path segment "' + t + '" of path ' + r.join(".") + " since component with record ", u, ' has annotation "createOnEvent" - this very likely represents an implementation error. Either alter the reference so it does not  match this component, or alter your workflow to ensure that the component is instantiated by the time this reference resolves'), 
                    h.initDependent(e, t), a = e[t]);
                }
                return a;
            };
        }, h.frameworkGrades = [ "fluid.component", "fluid.modelComponent", "fluid.viewComponent", "fluid.rendererComponent" ], 
        h.filterBuiltinGrades = function(e) {
            return h.remove_if(h.makeArray(e), function(e) {
                return -1 !== h.frameworkGrades.indexOf(e);
            });
        }, h.dumpGradeNames = function(e) {
            return e.options && e.options.gradeNames ? " gradeNames: " + JSON.stringify(h.filterBuiltinGrades(e.options.gradeNames)) : "";
        }, h.dumpThat = function(e) {
            return '{ typeName: "' + e.typeName + '"' + h.dumpGradeNames(e) + " id: " + e.id + "}";
        }, h.dumpThatStack = function(e, n) {
            return h.transform(e, function(e) {
                var t = n.idToPath(e.id);
                return h.dumpThat(e) + (t ? " - path: " + t : "");
            }).join("\n");
        }, h.dumpComponentPath = function(e) {
            var t = h.pathForComponent(e);
            return t ? h.pathUtil.composeSegments(t) : "** no path registered for component **";
        }, h.resolveContext = function(r, e, t) {
            if ("that" === r) return e;
            if ("object" == typeof r) {
                var n = h.resolveContext(r.context, e, t);
                h.isComponent(n) || h.triggerMismatchedPathError(r.context, e);
                var a = h.getForComponent(n, r.path), o = h.expandOptions(a, e);
                return h.isComponent(o) || h.fail("Unable to resolve recursive context expression " + h.renderContextReference(r) + ": the directly resolved value of " + a + " did not resolve to a component in the scope of component ", e, ": got ", o), 
                o;
            }
            var i, u = h.globalInstantiator;
            if (t) return u.idToShadow[e.id].ownScope[r];
            var s = u.getFullStack(e);
            return h.visitComponentsForVisibility(u, s, function(e, t) {
                var n = h.shadowForComponent(e);
                return r === t || n && n.contextHash && n.contextHash[r] || r === e.typeName ? (i = e, 
                !0) : h.getForComponent(e, [ "options", "components", r ]) && !e[r] ? (i = h.getForComponent(e, r), 
                !0) : void 0;
            }), i;
        }, h.triggerMismatchedPathError = function(e, t) {
            var n = h.renderContextReference(e);
            h.fail("Failed to resolve reference " + n + " - could not match context with name " + e.context + " from component " + h.dumpThat(t) + " at path " + h.dumpComponentPath(t) + " component: ", t);
        }, h.makeStackFetcher = function(r, a, o) {
            return function(e) {
                r && "destroyed" === r.lifecycleStatus && h.fail("Cannot resolve reference " + h.renderContextReference(e) + " from component " + h.dumpThat(r) + " which has been destroyed");
                var t = e.context;
                if (a && t in a) return h.get(a[t], e.path);
                var n = h.resolveContext(t, r, o);
                return n || "" === e.path || h.triggerMismatchedPathError(e, r), h.getForComponent(n, e.path);
            };
        }, h.makeStackResolverOptions = function(e, t, n) {
            return d.extend(h.copy(h.rawDefaults("fluid.makeExpandOptions")), {
                localRecord: t || {},
                fetcher: h.makeStackFetcher(e, t, n),
                contextThat: e,
                exceptions: {
                    members: {
                        model: !0,
                        modelRelay: !0
                    }
                }
            });
        }, h.clearListeners = function(e) {
            h.each(e.listeners, function(e) {
                e.event.removeListener(e.listenerId || e.listener);
            }), delete e.listeners;
        }, h.recordListener = function(e, t, n, r) {
            e.ownerId !== n.that.id && h.pushArray(n, "listeners", {
                event: e,
                listener: t,
                listenerId: r
            });
        }, h.constructScopeObjects = function(e, t, n, r) {
            var a = t ? e.idToShadow[t.id] : null;
            r.childrenScope = a ? Object.create(a.ownScope) : {}, r.ownScope = Object.create(r.childrenScope), 
            r.parentShadow = a;
        }, h.clearChildrenScope = function(e, n, r, t) {
            h.each(t.contextHash, function(e, t) {
                n.childrenScope[t] === r && delete n.childrenScope[t];
            });
        }, h.instantiator = function() {
            var c = h.typeTag("instantiator");
            function i(e, t, n, r, a) {
                var o;
                if (a) (o = c.idToShadow[t.id] = {}).that = t, o.path = n, o.memberName = r, h.constructScopeObjects(c, e, t, o); else {
                    (o = c.idToShadow[t.id]).injectedPaths = o.injectedPaths || {}, o.injectedPaths[n] = !0;
                    var i = c.idToShadow[e.id], u = h.keys(o.contextHash);
                    h.remove_if(u, function(e) {
                        return o.contextHash && "memberName" === o.contextHash[e];
                    }), u.push(r), h.each(u, function(e) {
                        i.childrenScope[e] || (i.childrenScope[e] = t);
                    });
                }
                c.pathToComponent[n] && h.fail("Error during instantiation - path " + n + " which has just created component " + h.dumpThat(t) + " has already been used for component " + h.dumpThat(c.pathToComponent[n]) + " - this is a circular instantiation or other oversight. Please clear the component using instantiator.clearComponent() before reusing the path."), 
                c.pathToComponent[n] = t;
            }
            return d.extend(c, {
                lifecycleStatus: "constructed",
                pathToComponent: {},
                idToShadow: {},
                modelTransactions: {
                    init: {}
                },
                composePath: h.model.composePath,
                composeSegments: h.model.composeSegments,
                parseEL: h.model.parseEL,
                events: {
                    onComponentAttach: h.makeEventFirer({
                        name: "instantiator's onComponentAttach event"
                    }),
                    onComponentClear: h.makeEventFirer({
                        name: "instantiator's onComponentClear event"
                    })
                }
            }), c.idToPath = function(e) {
                var t = c.idToShadow[e];
                return t ? t.path : "";
            }, c.getThatStack = function(e) {
                var t = c.idToShadow[e.id];
                if (t) {
                    for (var n = t.path, r = c.parseEL(n), a = c.pathToComponent[""], o = [], i = 0; i < r.length; ++i) a = a[r[i]], 
                    o.push(a);
                    return o;
                }
                return [];
            }, c.getFullStack = function(e) {
                var t = e ? c.getThatStack(e) : [];
                return t.unshift(h.resolveRootComponent), t;
            }, c.recordRoot = function(e) {
                i(null, e, "", "", !0);
            }, c.recordKnownComponent = function(e, t, n, r) {
                if (e[n] = t, h.isComponent(t) || "instantiator" === t.type) {
                    var a = c.idToShadow[e.id].path, o = c.composePath(a, n);
                    i(e, t, o, n, r), c.events.onComponentAttach.fire(t, o, c, r);
                } else h.fail("Cannot record non-component with value ", t, ' at path "' + n + '" of parent ', e);
            }, c.clearConcreteComponent = function(a) {
                h.each(a.childShadow.injectedPaths, function(e, t) {
                    var n = h.model.getToTailPath(t), r = c.pathToComponent[n];
                    c.clearComponent(r, h.model.getTailPath(t), a.child);
                }), h.clearDistributions(a.childShadow), h.clearListeners(a.childShadow), h.clearDynamicParentRecord(a.shadow, a.name), 
                h.fireEvent(a.child, "afterDestroy", [ a.child, a.name, a.component ]), delete c.idToShadow[a.child.id];
            }, c.clearComponent = function(e, t, o, i, n, r) {
                var a = c.idToShadow[e.id];
                i = i || {
                    flat: !0,
                    instantiator: c,
                    destroyRecs: []
                }, o = o || e[t], void 0 === (r = r || a.path) && h.fail("Cannot clear component " + t + " from component ", e, " which was not created by this instantiator");
                var u = c.composePath(r, t), s = c.idToShadow[o.id];
                if (s) {
                    var l = s.path === u;
                    c.events.onComponentClear.fire(o, u, e, l), l ? (h.visitComponentChildren(o, function(e, t, n, r) {
                        var a = c.composeSegments.apply(null, n.slice(0, r));
                        c.clearComponent(o, t, null, i, !0, a);
                    }, i, c.parseEL(u)), h.doDestroy(o, t, e), i.destroyRecs.push({
                        child: o,
                        childShadow: s,
                        name: t,
                        component: e,
                        shadow: a
                    })) : h.remove_if(s.injectedPaths, function(e, t) {
                        return t === u;
                    }), h.clearChildrenScope(c, a, o, s), delete c.pathToComponent[u], n || (delete e[t], 
                    h.each(i.destroyRecs, c.clearConcreteComponent));
                }
            }, c;
        }, h.globalInstantiator = h.instantiator(), h.getInstantiator = function(e) {
            var t = h.globalInstantiator;
            return e && t.idToShadow[e.id] ? t : null;
        }, h.defaults("fluid.resolveRoot"), h.defaults("fluid.resolveRootSingle", {
            gradeNames: "fluid.resolveRoot"
        }), h.constructRootComponents = function(e) {
            h.rootComponent = e.rootComponent = h.typeTag("fluid.rootComponent"), e.recordRoot(h.rootComponent), 
            h.resolveRootComponent = e.resolveRootComponent = h.typeTag("fluid.resolveRootComponent"), 
            e.recordKnownComponent(h.rootComponent, h.resolveRootComponent, "resolveRootComponent", !0);
            var t = e.idToShadow[h.rootComponent.id];
            t.contextHash = {};
            var n = e.idToShadow[h.resolveRootComponent.id];
            n.ownScope = t.ownScope, n.childrenScope = t.childrenScope, e.recordKnownComponent(h.resolveRootComponent, e, "instantiator", !0), 
            n.childrenScope.instantiator = e;
        }, h.constructRootComponents(h.globalInstantiator), h.expandOptions = function(e, t, n, r, a) {
            if (!e) return e;
            h.pushActivity("expandOptions", "expanding options %args for component %that ", {
                that: t,
                args: e
            });
            var o = h.makeStackResolverOptions(t, r);
            o.mergePolicy = n, o.defer = a && a.defer;
            var i = o.defer ? h.makeExpandOptions(e, o) : h.expand(e, o);
            return h.popActivity(), i;
        }, h.localRecordExpected = h.arrayToHash([ "type", "options", "container", "createOnEvent", "priority", "recordType" ]), 
        h.checkComponentRecord = function(n) {
            h.each(n, function(e, t) {
                h.localRecordExpected[t] || h.fail("Probable error in subcomponent record ", n, ' - key "' + t + '" found, where the only legal options are ' + h.keys(h.localRecordExpected).join(", "));
            });
        }, h.mergeRecordsToList = function(n, e) {
            var r = [];
            return h.each(e, function(e, t) {
                if ("distributions" === (e.recordType = t)) r.push.apply(r, h.transform(e, function(e) {
                    return h.computeDistributionPriority(n, e);
                })); else {
                    if (!e.options) return;
                    e.priority = h.mergeRecordTypes[t], void 0 === e.priority && h.fail("Merge record with unrecognised type " + t + ": ", e), 
                    r.push(e);
                }
            }), r;
        };
        h.generateExpandBlock = function(e, t, n, r) {
            var a = h.expandOptions(e.options, e.contextThat || t, n, r, {
                defer: !0
            });
            return a.priority = e.priority, a.namespace = e.namespace, a.recordType = e.recordType, 
            a;
        };
        function u(t, e, n, r) {
            var a = h.copy(e);
            !function(t) {
                h.each([ "gradeNames", "mergePolicy", "argumentMap", "components", "dynamicComponents", "events", "listeners", "modelListeners", "modelRelay", "distributeOptions", "transformOptions" ], function(e) {
                    h.set(t, [ e, "*", "noexpand" ], !0);
                });
            }(t), h.shadowForComponent(r).mergePolicy = t;
            var o = {
                defaults: {
                    options: a
                }
            };
            d.extend(o, n.mergeRecords), o.subcomponentRecord && h.checkComponentRecord(o.subcomponentRecord);
            var i = h.mergeRecordsToList(r, o);
            return h.transform(i, function(e) {
                return h.generateExpandBlock(e, r, t, n.localRecord);
            });
        }
        h.fabricateDestroyMethod = function(e, t, n, r) {
            return function() {
                n.clearComponent(e, t, r);
            };
        }, h.computeGlobalMemberName = function(e) {
            return h.computeNickName(e.typeName) + "-" + e.id;
        }, h.typeNameToMemberName = function(e) {
            return e.replace(/\./g, "_");
        }, h.expandComponentOptions = function(e, t, n, r) {
            var a = n, o = n && n.marker === h.EXPAND ? n.instantiator : null;
            h.pushActivity("expandComponentOptions", "expanding component options %options with record %record for component %that", {
                options: o ? n.mergeRecords.user : n,
                record: a,
                that: r
            }), o || (o = h.globalInstantiator, a = {
                mergeRecords: {
                    user: {
                        options: h.expandCompact(n, !0)
                    }
                },
                memberName: h.computeGlobalMemberName(r),
                instantiator: o,
                parentThat: h.rootComponent
            }), r.destroy = h.fabricateDestroyMethod(a.parentThat, a.memberName, o, r), o.recordKnownComponent(a.parentThat, r, a.memberName, !0);
            var i = u(e, t, a, r);
            return h.popActivity(), i;
        }, h.assembleCreatorArguments = function(a, e, o) {
            var t = h.defaults(e);
            t && t.argumentMap || h.fail("Error in assembleCreatorArguments: cannot look up component type name " + e + " to a component creator grade with an argumentMap");
            var n = a ? h.receiveDistributions(a, t.gradeNames, o.memberName, {}) : [];
            h.each(n, function(e) {
                h.computeDistributionPriority(a, e), h.isPrimitive(e.priority) && (e.priority = h.parsePriority(e.priority, 0, !1, "options distribution"));
            }), h.sortByPriority(n);
            var i = o.localDynamic, u = d.extend({}, h.censorKeys(o.componentRecord, [ "type" ]), i), r = t.argumentMap, s = Object.keys(r).concat([ "type" ]);
            h.each(s, function(e) {
                for (var t = 0; t < n.length; ++t) void 0 !== n[t][e] && (u[e] = n[t][e]);
            }), e = u.type || e, delete u.type, delete u.options;
            var l = {
                distributions: n
            };
            void 0 !== o.componentRecord && (l.subcomponentRecord = d.extend({}, o.componentRecord));
            var c = [];
            return h.each(r, function(e, t) {
                var n;
                if ("options" === t) n = {
                    marker: h.EXPAND,
                    localRecord: i,
                    mergeRecords: l,
                    instantiator: h.getInstantiator(a),
                    parentThat: a,
                    memberName: o.memberName
                }; else {
                    var r = u[t];
                    n = h.expandImmediate(r, a, u);
                }
                c[e] = n;
            }), {
                args: c,
                funcName: e
            };
        }, h.initDependent = function(e, t, n) {
            if (!e[t]) {
                var r, a = e.options.components[t], o = h.globalInstantiator, i = o.idToShadow[e.id], u = n || i.subcomponentLocal && i.subcomponentLocal[t];
                if (h.pushActivity("initDependent", 'instantiating dependent component at path "%path" with record %record as child of %parent', {
                    path: i.path + "." + t,
                    record: a,
                    parent: e
                }), "string" == typeof a || a.expander) e[t] = h.inEvaluationMarker, (r = h.expandImmediate(a, e)) ? o.recordKnownComponent(e, r, t, !1) : delete e[t]; else if (a.type) {
                    var s = h.expandImmediate(a.type, e, u);
                    s || h.fail("Error in subcomponent record: ", a.type, " could not be resolved to a type for component ", t, " of parent ", e);
                    var l = h.assembleCreatorArguments(e, s, {
                        componentRecord: a,
                        memberName: t,
                        localDynamic: u
                    });
                    r = h.initSubcomponentImpl(e, {
                        type: l.funcName
                    }, l.args);
                } else h.fail("Unrecognised material in place of subcomponent " + t + ' - no "type" field found');
                return h.popActivity(), r;
            }
        }, h.bindDeferredComponent = function(n, r, a) {
            var e = h.makeArray(a.createOnEvent);
            h.each(e, function(t) {
                var e = h.isIoCReference(t) ? h.expandOptions(t, n) : n.events[t];
                e && e.addListener || h.fail("Error instantiating createOnEvent component with name " + r + " of parent ", n, " since event specification " + t + " could not be expanded to an event - got ", e), 
                e.addListener(function() {
                    h.pushActivity("initDeferred", "instantiating deferred component %componentName of parent %that due to event %eventName", {
                        componentName: r,
                        that: n,
                        eventName: t
                    }), n[r] && h.globalInstantiator.clearComponent(n, r);
                    var e = {
                        arguments: h.makeArray(arguments)
                    };
                    h.initDependent(n, r, e), h.popActivity();
                }, null, a.priority);
            });
        }, h.priorityForComponent = function(e) {
            return e.priority ? e.priority : "fluid.typeFount" === e.type || h.hasGrade(h.defaults(e.type), "fluid.typeFount") ? "first" : void 0;
        }, h.initDependents = function(r) {
            h.pushActivity("initDependents", "instantiating dependent components for component %that", {
                that: r
            });
            var e = h.shadowForComponent(r);
            if (e.memberStrategy.initter(), e.invokerStrategy.initter(), h.getForComponent(r, "modelRelay"), 
            h.getForComponent(r, "model"), !h.isDestroyed(r)) {
                var t = r.options.components || {}, a = [];
                h.each(t, function(e, t) {
                    if (e.createOnEvent) h.bindDeferredComponent(r, t, e); else {
                        var n = h.priorityForComponent(e);
                        a.push({
                            namespace: t,
                            priority: h.parsePriority(n)
                        });
                    }
                }), h.sortByPriority(a), h.each(a, function(e) {
                    h.initDependent(r, e.namespace);
                }), e.subcomponentLocal && h.clear(e.subcomponentLocal), r.lifecycleStatus = "constructed", 
                h.assessTreeConstruction(r, e), h.popActivity();
            }
        }, h.assessTreeConstruction = function(e, t) {
            var n = h.globalInstantiator, r = n.getThatStack(e);
            h.find_if(r, function(e) {
                return "constructing" === e.lifecycleStatus;
            }) ? e.lifecycleStatus = "constructed" : h.markSubtree(n, e, t.path, "treeConstructed");
        }, h.markSubtree = function(a, e, o, i) {
            e.lifecycleStatus = i, h.visitComponentChildren(e, function(e, t) {
                var n = a.composePath(o, t), r = a.idToShadow[e.id];
                r && r.path === n && h.markSubtree(a, e, n, i);
            }, {
                flat: !0
            });
        }, h.pathForComponent = function(e, t) {
            var n = (t = t || h.getInstantiator(e) || h.globalInstantiator).idToShadow[e.id];
            return n ? t.parseEL(n.path) : null;
        }, h.construct = function(e, t, n) {
            var r = h.destroy(e, n);
            return h.set(r.parent, [ "options", "components", r.memberName ], {
                type: t.type,
                options: t
            }), h.initDependent(r.parent, r.memberName);
        }, h.destroy = function(e, t) {
            t = t || h.globalInstantiator;
            var n = h.model.parseToSegments(e, t.parseEL, !0);
            0 === n.length && h.fail("Cannot destroy the root component");
            var r = n.pop(), a = t.composeSegments.apply(null, n), o = t.pathToComponent[a];
            return o || h.fail("Cannot modify component with nonexistent parent at path ", e), 
            o[r] && o[r].destroy(), {
                parent: o,
                memberName: r
            };
        }, h.constructSingle = function(e, t, n) {
            n = n || h.globalInstantiator, e = e || "";
            var r = h.model.parseToSegments(e, n.parseEL, !0);
            "string" == typeof t && (t = {
                type: t
            });
            var a = t.type;
            a || h.fail("Cannot construct singleton object without a type entry");
            var o = (t = d.extend({}, t)).gradeNames = h.makeArray(t.gradeNames);
            o.unshift(a), t.type = "fluid.component", 0 === r.length && o.push("fluid.resolveRoot");
            var i = h.typeNameToMemberName(t.singleRootType || a);
            r.push(i), h.construct(r, t, n);
        }, h.destroySingle = function(e, t, n) {
            n = n || h.globalInstantiator;
            var r = h.model.parseToSegments(e, n.parseEL, !0), a = h.typeNameToMemberName(t);
            r.push(a), h.destroy(r, n);
        }, h.makeGradeLinkage = function(e, t, n) {
            h.defaults(e, {
                gradeNames: "fluid.component",
                distributeOptions: {
                    record: n,
                    target: "{/ " + t.join("&") + "}.options.gradeNames"
                }
            }), h.constructSingle([], e);
        }, h.componentForPath = function(e) {
            return h.globalInstantiator.pathToComponent[h.isArrayable(e) ? e.join(".") : e];
        }, h.debugger = function() {}, h.defaults("fluid.debuggingProbe", {
            gradeNames: [ "fluid.component" ]
        }), h.probeToDistribution = function(e) {
            var t = h.globalInstantiator, n = h.parseContextReference(e.target), r = h.model.parseToSegments(n.path, t.parseEL, !0);
            "options" !== r[0] && r.unshift("options");
            var a = h.parsePriority(e.priority);
            return a.constraint && !a.constraint.target && (a.constraint.target = "authoring"), 
            {
                target: "{/ " + n.context + "}." + t.composeSegments.apply(null, r),
                record: {
                    func: e.func,
                    funcName: e.funcName,
                    args: e.args,
                    priority: h.renderPriority(a)
                }
            };
        }, h.registerProbes = function(e) {
            var t = h.transform(e, h.probeToDistribution), n = "fluid_debuggingProbe_" + h.allocateGuid();
            return h.construct([ n ], {
                type: "fluid.debuggingProbe",
                distributeOptions: t
            }), n;
        }, h.deregisterProbes = function(e) {
            h.destroy([ e ]);
        }, h.thisistToApplicable = function(a, o, i) {
            return {
                apply: function(e, t) {
                    var n = h.expandOptions(o, i);
                    "string" == typeof n && (n = h.getGlobalValue(n)), n || h.fail("Could not resolve reference " + o + " to a value");
                    var r = n[a.method];
                    return "function" != typeof r && h.fail("Object ", n, " at reference " + o + " has no member named " + a.method + " which is a function "), 
                    h.passLogLevel(h.logLevel.TRACE) && h.log(h.logLevel.TRACE, "Applying arguments ", t, " to method " + a.method + " of instance ", n), 
                    r.apply(n, t);
                }
            };
        }, h.changeToApplicable = function(u, s) {
            return {
                apply: function(e, t, n, r) {
                    var a = h.parseValidModelReference(s, "changePath listener record", u.changePath), o = h.expandOptions(u.value, s, {}, h.extend(n, {
                        arguments: t
                    })), i = r && r.source && r.source.length ? h.makeArray(u.source).concat(r.source) : u.source;
                    a.applier.change(a.modelSegs, o, u.type, i);
                }
            };
        }, h.recordToApplicable = function(e, t, n) {
            if (void 0 !== e.changePath) return h.changeToApplicable(e, t, n);
            var r = e.this;
            return e.method ^ r && h.fail("Record ", t, ' must contain both entries "method" and "this" if it contains either'), 
            e.method ? h.thisistToApplicable(e, r, t) : null;
        }, h.getGlobalValueNonComponent = function(e, t) {
            var n = h.defaults(e);
            return n && h.hasGrade(n, "fluid.component") && h.fail("Error in function specification - cannot invoke function " + e + " in the context of " + t + ": component creator functions can only be used as subcomponents"), 
            h.getGlobalValue(e);
        }, h.makeInvoker = function(n, r, a) {
            void 0 === (r = h.upgradePrimitiveFunc(r)).args || r.args === h.NO_VALUE || h.isArrayable(r.args) || (r.args = h.makeArray(r.args));
            var o = h.recordToApplicable(r, n), i = h.preExpand(r.args), u = {}, s = h.makeStackResolverOptions(n, u, !0);
            return (o = o || (r.funcName ? h.getGlobalValueNonComponent(r.funcName, "an invoker") : h.expandImmediate(r.func, n))) && o.apply ? o === h.notImplemented && h.fail("Error constructing component ", n, " - the invoker named " + a + " which was defined in grade " + r.componentSource + " needs to be overridden with a concrete implementation") : h.fail("Error in invoker record: could not resolve members func, funcName or method to a function implementation - got " + o + " from ", r), 
            function() {
                var e, t;
                return !1 === h.defeatLogging && h.pushActivity("invokeInvoker", "invoking invoker with name %name and record %record from path %path holding component %that", {
                    name: a,
                    record: r,
                    path: h.dumpComponentPath(n),
                    that: n
                }), "destroyed" === n.lifecycleStatus ? h.log(h.logLevel.WARN, "Ignoring call to invoker " + a + " of component ", n, " which has been destroyed") : (u.arguments = arguments, 
                t = void 0 === r.args || r.args === h.NO_VALUE ? arguments : (h.expandImmediateImpl(i, s), 
                i.source), e = o.apply(null, t)), !1 === h.defeatLogging && h.popActivity(), e;
            };
        }, h.event.makeTrackedListenerAdder = function(e) {
            var i = h.shadowForComponent(e);
            return function(o) {
                return {
                    addListener: function(e, t, n, r, a) {
                        h.recordListener(o, e, i, a), o.addListener.apply(null, arguments);
                    }
                };
            };
        }, h.event.listenerEngine = function(n, r, a) {
            var o = {};
            h.each(n, function(e, t) {
                a(e).addListener(function() {
                    o[t] = h.makeArray(arguments), function() {
                        if (!h.find(n, function(e, t) {
                            if (void 0 === o[t]) return !0;
                        })) {
                            var e = o;
                            o = {}, r(e);
                        }
                    }();
                });
            });
        }, h.event.dispatchListener = function(r, a, o, i, u) {
            void 0 === i.args || i.args === h.NO_VALUE || h.isArrayable(i.args) || (i.args = h.makeArray(i.args)), 
            a = h.event.resolveListener(a);
            function e() {
                !1 === h.defeatLogging && h.pushActivity("dispatchListener", "firing to listener to event named %eventName of component %that", {
                    eventName: o,
                    that: r
                });
                var e, t = u ? arguments[0] : arguments;
                l.arguments = t, e = void 0 !== i.args && i.args !== h.NO_VALUE ? (h.expandImmediateImpl(s, c), 
                s.source) : t;
                var n = a.apply(null, e);
                return !1 === h.defeatLogging && h.popActivity(), n;
            }
            var s = h.preExpand(i.args), l = {}, c = h.makeStackResolverOptions(r, l, !0);
            return h.event.impersonateListener(a, e), e;
        }, h.event.resolveSoftNamespace = function(e) {
            if ("string" != typeof e) return null;
            var t = Math.max(e.lastIndexOf("."), e.lastIndexOf("}"));
            return e.substring(t + 1);
        }, h.event.resolveListenerRecord = function(e, i, u, s, l) {
            function c(e, t) {
                h.fail("Error in listener record - could not resolve reference ", e, ' to a listener or firer. Did you miss out "events." when referring to an event firer?' + t);
            }
            h.pushActivity("resolveListenerRecord", "resolving listener record for event named %eventName for component %that", {
                eventName: u,
                that: i
            });
            var t = h.makeArray(e), n = {
                records: h.transform(t, function(e) {
                    var t = h.isPrimitive(e) || e.expander ? {
                        listener: e
                    } : h.copy(e), n = h.recordToApplicable(e, i, l);
                    t.listener = n || (t.listener || t.func || t.funcName), t.listener || c(e, ' Listener record must contain a member named "listener", "func", "funcName" or "method"');
                    var r = e.method ? h.event.resolveSoftNamespace(e.this) + "." + e.method : h.event.resolveSoftNamespace(t.listener);
                    t.namespace || s || !r || (t.softNamespace = !0, t.namespace = (e.componentSource ? e.componentSource : i.typeName) + "." + r);
                    var a = t.listener = h.expandOptions(t.listener, i);
                    a || c(e, "");
                    var o = !1;
                    return "fluid.event.firer" === a.typeName && (a = a.fire, o = !0), t.listener = l && (t.args && "fluid.notImplemented" !== a || o) ? h.event.dispatchListener(i, a, u, t) : a, 
                    t.listenerId = h.allocateGuid(), t;
                }),
                adderWrapper: l ? h.event.makeTrackedListenerAdder(i) : null
            };
            return h.popActivity(), n;
        }, h.event.expandOneEvent = function(e, t) {
            var n;
            return (n = "string" == typeof t && "{" !== t.charAt(0) ? h.getForComponent(e, [ "events", t ]) : h.expandOptions(t, e)) && "fluid.event.firer" === n.typeName || h.fail("Error in event specification - could not resolve base event reference ", t, " to an event firer: got ", n), 
            n;
        }, h.event.expandEvents = function(t, e) {
            return "string" == typeof e ? h.event.expandOneEvent(t, e) : h.transform(e, function(e) {
                return h.event.expandOneEvent(t, e);
            });
        }, h.event.resolveEvent = function(i, u, s) {
            h.pushActivity("resolveEvent", "resolving event with name %eventName attached to component %that", {
                eventName: u,
                that: i
            });
            var l = h.event.makeTrackedListenerAdder(i);
            "string" == typeof s && (s = {
                event: s
            });
            var e = "fluid.event.firer" === s.typeName ? s : s.event || s.events;
            e || h.fail("Event specification for event with name " + u + " does not include a base event specification: ", s);
            var t, c = "fluid.event.firer" === e.typeName ? e : h.event.expandEvents(i, e), n = "fluid.event.firer" !== c.typeName;
            if (s.args || n) {
                t = h.makeEventFirer({
                    name: " [composite] " + h.event.nameEvent(i, u)
                });
                var r = h.event.dispatchListener(i, t.fire, u, s, n);
                n ? h.event.listenerEngine(c, r, l) : l(c).addListener(r);
            } else (t = {
                typeName: "fluid.event.firer",
                fire: function() {
                    var e = h.makeArray(arguments);
                    h.pushActivity("fireSynthetic", "firing synthetic event %eventName ", {
                        eventName: u
                    });
                    var t = c.fire.apply(null, e);
                    return h.popActivity(), t;
                },
                addListener: function(e, t, n, r, a) {
                    var o = h.event.dispatchListener(i, e, u, s);
                    l(c).addListener(o, t, n, r, a);
                },
                removeListener: function(e) {
                    c.removeListener(e);
                }
            }).originEvent = c;
            return h.popActivity(), t;
        }, h.withEnvironment = function(e, t, n) {
            var r;
            n = n || h.globalThreadLocal();
            try {
                for (r in e) n[r] = e[r];
                return d.extend(n, e), t();
            } finally {
                for (r in e) delete n[r];
            }
        }, h.fetchContextReference = function(e, t, n, r, a) {
            r && (e = r(e, n));
            var o = e.context ? n[e.context] : t;
            return o ? e.noDereference ? e.path : h.get(o, e.path) : a && a(e) || o;
        }, h.makeEnvironmentFetcher = function(n, r, a, o) {
            return a = a || h.globalThreadLocal, function(e) {
                var t = a();
                return h.fetchContextReference(e, n, t, r, o);
            };
        }, h.coerceToPrimitive = function(e) {
            return "false" !== e && ("true" === e || (isFinite(e) ? Number(e) : e));
        }, h.compactStringToRec = function(e, t) {
            var n = e.indexOf("("), r = e.indexOf(")");
            if ((-1 === n ^ -1 === r || r < n) && h.fail("Badly-formed compact " + t + " record without matching parentheses: " + e), 
            -1 === n || -1 === r) return "expander" === t && h.fail("Badly-formed compact expander record without parentheses: " + e), 
            e;
            var a = e.substring(r + 1);
            "" !== d.trim(a) && h.fail("Badly-formed compact " + t + " record " + e + " - unexpected material following close parenthesis: " + a);
            var o = e.substring(0, n), i = d.trim(e.substring(n + 1, r)), u = "" === i ? [] : h.transform(i.split(","), d.trim, h.coerceToPrimitive), s = h.upgradePrimitiveFunc(o, null);
            return s.args = u, s;
        }, h.expandPrefix = "@expand:", h.expandCompactString = function(e, t) {
            var n = e;
            if (0 === e.indexOf(h.expandPrefix)) {
                var r = e.substring(h.expandPrefix.length);
                n = {
                    expander: h.compactStringToRec(r, "expander")
                };
            } else t && (n = h.compactStringToRec(e, t));
            return n;
        };
        var o = {
            listeners: "listener",
            modelListeners: "modelListener"
        }, i = d.extend({
            invokers: "invoker"
        }, o);
        function c(e, t, n, r) {
            for (var a = 0; a < n; ++a) e = r(e, t[a], a, h.makeArray(t));
            return e;
        }
        h.expandCompactRec = function(n, r, e) {
            h.guardCircularExpansion(n, n.length);
            var t = 0 < n.length ? n[n.length - 1] : "", a = i[t];
            !a && 1 < n.length && (a = o[n[n.length - 2]]), h.each(e, function(e, t) {
                if (h.isPlainObject(e)) return r[t] = h.freshContainer(e), n.push(t), h.expandCompactRec(n, r[t], e), 
                void n.pop();
                "string" == typeof e && (e = h.expandCompactString(e, a)), r[t] = e;
            });
        }, h.expandCompact = function(e) {
            var t = {};
            return h.expandCompactRec([], t, e), t;
        }, h.extractEL = function(e, t) {
            if ("ALL" === t.ELstyle) return e;
            if (1 === t.ELstyle.length) {
                if (e.charAt(0) === t.ELstyle) return e.substring(1);
            } else if ("${}" === t.ELstyle) {
                var n = e.indexOf("${"), r = e.lastIndexOf("}");
                if (0 === n && -1 !== r) return e.substring(2, r);
            }
        }, h.extractELWithContext = function(e, t) {
            var n = h.extractEL(e, t);
            return h.isIoCReference(n) ? h.parseContextReference(n) : n ? {
                path: n
            } : n;
        }, h.parseContextReference = function(e, t, n) {
            t = t || 0;
            var r, a, o, i = "{" === e.charAt(t + 1);
            -1 === (r = i ? (o = h.parseContextReference(e, t + 1, "}")).endpos : e.indexOf("}", t + 1)) && h.fail('Cannot parse context reference "' + e + '": Malformed context reference without }'), 
            a = i ? o : e.substring(t + 1, r);
            var u = n ? e.indexOf(n, r + 1) : e.length, s = e.substring(r + 1, u);
            return "." === s.charAt(0) && (s = s.substring(1)), {
                context: a,
                path: s,
                endpos: u
            };
        }, h.renderContextReference = function(e) {
            var t = e.context;
            return "{" + ("string" == typeof t ? t : h.renderContextReference(t)) + "}" + (e.path ? "." + e.path : "");
        }, h.resolveContextValue = function(e, n) {
            function t(e) {
                h.pushActivity("resolveContextValue", "resolving context value %parsed", {
                    parsed: e
                });
                var t = n.fetcher(e);
                return h.pushActivity("resolvedContextValue", "resolved value %parsed to value %value", {
                    parsed: e,
                    value: t
                }), h.popActivity(2), t;
            }
            var r;
            if (n.bareContextRefs && h.isIoCReference(e)) return t(r = h.parseContextReference(e));
            if (n.ELstyle && "${}" !== n.ELstyle && (r = h.extractELWithContext(e, n))) return t(r);
            for (;"string" == typeof e; ) {
                var a = e.indexOf("${"), o = e.indexOf("}", a + 2);
                if (-1 === a || -1 === o) break;
                "{" === e.charAt(a + 2) ? o = (r = h.parseContextReference(e, a + 2, "}")).endpos : r = {
                    path: e.substring(a + 2, o)
                };
                var i = t(r), u = 0 === a && o === e.length - 1;
                if (null == i) return i;
                e = u ? i : e.substring(0, a) + i + e.substring(o + 1);
            }
            return e;
        }, h.fetchExpandChildren = function(n, r, a, o, i, u) {
            if (o.expander) {
                var e = h.expandExpander(n, o, u);
                if (h.isPrimitive(e) || !h.isPlainObject(e) || h.isArrayable(e) ^ h.isArrayable(n)) return e;
                d.extend(!0, n, e);
            }
            return h.each(o, function(e, t) {
                void 0 === e ? n[t] = void 0 : "expander" !== t && (a[r] = t, !0 !== h.getImmediate(u.exceptions, a, r) && u.strategy(n, t, r + 1, a, o, i));
            }), n;
        }, h.isUnexpandable = function(e) {
            return h.isPrimitive(e) || !h.isPlainObject(e);
        }, h.expandSource = function(e, t, n, r, a, o, i, u) {
            var s, l, c = h.derefMergePolicy(i);
            return "string" != typeof o || c.noexpand ? c.noexpand || h.isUnexpandable(o) ? s = o : o.expander ? s = h.expandExpander(a, o, e) : (s = h.freshContainer(o), 
            l = !0) : e.defaultEL && "{" !== o.charAt(0) ? s = o : (h.pushActivity("expandContextValue", "expanding context value %source held at path %path", {
                source: o,
                path: h.path.apply(null, r.slice(0, n))
            }), s = h.resolveContextValue(o, e), h.popActivity(1)), s !== h.NO_VALUE && a(s), 
            l && u(s, o, n, r, i), s;
        }, h.guardCircularExpansion = function(e, t) {
            t > h.strategyRecursionBailout && h.fail("Overflow/circularity in options expansion, current path is ", e, " at depth ", t, ' - please ensure options are not circularly connected, or protect from expansion using the "noexpand" policy or expander');
        }, h.makeExpandStrategy = function(s) {
            function l(e, t, n, r, a) {
                return h.fetchExpandChildren(e, n || 0, r || [], t, a, s);
            }
            function e(t, n, e, r, a, o) {
                if (h.guardCircularExpansion(r, e), t) {
                    if (t.hasOwnProperty(n)) return t[n];
                    void 0 === a && (a = c(s.source, r, e - 1, s.sourceStrategy), o = c(s.mergePolicy, r, e - 1, h.concreteTrundler));
                    var i = s.sourceStrategy(a, n, e, r), u = h.concreteTrundler(o, n);
                    return h.expandSource(s, t, e, r, function(e) {
                        t[n] = e;
                    }, i, u, l);
                }
            }
            return s.recurse = l, s.strategy = e;
        }, h.defaults("fluid.makeExpandOptions", {
            ELstyle: "${}",
            bareContextRefs: !0,
            target: h.inCreationMarker
        }), h.makeExpandOptions = function(e, t) {
            return (t = d.extend({}, h.rawDefaults("fluid.makeExpandOptions"), t)).defaultEL = "${}" === t.ELStyle && t.bareContextRefs, 
            t.expandSource = function(e) {
                return h.expandSource(t, null, 0, [], h.identity, e, t.mergePolicy, !1);
            }, h.isUnexpandable(e) ? (t.strategy = h.concreteTrundler, t.initter = h.identity, 
            t.target = "string" == typeof e ? (t.defer ? h.copy : h.identity)(t.expandSource(e)) : e, 
            t.immutableTarget = !0) : (t.source = e, t.target = h.freshContainer(e), t.sourceStrategy = t.sourceStrategy || h.concreteTrundler, 
            h.makeExpandStrategy(t), t.initter = function() {
                t.target = h.fetchExpandChildren(t.target, 0, [], t.source, t.mergePolicy, t);
            }), t;
        }, h.expand = function(e, t) {
            var n = h.makeExpandOptions(e, t);
            return n.initter(), n.target;
        }, h.preExpandRecurse = function(n, r, t, a, o) {
            function e(e) {
                n.expanders.push({
                    expander: e,
                    holder: t,
                    member: a
                }), delete t[a];
            }
            if (h.guardCircularExpansion(o, o.length), h.isIoCReference(r)) {
                var i = h.parseContextReference(r), u = h.model.parseEL(i.path);
                e({
                    typeFunc: h.expander.fetch,
                    context: i.context,
                    segs: u
                });
            } else h.isPlainObject(r) && (r.expander ? (r.expander.typeFunc = h.getGlobalValue(r.expander.type || "fluid.invokeFunc"), 
            e(r.expander)) : h.each(r, function(e, t) {
                o.push(t), h.preExpandRecurse(n, e, r, t, o), o.pop();
            }));
        }, h.preExpand = function(e) {
            var t = {
                expanders: [],
                source: h.isUnexpandable(e) ? e : h.copy(e)
            };
            return h.preExpandRecurse(t, t.source, t, "source", []), t;
        }, h.expandImmediate = function(e, t, n) {
            var r = h.makeStackResolverOptions(t, n, !0), a = h.preExpand(e);
            return h.expandImmediateImpl(a, r), a.source;
        }, h.expandImmediateImpl = function(e, t) {
            for (var n = e.expanders, r = 0; r < n.length; ++r) {
                var a = n[r];
                a.holder[a.member] = a.expander.typeFunc(null, a, t);
            }
        }, h.expandExpander = function(e, t, n) {
            var r = h.getGlobalValue(t.expander.type || "fluid.invokeFunc");
            return r || h.fail("Unknown expander with type " + t.expander.type), r(e, t, n);
        }, h.registerNamespace("fluid.expander"), h.expander.fetch = function(e, t, n) {
            var r = n.localRecord, a = t.expander.context, o = t.expander.segs, i = void 0 !== r[a], u = n.contextThat.lifecycleStatus, s = "treeConstructed" === u || "destroyed" === u, l = i ? r[a] : h.resolveContext(a, n.contextThat, s);
            if (l) {
                var c = l;
                if (i || "constructing" !== l.lifecycleStatus) for (var d = 0; d < o.length; ++d) c = c ? c[o[d]] : void 0; else c = h.getForComponent(l, o);
                return void 0 !== c || i || (c = h.getForComponent(l, o)), c;
            }
            0 < o.length && h.triggerMismatchedPathError(t.expander, n.contextThat);
        }, h.invokeFunc = function(e, t, n) {
            var r = t.expander, a = h.makeArray(r.args);
            r.args = a, a = n.recurse ? n.recurse([], a) : (r = h.expandImmediate(r, n.contextThat, n.localRecord)).args;
            var o = r.func || r.funcName, i = (n.expandSource ? n.expandSource(o) : o) || h.recordToApplicable(r, n.contextThat);
            return "string" == typeof i && (i = h.getGlobalValue(i)), i || h.fail("Error in expander record ", r, ": " + o + " could not be resolved to a function for component ", n.contextThat), 
            i.apply(null, a);
        }, h.noexpand = function(e, t) {
            return t.expander.value ? t.expander.value : t.expander.tree;
        };
    }(t, n = n || {}), function(n, y) {
        "use strict";
        y.model.makeEnvironmentStrategy = function(r) {
            return function(e, t, n) {
                return 0 === n && r[t] ? r[t] : void 0;
            };
        }, y.model.defaultCreatorStrategy = function(e, t) {
            if (void 0 === e[t]) return e[t] = {}, e[t];
        }, y.model.defaultFetchStrategy = function(e, t) {
            return e[t];
        }, y.model.funcResolverStrategy = function(e, t) {
            if (e.resolvePathSegment) return e.resolvePathSegment(t);
        }, y.model.traverseWithStrategy = function(e, t, n, r, a) {
            for (var o = r.strategies, i = t.length - a, u = n; u < i; ++u) {
                if (!e) return e;
                for (var s, l = 0; l < o.length && void 0 === (s = o[l](e, t[u], u + 1, t)); ++l) ;
                s === y.NO_VALUE && (s = void 0), e = s;
            }
            return e;
        }, y.model.getValueAndSegments = function(e, t, n, r) {
            return y.model.accessWithStrategy(e, t, y.NO_VALUE, n, r, !0);
        }, y.model.makeTrundler = function(n) {
            return function(e, t) {
                return y.model.getValueAndSegments(e.root, t, n, e.segs);
            };
        }, y.model.getWithStrategy = function(e, t, n, r) {
            return y.model.accessWithStrategy(e, t, y.NO_VALUE, n, r);
        }, y.model.setWithStrategy = function(e, t, n, r, a) {
            y.model.accessWithStrategy(e, t, n, r, a);
        }, y.model.accessWithStrategy = function(e, t, n, r, a, o) {
            if (y.isPrimitive(t) || y.isArrayable(t)) return y.model.accessImpl(e, t, n, r, a, o, y.model.traverseWithStrategy);
            var i = t.type || "default", u = r.resolvers[i];
            u || y.fail("Unable to find resolver of type " + i);
            var s = y.model.makeTrundler(r), l = {
                root: e,
                segs: a
            };
            return l = u(l, t, s), t.path && l && (l = s(l, t.path)), o ? l : l ? l.root : void 0;
        }, y.registerNamespace("fluid.pathUtil"), y.pathUtil.getPathSegmentImpl = function(e, t, n) {
            var r = null;
            e && (r = "");
            for (var a = !1, o = t.length; n < o; ++n) {
                var i = t.charAt(n);
                if (a) a = !1, null !== r && (r += i); else {
                    if ("." === i) break;
                    "\\" === i ? a = !0 : null !== r && (r += i);
                }
            }
            return null !== r && (e[0] = r), n;
        };
        var o = [];
        y.pathUtil.parseEL = function(e) {
            for (var t = [], n = 0, r = e.length; n < r; ) {
                var a = y.pathUtil.getPathSegmentImpl(o, e, n);
                t.push(o[0]), n = a + 1;
            }
            return t;
        }, y.pathUtil.composeSegment = function(e, t) {
            t = t.toString();
            for (var n = 0; n < t.length; ++n) {
                var r = t.charAt(n);
                "." !== r && "\\" !== r && "}" !== r || (e += "\\"), e += r;
            }
            return e;
        }, y.pathUtil.escapeSegment = function(e) {
            return y.pathUtil.composeSegment("", e);
        }, y.pathUtil.composePath = function(e, t) {
            return 0 !== e.length && (e += "."), y.pathUtil.composeSegment(e, t);
        }, y.pathUtil.composeSegments = function() {
            for (var e = "", t = 0; t < arguments.length; ++t) e = y.pathUtil.composePath(e, arguments[t]);
            return e;
        }, y.pathUtil.matchSegments = function(e, t, n, r) {
            if (r - n !== e.length) return !1;
            for (var a = n; a < r; ++a) if (t[a] !== e[a - n]) return !1;
            return !0;
        }, y.model.unescapedParser = {
            parse: y.model.parseEL,
            compose: y.model.composeSegments
        }, y.model.defaultGetConfig = {
            parser: y.model.unescapedParser,
            strategies: [ y.model.funcResolverStrategy, y.model.defaultFetchStrategy ]
        }, y.model.defaultSetConfig = {
            parser: y.model.unescapedParser,
            strategies: [ y.model.funcResolverStrategy, y.model.defaultFetchStrategy, y.model.defaultCreatorStrategy ]
        }, y.model.escapedParser = {
            parse: y.pathUtil.parseEL,
            compose: y.pathUtil.composeSegments
        }, y.model.escapedGetConfig = {
            parser: y.model.escapedParser,
            strategies: [ y.model.defaultFetchStrategy ]
        }, y.model.escapedSetConfig = {
            parser: y.model.escapedParser,
            strategies: [ y.model.defaultFetchStrategy, y.model.defaultCreatorStrategy ]
        }, y.stronglyConnected = function(e, t) {
            var n = {
                stack: [],
                accessor: t,
                components: [],
                index: 0
            };
            return e.forEach(function(e) {
                void 0 === e.tarjanIndex && y.stronglyConnectedOne(e, n);
            }), n.components;
        }, y.stronglyConnectedOne = function(t, n) {
            if (t.tarjanIndex = n.index, t.lowIndex = n.index, ++n.index, n.stack.push(t), t.onStack = !0, 
            n.accessor(t).forEach(function(e) {
                void 0 === e.tarjanIndex ? (y.stronglyConnectedOne(e, n), t.lowIndex = Math.min(t.lowIndex, e.lowIndex)) : e.onStack && (t.lowIndex = Math.min(t.lowIndex, e.tarjanIndex));
            }), t.lowIndex === t.tarjanIndex) {
                for (var e, r = []; (e = n.stack.pop()).onStack = !1, r.push(e), e !== t; ) ;
                n.components.push(r);
            }
        }, y.initRelayModel = function(e) {
            return y.deenlistModelComponent(e), e.model;
        }, y.isModelComplete = function(e) {
            return "model" in e && e.model !== y.inEvaluationMarker;
        }, y.enlistModelComponent = function(e) {
            var t = y.getInstantiator(e), n = t.modelTransactions.init[e.id];
            return n || (n = {
                that: e,
                applier: y.getForComponent(e, "applier"),
                complete: y.isModelComplete(e)
            }, t.modelTransactions.init[e.id] = n), n;
        }, y.clearTransactions = function() {
            var e = y.globalInstantiator;
            y.clear(e.modelTransactions), e.modelTransactions.init = {};
        }, y.failureEvent.addListener(y.clearTransactions, "clearTransactions", "before:fail"), 
        y.clearLinkCounts = function(n, r) {
            y.each(n, function(e, t) {
                "number" == typeof e ? n[t] = 0 : r && e.options && "number" == typeof e.relayCount && (e.relayCount = 0);
            });
        }, y.computeInitialOutArcs = function(o, i) {
            return y.transform(i, function(e, n) {
                var r = {}, t = e.that.applier.listeners.sortedListeners;
                y.each(t, function(e) {
                    if (e.isRelay && !y.isExcludedChangeSource(o[n], e.cond)) {
                        var t = e.targetId;
                        t !== n && (r[t] = !0);
                    }
                });
                var a = Object.keys(r).map(function(e) {
                    return i[e];
                });
                return y.remove_if(a, function(e) {
                    return void 0 === e;
                }), a;
            });
        }, y.sortCompleteLast = function(e, t) {
            return (e.completeOnInit ? 1 : 0) - (t.completeOnInit ? 1 : 0);
        }, y.operateInitialTransaction = function(e, t) {
            var n, r = y.allocateGuid(), a = y.getModelTransactionRec(e, r), o = y.transform(t, function(e) {
                return n = e.that.applier.initiate(null, "init", r), a[e.that.applier.applierId] = {
                    transaction: n
                }, n;
            }), i = y.computeInitialOutArcs(o, t), u = y.values(t), s = y.stronglyConnected(u, function(e) {
                return i[e.that.id];
            }), l = 0;
            s.forEach(function(e) {
                e.forEach(function(e) {
                    e.initPriority = e.completeOnInit ? Math.Infinity : l++;
                });
            }), u.sort(function(e, t) {
                return e.initPriority - t.initPriority;
            }), u.forEach(function(e) {
                var t = e.that, n = o[t.id];
                e.completeOnInit ? y.initModelEvent(t, t.applier, n, t.applier.listeners.sortedListeners) : y.each(e.initModels, function(e) {
                    n.fireChangeRequest({
                        type: "ADD",
                        segs: [],
                        value: e
                    }), y.clearLinkCounts(a, !0);
                });
                var r = y.shadowForComponent(t);
                r && (r.modelComplete = !0);
            }), n.commit();
        }, y.deenlistModelComponent = function(e) {
            var t = y.getInstantiator(e), n = t.modelTransactions.init;
            if (n[e.id] && (e.model = void 0, n[e.id].complete = !0, !y.find_if(n, function(e) {
                return !0 !== e.complete;
            }))) {
                try {
                    y.operateInitialTransaction(e, n);
                } catch (e) {
                    throw y.clearTransactions(), e;
                }
                t.modelTransactions.init = {};
            }
        }, y.parseModelReference = function(e, t) {
            var n = y.parseContextReference(t);
            return n.segs = e.applier.parseEL(n.path), n;
        }, y.parseValidModelReference = function(e, t, n, r) {
            function a() {
                var e = [ "Error in " + t + ": ", n ].concat(y.makeArray(arguments));
                y.fail.apply(null, e);
            }
            function o(e) {
                a(" must be a reference to a component with a ChangeApplier (descended from fluid.modelComponent), instead got ", e);
            }
            var i, u, s;
            if ("string" == typeof n) if (y.isIoCReference(n)) {
                var l = (i = y.parseModelReference(e, n)).segs.indexOf("model");
                -1 === l ? r ? i.nonModel = !0 : a(' must be a reference into a component model via a path including the segment "model"') : (i.modelSegs = i.segs.slice(l + 1), 
                i.contextSegs = i.segs.slice(0, l), delete i.path);
            } else i = {
                path: n,
                modelSegs: e.applier.parseEL(n)
            }; else y.isArrayable(n.segs) || a(' must contain an entry "segs" holding path segments referring a model path within a component'), 
            i = {
                context: n.context,
                modelSegs: y.expandOptions(n.segs, e)
            };
            return s = i.context ? ((u = y.resolveContext(i.context, e)) || a(" context must be a reference to an existing component"), 
            i.contextSegs ? y.getForComponent(u, i.contextSegs) : u) : e, i.nonModel || (y.isComponent(s) || o(s), 
            s.applier || y.getForComponent(s, [ "applier" ]), s.applier || o(s)), i.that = s, 
            i.applier = s && s.applier, i.path || (i.path = s && s.applier.composeSegments.apply(null, i.modelSegs)), 
            i;
        }, y.getModelTransactionRec = function(e, t) {
            var n = y.getInstantiator(e);
            if (t || y.fail("Cannot get transaction record without transaction id"), !n) return null;
            var r = n.modelTransactions[t];
            return r || (r = n.modelTransactions[t] = {
                relays: [],
                sources: {},
                externalChanges: {}
            }), r;
        }, y.recordChangeListener = function(e, t, n, r) {
            var a = y.shadowForComponent(e);
            y.recordListener(t.modelChanged, n, a, r);
        }, y.registerRelayTransaction = function(e, t, n, r, a) {
            var o = t.initiate("relay", null, n), i = e[t.applierId] = {
                transaction: o,
                relayCount: 0,
                namespace: a.namespace,
                priority: a.priority,
                options: r
            };
            return i.priority = y.parsePriority(i.priority, e.relays.length, !1, "model relay"), 
            e.relays.push(i), i;
        }, y.relayRecursionBailout = 100, y.registerDirectChangeRelay = function(l, c, e, d, f, p, m, g) {
            var h = m.targetApplier || l.applier, t = m.sourceApplier || e.applier, v = h.applierId;
            c = y.makeArray(c), d = y.makeArray(d);
            function n(e, t, n, r, a, o) {
                var i = a.id, u = y.getModelTransactionRec(l, i);
                o && a && !u[o.applierId] && (u[o.applierId] = {
                    transaction: a
                });
                var s = u[v];
                u[f] = u[f] || 0, ++u[f], u[f] > y.relayRecursionBailout && y.fail("Error in model relay specification at component ", l, " - operated more than " + y.relayRecursionBailout + " relays without model value settling - current model contents are ", a.newHolder.model), 
                s || (s = y.registerRelayTransaction(u, h, i, m, g)), p && !m.targetApplier ? p(s.transaction, m.sourceApplier ? void 0 : e, d, c, r) : (r && "DELETE" === r.type && s.transaction.fireChangeRequest({
                    type: "DELETE",
                    segs: c
                }), void 0 !== e && s.transaction.fireChangeRequest({
                    type: "ADD",
                    segs: c,
                    value: e
                }));
            }
            var r = t.modelChanged.addListener({
                isRelay: !0,
                cond: p && p.cond,
                targetId: l.id,
                targetApplierId: h.id,
                segs: d,
                transactional: m.transactional
            }, n);
            y.passLogLevel(y.logLevel.TRACE) && y.log(y.logLevel.TRACE, "Adding relay listener with listenerId " + r.listenerId + " to source applier with id " + t.applierId + " from target applier with id " + v + " for target component with id " + l.id), 
            e && (y.recordChangeListener(e, t, n, r.listenerId), l !== e && y.recordChangeListener(l, t, n, r.listenerId));
        }, y.connectModelRelay = function(e, t, n, r, a) {
            var o = y.allocateGuid();
            function i(e) {
                var t = y.enlistModelComponent(e);
                t.complete && y.shadowForComponent(e).modelComplete && (t.completeOnInit = !0);
            }
            i(n), i(e);
            var u = y.filterKeys(a, [ "namespace", "priority" ]);
            a.update ? a.targetApplier ? y.registerDirectChangeRelay(e, t, n, r, o, null, {
                transactional: !1,
                targetApplier: a.targetApplier,
                update: a.update
            }, u) : y.registerDirectChangeRelay(n, r, e, [], o + "-transform", a.forwardAdapter, {
                transactional: !0,
                sourceApplier: a.forwardApplier
            }, u) : (y.registerDirectChangeRelay(n, r, e, t, o, a.forwardAdapter, {
                transactional: !1
            }, u), y.registerDirectChangeRelay(e, t, n, r, o, a.backwardAdapter, {
                transactional: !1
            }, u));
        }, y.parseSourceExclusionSpec = function(e, t) {
            return e.excludeSource = y.arrayToHash(y.makeArray(t.excludeSource || (t.includeSource ? "*" : void 0))), 
            e.includeSource = y.arrayToHash(y.makeArray(t.includeSource)), e;
        }, y.isExcludedChangeSource = function(e, t) {
            if (!t || !t.excludeSource) return !1;
            var n = t.excludeSource["*"];
            for (var r in e.fullSources) t.excludeSource[r] && (n = !0), t.includeSource[r] && (n = !1);
            return n;
        }, y.model.guardedAdapter = function(e, t, n, r) {
            y.isExcludedChangeSource(e, t) || n === y.model.transform.uninvertibleTransform || n.apply(null, r);
        }, y.transformToAdapter = function(e, o) {
            var i = {};
            return i[o] = e, function(e, t, n, r, a) {
                a && "DELETE" === a.type && e.fireChangeRequest({
                    type: "DELETE",
                    path: o
                }), y.model.transformWithRules(t, i, {
                    finalApplier: e
                });
            };
        }, y.makeTransformPackage = function(e, n, r, a, o, t, i, u) {
            var s = {
                forwardHolder: {
                    model: n
                },
                backwardHolder: {
                    model: null
                },
                generateAdapters: function(e) {
                    if (s.forwardAdapterImpl = y.transformToAdapter(e ? e.newHolder.model : s.forwardHolder.model, a), 
                    null !== r) {
                        var t = y.model.transform.invertConfiguration(n);
                        t !== y.model.transform.uninvertibleTransform ? (s.backwardHolder.model = t, s.backwardAdapterImpl = y.transformToAdapter(s.backwardHolder.model, r)) : s.backwardAdapterImpl = t;
                    }
                },
                forwardAdapter: function(e, t) {
                    void 0 === t && s.generateAdapters(), y.model.guardedAdapter(e, o, s.forwardAdapterImpl, arguments);
                }
            };
            s.forwardAdapter.cond = o, s.runTransform = function(e) {
                e.commit(), e.reset();
            }, s.forwardApplier = y.makeHolderChangeApplier(s.forwardHolder), s.forwardApplier.isRelayApplier = !0, 
            s.invalidator = y.makeEventFirer({
                name: "Invalidator for model relay with applier " + s.forwardApplier.applierId
            }), null !== r && (s.backwardApplier = y.makeHolderChangeApplier(s.backwardHolder), 
            s.backwardAdapter = function(e) {
                y.model.guardedAdapter(e, t, s.backwardAdapterImpl, arguments);
            }, s.backwardAdapter.cond = t), s.update = s.invalidator.fire;
            var l = {
                targetApplier: s.forwardApplier,
                update: s.update,
                namespace: i,
                priority: u,
                refCount: 0
            };
            return s.forwardHolder.model = y.parseImplicitRelay(e, n, [], l), s.refCount = l.refCount, 
            s.namespace = i, s.priority = u, s.generateAdapters(), s.invalidator.addListener(s.generateAdapters), 
            s.invalidator.addListener(s.runTransform), s;
        }, y.singleTransformToFull = function(e) {
            return {
                "": {
                    transform: n.extend(!0, {
                        inputPath: ""
                    }, e)
                }
            };
        }, y.model.relayConditions = {
            initOnly: {
                includeSource: "init"
            },
            liveOnly: {
                excludeSource: "init"
            },
            never: {
                includeSource: []
            },
            always: {}
        }, y.model.parseRelayCondition = function(e) {
            var t;
            return "initOnly" === e ? y.log(y.logLevel.WARN, 'The relay condition "initOnly" is deprecated: Please use the form \'includeSource: "init"\' instead') : "liveOnly" === e && y.log(y.logLevel.WARN, 'The relay condition "liveOnly" is deprecated: Please use the form \'excludeSource: "init"\' instead'), 
            e ? "string" == typeof e ? (t = y.model.relayConditions[e]) || y.fail('Unrecognised model relay condition string "' + e + '": the supported values are "never" or a record with members "includeSource" and/or "excludeSource"') : t = e : t = {}, 
            y.parseSourceExclusionSpec({}, t);
        }, y.parseModelRelay = function(e, t, n) {
            var r = void 0 !== t.source ? y.parseValidModelReference(e, 'modelRelay record member "source"', t.source) : {
                path: null,
                modelSegs: null
            }, a = y.parseValidModelReference(e, 'modelRelay record member "target"', t.target), o = t.namespace || n, i = t.singleTransform ? y.singleTransformToFull(t.singleTransform) : t.transform;
            i || y.fail('Cannot parse modelRelay record without element "singleTransform" or "transform":', t);
            var u = y.model.parseRelayCondition(t.forward), s = y.model.parseRelayCondition(t.backward), l = y.makeTransformPackage(e, i, r.path, a.path, u, s, o, t.priority);
            0 === l.refCount ? y.connectModelRelay(r.that || e, r.modelSegs, a.that, a.modelSegs, y.filterKeys(l, [ "forwardAdapter", "backwardAdapter", "namespace", "priority" ])) : (r.modelSegs && y.fail('Error in model relay definition: If a relay transform has a model dependency, you can not specify a "source" entry - please instead enter this as "input" in the transform specification. Definition was ', t, " for component ", e), 
            y.connectModelRelay(e, null, a.that, a.modelSegs, l));
        }, y.parseImplicitRelay = function(r, e, a, o) {
            var i;
            if (y.isIoCReference(e)) {
                var t = y.parseValidModelReference(r, "model reference from model (implicit relay)", e, !0);
                t.nonModel ? i = y.getForComponent(t.that, t.segs) : (++o.refCount, y.connectModelRelay(r, a, t.that, t.modelSegs, o));
            } else y.isPrimitive(e) || !y.isPlainObject(e) ? i = e : e.expander && y.isPlainObject(e.expander) ? i = y.expandOptions(e, r) : (i = y.freshContainer(e), 
            y.each(e, function(e, t) {
                a.push(t);
                var n = y.parseImplicitRelay(r, e, a, o);
                void 0 !== n && (i[t] = n), a.pop();
            }));
            return i;
        }, y.model.notifyExternal = function(e) {
            var t = e ? y.values(e.externalChanges) : [];
            y.sortByPriority(t);
            for (var n = 0; n < t.length; ++n) {
                var r = t[n];
                r.args[5].destroyed || r.listener.apply(null, r.args);
            }
            y.clearLinkCounts(e, !0);
        }, y.model.commitRelays = function(e, t) {
            var n = e.modelTransactions[t];
            y.each(n, function(e) {
                e.transaction && (e.transaction.commit("relay"), e.transaction.reset());
            });
        }, y.model.updateRelays = function(e, t) {
            var n = e.modelTransactions[t], r = 0;
            return y.sortByPriority(n.relays), y.each(n.relays, function(e) {
                0 < e.transaction.changeRecord.changes && e.relayCount < 2 && e.options.update && (e.relayCount++, 
                y.clearLinkCounts(n), e.options.update(e.transaction, n), ++r);
            }), r;
        }, y.establishModelRelay = function(r, e, t, n, a) {
            var o = y.shadowForComponent(r);
            o.modelRelayEstablished ? y.fail("FLUID-5887 failure: Model relay initialised twice on component", r) : o.modelRelayEstablished = !0, 
            y.mergeModelListeners(r, t);
            var i = y.enlistModelComponent(r);
            y.each(n, function(e, t) {
                for (var n = 0; n < e.length; ++n) y.parseModelRelay(r, e[n], t);
            });
            var u = y.transform(e, function(e) {
                return y.parseImplicitRelay(r, e, [], {
                    refCount: 0,
                    priority: "first"
                });
            });
            i.initModels = u;
            var s = y.getInstantiator(r);
            return a.preCommit.addListener(function(e) {
                for (;0 < y.model.updateRelays(s, e.id); ) ;
            }), a.preCommit.addListener(function(e, t, n) {
                "relay" !== n && y.model.commitRelays(s, e.id);
            }), a.postCommit.addListener(function(e, t, n) {
                "relay" !== n && (y.model.notifyExternal(s.modelTransactions[e.id]), delete s.modelTransactions[e.id]);
            }), null;
        }, y.defaults("fluid.modelComponent", {
            gradeNames: [ "fluid.component" ],
            changeApplierOptions: {
                relayStyle: !0,
                cullUnchanged: !0
            },
            members: {
                model: "@expand:fluid.initRelayModel({that}, {that}.modelRelay)",
                applier: "@expand:fluid.makeHolderChangeApplier({that}, {that}.options.changeApplierOptions)",
                modelRelay: "@expand:fluid.establishModelRelay({that}, {that}.options.model, {that}.options.modelListeners, {that}.options.modelRelay, {that}.applier)"
            },
            mergePolicy: {
                model: {
                    noexpand: !0,
                    func: y.arrayConcatPolicy
                },
                modelListeners: y.makeMergeListenersPolicy(y.arrayConcatPolicy),
                modelRelay: y.makeMergeListenersPolicy(y.arrayConcatPolicy, !0)
            }
        }), y.modelChangedToChange = function(e) {
            return {
                value: e[0],
                oldValue: e[1],
                path: e[2],
                transaction: e[4]
            };
        }, y.event.invokeListener = function(e, t, n, r) {
            return "string" == typeof e && (e = y.event.resolveListener(e)), e.apply(null, t, n, r);
        }, y.resolveModelListener = function(a, o) {
            function e() {
                if (!y.isDestroyed(a)) {
                    var e = y.modelChangedToChange(arguments), t = arguments, n = {
                        change: e,
                        arguments: t
                    }, r = {
                        source: Object.keys(e.transaction.sources)
                    };
                    o.args && (t = y.expandOptions(o.args, a, {}, n)), y.event.invokeListener(o.listener, y.makeArray(t), n, r);
                }
            }
            return y.event.impersonateListener(o.listener, e), e;
        }, y.registerModelListeners = function(r, a, e, o) {
            var i = y.resolveModelListener(r, a);
            y.each(a.byTarget, function(e) {
                var t = e[0], n = {
                    listener: i,
                    listenerId: y.allocateGuid(),
                    segsArray: y.getMembers(e, "modelSegs"),
                    pathArray: y.getMembers(e, "path"),
                    includeSource: a.includeSource,
                    excludeSource: a.excludeSource,
                    priority: y.expandOptions(a.priority, r),
                    transactional: !0
                };
                n = t.applier.modelChanged.addListener(n, i, o, a.softNamespace), y.recordChangeListener(r, t.applier, i, n.listenerId), 
                r === t.that || y.isModelComplete(r) || y.getForComponent(r, [ "events", "onCreate" ]).addListener(function() {
                    if (y.isModelComplete(t.that)) {
                        var e = t.applier.initiate(null, "init");
                        y.initModelEvent(r, t.applier, e, [ n ]), e.commit();
                    }
                });
            });
        }, y.mergeModelListeners = function(a, e) {
            y.each(e, function(e, r) {
                "string" == typeof e && (e = {
                    funcName: e
                });
                var t = y.event.resolveListenerRecord(e, a, "modelListeners", null, !1).records;
                y.each(t, function(n) {
                    n.byTarget = {};
                    var e = y.makeArray(void 0 === n.path ? r : n.path);
                    y.each(e, function(e) {
                        var t = y.parseValidModelReference(a, "modelListeners entry", e);
                        y.pushArray(n.byTarget, t.that.id, t);
                    });
                    var t = (n.namespace && !n.softNamespace ? n.namespace : null) || (void 0 !== n.path ? r : null);
                    y.registerModelListeners(a, n, e, t);
                });
            });
        }, y.fireChanges = function(e, t) {
            for (var n = 0; n < t.length; ++n) e.fireChangeRequest(t[n]);
        }, y.model.isChangedPath = function(e, t) {
            for (var n = 0; n <= t.length; ++n) {
                if ("string" == typeof e) return !0;
                n < t.length && e && (e = e[t[n]]);
            }
            return !1;
        }, y.model.setChangedPath = function(t, n, r) {
            function e(e) {
                n.unshift(e), y.model.setSimple(t, n, r), n.shift();
            }
            y.model.isChangedPath(t.changeMap, n) || (++t.changes, e("changeMap")), y.model.isChangedPath(t.deltaMap, n) || (++t.deltas, 
            e("deltaMap"));
        }, y.model.fetchChangeChildren = function(n, r, a, e, o) {
            y.each(e, function(e, t) {
                a[r] = t, y.model.applyChangeStrategy(n, t, r, a, e, o), a.length = r;
            });
        }, y.model.isSameValue = function(e, t) {
            return "number" != typeof e || "number" != typeof t ? e === t : e === t || e != e && t != t || Math.abs((e - t) / t) < 1e-12;
        }, y.model.applyChangeStrategy = function(e, t, n, r, a, o) {
            var i = e[t], u = y.typeCode(a), s = y.typeCode(i), l = y.NO_VALUE;
            "primitive" === u ? y.model.isSameValue(i, a) || (l = a, ++o.unchanged) : (s !== u || "array" === u && a.length !== i.length) && (l = y.freshContainer(a)), 
            l !== y.NO_VALUE && (e[t] = l, o.changeMap && y.model.setChangedPath(o, r, o.inverse ? "DELETE" : "ADD")), 
            "primitive" !== u && y.model.fetchChangeChildren(e[t], n + 1, r, a, o);
        }, y.model.stepTargetAccess = function(e, t, n, r, a, o) {
            for (var i = r; i < a; ++i) {
                if (e) e[n[i]] !== (e = y.model.traverseWithStrategy(e, n, i, o["ADD" === t ? "resolverSetConfig" : "resolverGetConfig"], n.length - i - 1)) && o.changeMap && y.model.setChangedPath(o, n.slice(0, i + 1), "ADD");
            }
            return {
                root: e,
                last: n[a]
            };
        }, y.model.defaultAccessorConfig = function(e) {
            return (e = e || {}).resolverSetConfig = e.resolverSetConfig || y.model.escapedSetConfig, 
            e.resolverGetConfig = e.resolverGetConfig || y.model.escapedGetConfig, e;
        }, y.model.applyHolderChangeRequest = function(e, t, n) {
            (n = y.model.defaultAccessorConfig(n)).deltaMap = n.changeMap ? {} : null, n.deltas = 0;
            var r, a = t.segs.length, o = 0 === a;
            if (r = o ? {
                root: e,
                last: "model"
            } : (e.model || (e.model = {}, y.model.setChangedPath(n, [], n.inverse ? "DELETE" : "ADD")), 
            y.model.stepTargetAccess(e.model, t.type, t.segs, 0, a - 1, n)), "ADD" === t.type) {
                var i = t.value, u = y.makeArray(t.segs);
                y.model.applyChangeStrategy(r.root, r.last, a - 1, u, i, n, o);
            } else "DELETE" === t.type ? r.root && void 0 !== r.root[r.last] && (delete r.root[r.last], 
            n.changeMap && y.model.setChangedPath(n, t.segs, "DELETE")) : y.fail("Unrecognised change type of " + t.type);
            return n.deltas ? n.deltaMap : null;
        }, y.model.diff = function(e, t, n) {
            n = n || {
                changes: 0,
                unchanged: 0,
                changeMap: {}
            };
            var r, a = y.typeCode(e), o = y.typeCode(t);
            if ("primitive" === a && "primitive" === o) r = y.model.isSameValue(e, t); else if ("primitive" === a ^ "primitive" === o) r = !1; else {
                var i = {
                    model: y.copy(e)
                };
                y.model.applyHolderChangeRequest(i, {
                    value: t,
                    segs: [],
                    type: "ADD"
                }, n);
                var u = {
                    model: y.copy(t)
                };
                n.inverse = !0, y.model.applyHolderChangeRequest(u, {
                    value: e,
                    segs: [],
                    type: "ADD"
                }, n), r = 0 === n.changes;
            }
            return !1 === r && 0 === n.changes ? (n.changes = 1, n.changeMap = void 0 === t ? "DELETE" : "ADD") : !0 === r && 0 === n.unchanged && (n.unchanged = 1), 
            r;
        }, y.outputMatches = function(n, r, e) {
            y.each(e, function(e, t) {
                n.push(r.concat(t));
            });
        }, y.matchChanges = function(e, t, n, r) {
            for (var a = n.model, o = r.model, i = e, u = [ "model" ], s = !1, l = [], c = 0; c < t.length; ++c) {
                var d = t[c];
                "*" === d ? c === t.length - 1 ? s = !0 : y.fail("Wildcard specification in modelChanged listener is only supported for the final path segment: " + t.join(".")) : (u.push(d), 
                i = y.isPrimitive(i) ? i : i[d], a = a ? a[d] : void 0, o = o ? o[d] : void 0);
            }
            return i && (s ? "DELETE" === i ? y.outputMatches(l, u, o) : "ADD" === i ? y.outputMatches(l, u, a) : y.outputMatches(l, u, i) : l.push(u)), 
            l;
        }, y.storeExternalChange = function(e, t, n, r, a) {
            var o = t.composeSegments.apply(null, n), i = [ t.holder.id, r.listenerId, r.wildcard ? o : "" ].join("|");
            e.externalChanges[i] = {
                listener: r.listener,
                namespace: r.namespace,
                priority: r.priority,
                args: a
            };
        }, y.notifyModelChanges = function(e, t, n, r, a, o, i, u) {
            if (e) for (var s = o && y.getModelTransactionRec(u, o.id), l = 0; l < e.length; ++l) for (var c = e[l], d = 1 < c.segsArray.length, f = 0; f < c.segsArray.length; ++f) for (var p = y.matchChanges(t, c.segsArray[f], n, r), m = 0; m < p.length; ++m) {
                if (i.destroyed) return;
                var g = p[m];
                c.listener = y.event.resolveListener(c.listener);
                var h = [ d ? n.model : y.model.getSimple(n, g), d ? r.model : y.model.getSimple(r, g), d ? [] : g.slice(1), a, o, i ];
                if (!c.isRelay) {
                    if (y.model.diff(h[0], h[1])) continue;
                    if (y.isExcludedChangeSource(o, c)) continue;
                }
                s && !c.isRelay && c.transactional ? y.storeExternalChange(s, i, g, c, h) : c.listener.apply(null, h);
            }
        }, y.bindELMethods = function(t) {
            t.parseEL = function(e) {
                return y.model.pathToSegments(e, t.options.resolverSetConfig);
            }, t.composeSegments = function() {
                return t.options.resolverSetConfig.parser.compose.apply(null, arguments);
            };
        }, y.initModelEvent = function(e, t, n, r) {
            y.notifyModelChanges(r, "ADD", n.oldHolder, y.emptyHolder, null, n, t, e);
        }, y.emptyHolder = y.freezeRecursive({
            model: void 0
        }), y.preFireChangeRequest = function(e, t) {
            t.type || (t.type = "ADD"), t.segs = t.segs || e.parseEL(t.path);
        }, y.bindRequestChange = function(o) {
            o.change = function(e, t, n, r) {
                var a = {
                    path: e,
                    value: t,
                    type: n,
                    source: r
                };
                o.fireChangeRequest(a);
            };
        }, y.isObjectSimple = function(e) {
            return "[object Object]" === Object.prototype.toString.call(e);
        }, y.mergeChangeSources = function(t, e) {
            y.isObjectSimple(e) ? y.extend(t, e) : y.each(y.makeArray(e), function(e) {
                t[e] = !0;
            });
        }, y.ChangeApplier = function() {}, y.makeHolderChangeApplier = function(i, u) {
            u = y.model.defaultAccessorConfig(u);
            var e = y.allocateGuid(), s = new y.ChangeApplier(), t = y.isComponent(i) ? "ChangeApplier for component " + y.dumpThat(i) : "ChangeApplier with id " + e;
            return n.extend(s, {
                applierId: e,
                holder: i,
                listeners: y.makeEventFirer({
                    name: "Internal change listeners for " + t
                }),
                transListeners: y.makeEventFirer({
                    name: "External change listeners for " + t
                }),
                options: u,
                modelChanged: {},
                preCommit: y.makeEventFirer({
                    name: "preCommit event for " + t
                }),
                postCommit: y.makeEventFirer({
                    name: "postCommit event for " + t
                })
            }), s.destroy = function() {
                s.preCommit.destroy(), s.postCommit.destroy(), s.destroyed = !0;
            }, s.modelChanged.addListener = function(e, t, n, r) {
                return (e = "string" == typeof e ? {
                    path: e
                } : y.copy(e)).listenerId = e.listenerId || y.allocateGuid(), e.namespace = n, e.softNamespace = r, 
                "string" == typeof t && (t = {
                    globalName: t
                }), e.listener = t, !1 !== e.transactional && (e.transactional = !0), e.segsArray || (void 0 !== e.path && (e.segs = e.segs || s.parseEL(e.path)), 
                e.segsArray || (e.segsArray = [ e.segs ])), e.isRelay || (y.parseSourceExclusionSpec(e, e), 
                e.wildcard = y.accumulate(y.transform(e.segsArray, function(e) {
                    return y.contains(e, "*");
                }), y.add, 0), e.wildcard && 1 < e.segsArray.length && y.fail("Error in model listener specification ", e, " - you may not supply a wildcard pattern as one of a set of multiple paths to be matched")), 
                s[e.transactional ? "transListeners" : "listeners"].addListener(e), e;
            }, s.modelChanged.removeListener = function(e) {
                s.listeners.removeListener(e), s.transListeners.removeListener(e);
            }, s.fireChangeRequest = function(e) {
                var t = s.initiate("local", e.source);
                t.fireChangeRequest(e), t.commit();
            }, s.initiate = function(e, t, n) {
                var r = "relay" === (e = "init" === t ? null : e || "local"), a = {
                    instanceId: y.allocateGuid(),
                    id: n || y.allocateGuid(),
                    changeRecord: {
                        resolverSetConfig: u.resolverSetConfig,
                        resolverGetConfig: u.resolverGetConfig
                    },
                    reset: function() {
                        a.oldHolder = i, a.newHolder = {
                            model: y.copy(i.model)
                        }, a.changeRecord.changes = 0, a.changeRecord.unchanged = 0, a.changeRecord.changeMap = {};
                    },
                    commit: function(e) {
                        if (s.preCommit.fire(a, s, e), 0 < a.changeRecord.changes) {
                            var t = {
                                model: i.model
                            };
                            i.model = a.newHolder.model, y.notifyModelChanges(s.transListeners.sortedListeners, a.changeRecord.changeMap, i, t, null, a, s, i);
                        }
                        r || s.postCommit.fire(a, s, e);
                    },
                    fireChangeRequest: function(e) {
                        y.preFireChangeRequest(s, e), e.transactionId = a.id;
                        var t = y.model.applyHolderChangeRequest(a.newHolder, e, a.changeRecord);
                        y.notifyModelChanges(s.listeners.sortedListeners, t, a.newHolder, i, e, a, s, i);
                    },
                    hasChangeSource: function(e) {
                        return a.fullSources[e];
                    }
                }, o = y.getModelTransactionRec(i, a.id);
                return o && (y.mergeChangeSources(o.sources, t), a.sources = o.sources, a.fullSources = Object.create(o.sources), 
                a.fullSources[e] = !0), a.reset(), y.bindRequestChange(a), a;
            }, y.bindRequestChange(s), y.bindELMethods(s), s;
        }, y.modelPairToChanges = function(e, t, n) {
            n = n || "";
            var r = {
                changes: 0,
                unchanged: 0,
                changeMap: {}
            };
            y.model.diff(t, e, r);
            var a = [];
            return y.modelPairToChangesImpl(e, y.pathUtil.parseEL(n), r.changeMap, [], a), a;
        }, y.modelPairToChangesImpl = function(r, a, e, o, i) {
            "ADD" === e ? i.push({
                path: a,
                value: r,
                type: "ADD"
            }) : "DELETE" === e ? i.push({
                path: a,
                value: null,
                type: "DELETE"
            }) : y.isPlainObject(e, !0) && y.each(e, function(e, t) {
                var n = o.concat([ t ]);
                "ADD" === e ? i.push({
                    path: a.concat(n),
                    value: y.get(r, n),
                    type: "ADD"
                }) : "DELETE" === e ? i.push({
                    path: a.concat(n),
                    value: null,
                    type: "DELETE"
                }) : y.isPlainObject(e, !0) && y.modelPairToChangesImpl(r, a, e, n, i);
            });
        };
    }(t, n = n || {}), function(s, c) {
        "use strict";
        c.registerNamespace("fluid.model.transform"), c.defaults("fluid.transformFunction", {
            gradeNames: "fluid.function"
        }), c.defaults("fluid.standardInputTransformFunction", {
            gradeNames: "fluid.transformFunction"
        }), c.defaults("fluid.standardOutputTransformFunction", {
            gradeNames: "fluid.transformFunction"
        }), c.defaults("fluid.multiInputTransformFunction", {
            gradeNames: "fluid.transformFunction"
        }), c.defaults("fluid.standardTransformFunction", {
            gradeNames: [ "fluid.standardInputTransformFunction", "fluid.standardOutputTransformFunction" ]
        }), c.defaults("fluid.lens", {
            gradeNames: "fluid.transformFunction",
            invertConfiguration: null
        }), c.model.transform.pathToRule = function(e) {
            return {
                transform: {
                    type: "fluid.transforms.value",
                    inputPath: e
                }
            };
        }, c.model.transform.literalValueToRule = function(e) {
            return {
                transform: {
                    type: "fluid.transforms.literalValue",
                    input: e
                }
            };
        }, c.model.composePaths = function(e, t) {
            return t = 0 === t ? "0" : t || "", (e = 0 === e ? "0" : e || "") ? t ? e + "." + t : e : t;
        }, c.model.transform.accumulateInputPath = function(e, t, n) {
            void 0 !== e && n.push(c.model.composePaths(t.inputPrefix, e));
        }, c.model.transform.accumulateStandardInputPath = function(e, t, n, r) {
            c.model.transform.getValue(void 0, t[e], n), c.model.transform.accumulateInputPath(t[e + "Path"], n, r);
        }, c.model.transform.accumulateMultiInputPaths = function(e, n, r, a) {
            c.each(e, function(e, t) {
                c.model.transform.accumulateStandardInputPath(t, n, r, a);
            });
        }, c.model.transform.getValue = function(e, t, n) {
            var r;
            return void 0 !== e && (r = c.get(n.source, c.model.composePaths(n.inputPrefix, e), n.resolverGetConfig)), 
            void 0 === r && (r = c.isPrimitive(t) ? t : "literalValue" in t ? t.literalValue : void 0 === t.transform ? t : n.expand(t)), 
            r;
        }, c.model.transform.NONDEFAULT_OUTPUT_PATH_RETURN = {}, c.model.transform.setValue = function(e, t, n) {
            var r = c.copy(t), a = c.model.composePaths(n.outputPrefix, e);
            return void 0 !== r && n.applier.change(a, r), e ? c.model.transform.NONDEFAULT_OUTPUT_PATH_RETURN : r;
        }, c.model.transform.resolveParam = function(e, t, n, r) {
            var a = c.model.transform.getValue(e[n + "Path"], e[n], t);
            return void 0 !== a ? a : r;
        }, c.model.transform.matchValue = function(e, t, n) {
            var r = {
                changes: 0,
                unchanged: 0,
                changeMap: {}
            };
            return c.model.diff(e, t, r), 0 === r.unchanged ? 0 : n ? 0xffffff000000 - 16777216 * r.changes + r.unchanged : r.changes ? 0 : 0xffffff000000 + r.unchanged;
        }, c.model.transform.invertPaths = function(e, t) {
            var n = c.model.composePaths(t.outputPrefix, e.outputPath);
            return e.outputPath = c.model.composePaths(t.inputPrefix, e.inputPath), e.inputPath = n, 
            e;
        }, c.model.transform.prefixApplier = function(e, t) {
            e.inputPrefix && t.inputPrefixOp.push(e.inputPrefix), e.outputPrefix && t.outputPrefixOp.push(e.outputPrefix), 
            t.expand(e.input), e.inputPrefix && t.inputPrefixOp.pop(), e.outputPrefix && t.outputPrefixOp.pop();
        }, c.defaults("fluid.model.transform.prefixApplier", {
            gradeNames: [ "fluid.transformFunction" ]
        }), c.model.makePathStack = function(n, r) {
            var a = n[r + "Stack"] = [];
            return n[r] = "", {
                push: function(e) {
                    var t = c.model.composePaths(n[r], e);
                    a.push(n[r]), n[r] = t;
                },
                pop: function() {
                    n[r] = a.pop();
                }
            };
        }, c.model.transform.doTransform = function(r, a, e) {
            var t = e.defaults, n = c.getGlobalValue(e.typeName);
            "function" != typeof n && c.fail("Transformation record specifies transformation function with name " + r.type + " which is not a function - ", n), 
            c.hasGrade(t, "fluid.transformFunction") || (t = c.defaults("fluid.standardTransformFunction"));
            var o = [ r, a ];
            if (c.hasGrade(t, "fluid.multiInputTransformFunction")) {
                var i = {};
                c.each(t.inputVariables, function(t, n) {
                    i[n] = function() {
                        var e = c.model.transform.getValue(r[n + "Path"], r[n], a);
                        return e = void 0 === e && null !== t ? t : e;
                    };
                }), o.unshift(i);
            }
            if (c.hasGrade(t, "fluid.standardInputTransformFunction")) {
                "input" in r || "inputPath" in r || c.fail('Error in transform specification. Either "input" or "inputPath" must be specified for a standardInputTransformFunction: received ', r);
                var u = c.model.transform.getValue(r.inputPath, r.input, a);
                if (o.unshift(u), void 0 === u) return;
            }
            var s = n.apply(null, o);
            c.hasGrade(t, "fluid.standardOutputTransformFunction") && void 0 !== (void 0 !== r.outputPath ? r.outputPath : e.doOutput ? "" : void 0) && void 0 !== s && (c.model.transform.setValue(r.outputPath, s, a), 
            s = void 0);
            return s;
        };
        var n = [];
        c.registerNamespace("fluid.pathUtil"), c.pathUtil.getPathSegment = function(e, t) {
            return c.pathUtil.getPathSegmentImpl(n, e, t), n[0];
        }, c.pathUtil.getHeadPath = function(e) {
            return c.pathUtil.getPathSegment(e, 0);
        }, c.pathUtil.getFromHeadPath = function(e) {
            var t = c.pathUtil.getPathSegmentImpl(null, e, 0);
            return t === e.length ? "" : e.substring(t + 1);
        }, c.pathUtil.matchPath = function(e, t, n) {
            for (var r = []; ;) {
                if ("" === t ^ "" === e && n) return null;
                if (!e || !t) break;
                var a = c.pathUtil.getHeadPath(e), o = c.pathUtil.getHeadPath(t);
                if ("*" !== a && a !== o) return null;
                r.push(o), e = c.pathUtil.getFromHeadPath(e), t = c.pathUtil.getFromHeadPath(t);
            }
            return r;
        }, c.model.transform.expandWildcards = function(u, e) {
            c.each(e, function(e, t) {
                var n = u.queuedTransforms;
                u.pathOp.push(c.pathUtil.escapeSegment(t.toString()));
                for (var r = 0; r < n.length; ++r) if (c.pathUtil.matchPath(n[r].matchPath, u.path, !0)) {
                    var a = c.copy(n[r].transformSpec);
                    void 0 !== a.inputPath && !c.model.transform.hasWildcard(a.inputPath) || (a.inputPath = ""), 
                    u.inputPrefixOp.push(u.path), u.outputPrefixOp.push(u.path);
                    var o = c.model.transform.lookupType(a.type), i = c.model.transform.doTransform(a, u, o);
                    void 0 !== i && c.model.transform.setValue(null, i, u), u.outputPrefixOp.pop(), 
                    u.inputPrefixOp.pop();
                }
                c.isPrimitive(e) || c.model.transform.expandWildcards(u, e), u.pathOp.pop();
            });
        }, c.model.transform.hasWildcard = function(e) {
            return "string" == typeof e && -1 !== e.indexOf("*");
        }, c.model.transform.maybePushWildcard = function(e, t) {
            var n, r = c.model.transform.hasWildcard;
            return r(e.inputPath) ? n = c.model.composePaths(t.inputPrefix, e.inputPath) : (r(t.outputPrefix) || r(e.outputPath)) && (n = c.model.composePaths(t.outputPrefix, e.outputPath)), 
            !!n && (t.queuedTransforms.push({
                transformSpec: e,
                outputPrefix: t.outputPrefix,
                inputPrefix: t.inputPrefix,
                matchPath: n
            }), !0);
        }, c.model.sortByKeyLength = function(e) {
            return c.keys(e).sort(c.compareStringLength(!0));
        }, c.model.transform.handleTransformStrategy = function(e, t, n) {
            return c.model.transform.maybePushWildcard(e, t) ? void 0 : c.model.transform.doTransform(e, t, n);
        }, c.model.transform.handleInvertStrategy = function(e, t, n) {
            e = c.copy(e), c.hasGrade(n.defaults, "fluid.standardTransformFunction") && (e = c.model.transform.invertPaths(e, t));
            var r = n.defaults && n.defaults.invertConfiguration;
            if (r) {
                var a = c.invokeGlobalFunction(r, [ e, t ]);
                t.inverted.push(a);
            } else t.inverted.push(c.model.transform.uninvertibleTransform);
        }, c.model.transform.handleCollectStrategy = function(e, t, n) {
            var r = n.defaults, a = c.hasGrade(r, "fluid.standardInputTransformFunction"), o = c.hasGrade(r, "fluid.multiInputTransformFunction");
            a && c.model.transform.accumulateStandardInputPath("input", e, t, t.inputPaths), 
            o && c.model.transform.accumulateMultiInputPaths(r.inputVariables, e, t, t.inputPaths);
            var i = r.collectInputPaths;
            if (i) {
                var u = c.makeArray(c.invokeGlobalFunction(i, [ e, t ]));
                Array.prototype.push.apply(t.inputPaths, u);
            }
        }, c.model.transform.lookupType = function(e, t) {
            return e || c.fail("Transformation record is missing a type name: ", t), -1 === e.indexOf(".") && (e = "fluid.transforms." + e), 
            {
                defaults: c.defaults(e),
                typeName: e
            };
        }, c.model.transform.processRule = function(e, r) {
            var t, n, a;
            if ("string" == typeof e ? e = c.model.transform.pathToRule(e) : void 0 !== e.literalValue && (e = c.model.transform.literalValueToRule(e.literalValue)), 
            e.transform) if (c.isArrayable(e.transform)) {
                var o = e.transform;
                t = void 0;
                for (var i = 0; i < o.length; ++i) n = o[i], a = c.model.transform.lookupType(n.type), 
                r.transformHandler(n, r, a);
            } else n = e.transform, a = c.model.transform.lookupType(n.type), t = r.transformHandler(n, r, a);
            return c.isArrayable(e) && (r.collectedFlatSchemaOpts = r.collectedFlatSchemaOpts || {}, 
            r.collectedFlatSchemaOpts[r.outputPrefix] = "array"), c.each(e, function(e, t) {
                if ("transform" !== t) {
                    r.outputPrefixOp.push(t);
                    var n = r.expand(e, r);
                    void 0 !== n && (c.model.transform.setValue(null, n, r), n = void 0), r.outputPrefixOp.pop();
                }
            }), t;
        }, c.model.transform.makeStrategy = function(t, e, n) {
            n = n || c.model.transform.processRule, t.expand = function(e) {
                return n(e, t);
            }, t.outputPrefixOp = c.model.makePathStack(t, "outputPrefix"), t.inputPrefixOp = c.model.makePathStack(t, "inputPrefix"), 
            t.transformHandler = e;
        }, c.model.transform.uninvertibleTransform = Object.freeze({}), c.model.transform.invertConfiguration = function(e) {
            var t = {
                inverted: []
            };
            return c.model.transform.makeStrategy(t, c.model.transform.handleInvertStrategy), 
            t.expand(e), -1 === t.inverted.indexOf(c.model.transform.uninvertibleTransform) ? {
                transform: t.inverted
            } : c.model.transform.uninvertibleTransform;
        }, c.model.transform.collectInputPaths = function(e) {
            var t = {
                inputPaths: []
            };
            c.model.transform.makeStrategy(t, c.model.transform.handleCollectStrategy), t.expand(e);
            var n = c.arrayToHash(t.inputPaths);
            return Object.keys(n);
        }, c.model.transform.flatSchemaStrategy = function(u, s) {
            var l = c.model.sortByKeyLength(u);
            return function(e, t, n, r) {
                for (var a = s.parser.compose.apply(null, r.slice(0, n)), o = 0; o < l.length; ++o) {
                    var i = l[o];
                    if (null !== c.pathUtil.matchPath(i, a, !0)) return u[i];
                }
            };
        }, c.model.transform.defaultSchemaValue = function(e) {
            return "array" === (c.isPrimitive(e) ? e : e.type) ? [] : {};
        }, c.model.transform.isomorphicSchemaStrategy = function(o, i) {
            return function(e, t, n, r) {
                var a = c.get(o, r.slice(0, n), i);
                return c.isArrayable(a) ? "array" : "object";
            };
        }, c.model.transform.decodeStrategy = function(e, t, n) {
            return t.isomorphic ? c.model.transform.isomorphicSchemaStrategy(e, n) : t.flatSchema ? c.model.transform.flatSchemaStrategy(t.flatSchema, n) : void 0;
        }, c.model.transform.schemaToCreatorStrategy = function(o) {
            return function(e, t, n, r) {
                if (void 0 === e[t]) {
                    var a = o(e, t, n, r);
                    return e[t] = c.model.transform.defaultSchemaValue(a), e[t];
                }
            };
        }, c.model.transform.sequence = function(e, t, n) {
            for (var r = 0; r < t.length; ++r) e = c.model.transform(e, t[r], n);
            return e;
        }, c.model.compareByPathLength = function(e, t) {
            var n = e.path.length - t.path.length;
            return 0 == n ? e.sequence - t.sequence : n;
        }, c.model.fireSortedChanges = function(e, t) {
            e.sort(c.model.compareByPathLength), c.fireChanges(t, e);
        }, c.model.transformWithRules = function(e, t, n) {
            n = n || {};
            var r = c.model.escapedGetConfig, a = c.model.escapedSetConfig, o = c.model.transform.decodeStrategy(e, n, r), i = {
                source: e,
                target: {
                    model: o ? c.model.transform.defaultSchemaValue(o(null, "", 0, [ "" ])) : {}
                },
                resolverGetConfig: r,
                resolverSetConfig: a,
                collectedFlatSchemaOpts: void 0,
                queuedChanges: [],
                queuedTransforms: []
            };
            c.model.transform.makeStrategy(i, c.model.transform.handleTransformStrategy), i.applier = {
                fireChangeRequest: function(e) {
                    e.sequence = i.queuedChanges.length, i.queuedChanges.push(e);
                }
            }, c.bindRequestChange(i.applier), i.expand(t);
            var u = c.copy(a);
            return void 0 !== i.collectedFlatSchemaOpts && (s.extend(i.collectedFlatSchemaOpts, n.flatSchema), 
            o = c.model.transform.flatSchemaStrategy(i.collectedFlatSchemaOpts, r)), u.strategies = [ c.model.defaultFetchStrategy, o ? c.model.transform.schemaToCreatorStrategy(o) : c.model.defaultCreatorStrategy ], 
            i.finalApplier = n.finalApplier || c.makeHolderChangeApplier(i.target, {
                resolverSetConfig: u
            }), 0 < i.queuedTransforms.length && (i.typeStack = [], i.pathOp = c.model.makePathStack(i, "path"), 
            c.model.transform.expandWildcards(i, e)), c.model.fireSortedChanges(i.queuedChanges, i.finalApplier), 
            i.target.model;
        }, s.extend(c.model.transformWithRules, c.model.transform), c.model.transform = c.model.transformWithRules, 
        c.transformOne = function(e) {
            return {
                transformOptions: {
                    transformer: "fluid.model.transformWithRules",
                    config: e
                }
            };
        }, c.transformMany = function(e) {
            return {
                transformOptions: {
                    transformer: "fluid.model.transform.sequence",
                    config: e
                }
            };
        };
    }(t, n = n || {}), function(s, l) {
        "use strict";
        l.registerNamespace("fluid.model.transform"), l.registerNamespace("fluid.transforms"), 
        l.defaults("fluid.transforms.value", {
            gradeNames: "fluid.standardTransformFunction",
            invertConfiguration: "fluid.identity"
        }), l.transforms.value = l.identity, l.transforms.identity = l.transforms.value, 
        l.defaults("fluid.transforms.identity", {
            gradeNames: "fluid.transforms.value"
        }), l.transforms.invertToIdentity = function(e) {
            return e.type = "fluid.transforms.identity", e;
        }, l.defaults("fluid.transforms.literalValue", {
            gradeNames: "fluid.standardOutputTransformFunction"
        }), l.transforms.literalValue = function(e) {
            return e.input;
        }, l.defaults("fluid.transforms.stringToNumber", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.stringToNumber.invert"
        }), l.transforms.stringToNumber = function(e) {
            var t = Number(e);
            return isNaN(t) ? void 0 : t;
        }, l.transforms.stringToNumber.invert = function(e) {
            return e.type = "fluid.transforms.numberToString", e;
        }, l.defaults("fluid.transforms.numberToString", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.numberToString.invert"
        }), l.transforms.numberToString = function(e, t) {
            if ("number" == typeof e) return "number" != typeof t.scale || isNaN(t.scale) ? e.toString() : l.roundToDecimal(e, t.scale, t.method).toString();
        }, l.transforms.numberToString.invert = function(e) {
            return e.type = "fluid.transforms.stringToNumber", e;
        }, l.defaults("fluid.transforms.count", {
            gradeNames: "fluid.standardTransformFunction"
        }), l.transforms.count = function(e) {
            return l.makeArray(e).length;
        }, l.defaults("fluid.transforms.round", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.invertToIdentity"
        }), l.transforms.round = function(e, t) {
            return l.roundToDecimal(e, t.scale, t.method);
        }, l.defaults("fluid.transforms.delete", {
            gradeNames: "fluid.transformFunction"
        }), l.transforms.delete = function(e, t) {
            var n = l.model.composePaths(t.outputPrefix, e.outputPath);
            t.applier.change(n, null, "DELETE");
        }, l.defaults("fluid.transforms.firstValue", {
            gradeNames: "fluid.standardOutputTransformFunction"
        }), l.transforms.firstValue = function(e, t) {
            e.values && e.values.length || l.fail('firstValue transformer requires an array of values at path named "values", supplied', e);
            for (var n = 0; n < e.values.length; n++) {
                var r = e.values[n], a = t.expand(r);
                if (void 0 !== a) return a;
            }
        }, l.defaults("fluid.transforms.linearScale", {
            gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.linearScale.invert",
            inputVariables: {
                factor: 1,
                offset: 0
            }
        }), l.transforms.linearScale = function(e, t) {
            var n = t.factor(), r = t.offset();
            if ("number" == typeof e && "number" == typeof n && "number" == typeof r) return e * n + r;
        }, l.transforms.linearScale.invert = function(e) {
            return delete e.factorPath, delete e.offsetPath, void 0 !== e.factor && (e.factor = 0 === e.factor ? 0 : 1 / e.factor), 
            void 0 !== e.offset && (e.offset = -e.offset * (void 0 !== e.factor ? e.factor : 1)), 
            e;
        }, l.defaults("fluid.transforms.binaryOp", {
            gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardOutputTransformFunction" ],
            inputVariables: {
                left: null,
                right: null
            }
        }), l.transforms.binaryLookup = {
            "===": function(e, t) {
                return l.model.isSameValue(e, t);
            },
            "!==": function(e, t) {
                return !l.model.isSameValue(e, t);
            },
            "<=": function(e, t) {
                return e <= t;
            },
            "<": function(e, t) {
                return e < t;
            },
            ">=": function(e, t) {
                return t <= e;
            },
            ">": function(e, t) {
                return t < e;
            },
            "+": function(e, t) {
                return e + t;
            },
            "-": function(e, t) {
                return e - t;
            },
            "*": function(e, t) {
                return e * t;
            },
            "/": function(e, t) {
                return e / t;
            },
            "%": function(e, t) {
                return e % t;
            },
            "&&": function(e, t) {
                return e && t;
            },
            "||": function(e, t) {
                return e || t;
            }
        }, l.transforms.binaryOp = function(e, t, n) {
            var r = e.left(), a = e.right(), o = l.model.transform.getValue(void 0, t.operator, n), i = l.transforms.binaryLookup[o];
            return void 0 === i || void 0 === r || void 0 === a ? void 0 : i(r, a);
        }, l.defaults("fluid.transforms.condition", {
            gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardOutputTransformFunction" ],
            inputVariables: {
                true: null,
                false: null,
                condition: null
            }
        }), l.transforms.condition = function(e) {
            var t = e.condition();
            if (null !== t) return e[t ? "true" : "false"]();
        }, l.defaults("fluid.transforms.valueMapper", {
            gradeNames: [ "fluid.lens" ],
            invertConfiguration: "fluid.transforms.valueMapper.invert",
            collectInputPaths: "fluid.transforms.valueMapper.collect"
        }), l.model.transform.compareMatches = function(e, t) {
            var n = t.matchValue - e.matchValue;
            return 0 == n ? e.index - t.index : n;
        }, l.transforms.valueMapper = function(e, t) {
            e.match || l.fail('valueMapper requires an array or hash of matches at path named "match", supplied ', e);
            var n = l.model.transform.getValue(e.defaultInputPath, e.defaultInput, t), r = l.isArrayable(e.match) ? l.transforms.valueMapper.longFormMatch(n, e, t) : e.match[n];
            if (void 0 === r && (r = e.noMatch), void 0 !== r) {
                var a, o = void 0 === r.outputPath ? e.defaultOutputPath : r.outputPath;
                return t.outputPrefixOp.push(o), a = l.isPrimitive(r) ? r : r.outputUndefinedValue ? void 0 : void 0 === (a = l.model.transform.resolveParam(r, t, "outputValue", void 0)) ? e.defaultOutputValue : a, 
                "string" == typeof o && void 0 !== a && (l.model.transform.setValue(void 0, a, t, e.merge), 
                a = void 0), t.outputPrefixOp.pop(), a;
            }
        }, l.transforms.valueMapper.longFormMatch = function(e, t, n) {
            var r = t.match;
            0 === r.length && l.fail("valueMapper supplied empty list of matches: ", t);
            for (var a = [], o = 0; o < r.length; ++o) {
                var i = r[o], u = i.inputPath ? l.model.transform.getValue(i.inputPath, void 0, n) : e, s = l.model.transform.matchValue(i.inputValue, u, i.partialMatches);
                a[o] = {
                    index: o,
                    matchValue: s
                };
            }
            return a.sort(l.model.transform.compareMatches), a[0].matchValue <= 0 ? void 0 : r[a[0].index];
        }, l.transforms.valueMapper.invert = function(a, o) {
            var i = [], e = {
                type: "fluid.transforms.valueMapper",
                match: i
            }, u = l.isArrayable(a.match);
            e.defaultInputPath = l.model.composePaths(o.outputPrefix, a.defaultOutputPath), 
            e.defaultOutputPath = l.model.composePaths(o.inputPrefix, a.defaultInputPath);
            var s = l.firstDefined;
            return l.each(a.match, function(e, t) {
                if (!0 !== e.outputUndefinedValue) {
                    var n = {}, r = s(u ? e.inputValue : t, a.defaultInputValue);
                    void 0 === r && l.fail("Failure inverting configuration for valueMapper - inputValue could not be resolved for record " + t + ": ", a), 
                    n.outputValue = r, n.inputValue = !u && l.isPrimitive(e) ? e : s(e.outputValue, a.defaultOutputValue), 
                    e.outputPath && (n.inputPath = l.model.composePaths(o.outputPrefix, s(e.outputPath, a.outputPath))), 
                    e.inputPath && (n.outputPath = l.model.composePaths(o.inputPrefix, s(e.inputPath, a.inputPath))), 
                    i.push(n);
                }
            }), e;
        }, l.transforms.valueMapper.collect = function(e, t) {
            var n = [];
            return l.model.transform.accumulateStandardInputPath("defaultInput", e, t, n), l.each(e.match, function(e) {
                l.model.transform.accumulateInputPath(e.inputPath, t, n);
            }), n;
        }, l.defaults("fluid.transforms.arrayToSetMembership", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.arrayToSetMembership.invert"
        }), l.transforms.arrayToSetMembership = function(r, a, o) {
            var i = {}, e = a.options;
            return r && l.isArrayable(r) || l.fail("arrayToSetMembership didn't find array at inputPath nor passed as value.", a), 
            e || l.fail("arrayToSetMembership requires an options block set"), void 0 === a.presentValue && (a.presentValue = !0), 
            void 0 === a.missingValue && (a.missingValue = !1), l.each(e, function(e, t) {
                var n = -1 !== r.indexOf(t) ? a.presentValue : a.missingValue;
                l.set(i, e, n, o.resolverSetConfig);
            }), i;
        }, l.transforms.arrayToSetMembership.invertWithType = function(e, t, n) {
            e.type = n;
            var r = {};
            return l.each(e.options, function(e, t) {
                r[e] = t;
            }), e.options = r, e;
        }, l.transforms.arrayToSetMembership.invert = function(e, t) {
            return l.transforms.arrayToSetMembership.invertWithType(e, t, "fluid.transforms.setMembershipToArray");
        }, l.defaults("fluid.transforms.setMembershipToArray", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.setMembershipToArray.invert"
        }), l.transforms.setMembershipToArray = function(n, r, a) {
            var e = r.options;
            e || l.fail("setMembershipToArray requires an options block specified"), void 0 === r.presentValue && (r.presentValue = !0), 
            void 0 === r.missingValue && (r.missingValue = !1);
            var o = [];
            return l.each(e, function(e, t) {
                l.get(n, t, a.resolverGetConfig) === r.presentValue && o.push(e);
            }), o;
        }, l.transforms.setMembershipToArray.invert = function(e, t) {
            return l.transforms.arrayToSetMembership.invertWithType(e, t, "fluid.transforms.arrayToSetMembership");
        }, l.model.transform.applyPaths = function(e, t, n) {
            for (var r = 0; r < n.length; ++r) "push" === e ? t.push(n[r]) : t.pop();
        }, l.model.transform.expandInnerValues = function(e, t, n, r) {
            var a = n.inputPrefixOp, o = n.outputPrefixOp, i = l.model.transform.applyPaths;
            i("push", a, e), i("push", o, t);
            var u = {};
            return l.each(r, function(e) {
                var t = n.expand(e);
                l.isPrimitive(t) ? u = t : s.extend(!0, u, t);
            }), i("pop", o, t), i("pop", a, e), u;
        }, l.defaults("fluid.transforms.indexArrayByKey", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.indexArrayByKey.invert"
        }), l.transforms.indexArrayByKey = function(e, o, i) {
            void 0 === o.key && l.fail("indexArrayByKey requires a 'key' option.", o), l.isArrayable(e) || l.fail("indexArrayByKey didn't find array at inputPath.", o);
            var u = {}, s = o.key;
            return l.each(e, function(e, t) {
                var n = e[s], r = typeof n;
                "string" != r && "boolean" != r && "number" != r && l.fail("indexArrayByKey encountered untransformable array due to missing or invalid key", e);
                var a = l.copy(e);
                delete a[s], o.innerValue && (a = l.model.transform.expandInnerValues([ i.inputPrefix, o.inputPath, t.toString() ], [ o.outputPath, n ], i, o.innerValue)), 
                u[n] = a;
            }), u;
        }, l.transforms.indexArrayByKey.invert = function(e) {
            if (e.type = "fluid.transforms.deindexIntoArrayByKey", e.innerValue) for (var t = e.innerValue, n = 0; n < t.length; ++n) {
                var r = l.model.transform.invertConfiguration(t[n]);
                if (r === l.model.transform.uninvertibleTransform) return r;
                t[n] = r;
            }
            return e;
        }, l.defaults("fluid.transforms.deindexIntoArrayByKey", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.deindexIntoArrayByKey.invert"
        }), l.transforms.deindexIntoArrayByKey = function(e, r, a) {
            void 0 === r.key && l.fail('deindexIntoArrayByKey requires a "key" option.', r);
            var o = [], i = r.key;
            return l.each(e, function(e, t) {
                var n = {};
                n[i] = t, r.innerValue && (e = l.model.transform.expandInnerValues([ r.inputPath, t ], [ r.outputPath, o.length.toString() ], a, r.innerValue)), 
                s.extend(!0, n, e), o.push(n);
            }), o;
        }, l.transforms.deindexIntoArrayByKey.invert = function(e) {
            if (e.type = "fluid.transforms.indexArrayByKey", e.innerValue) for (var t = e.innerValue, n = 0; n < t.length; ++n) t[n] = l.model.transform.invertConfiguration(t[n]);
            return e;
        }, l.defaults("fluid.transforms.limitRange", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.invertToIdentity"
        }), l.transforms.limitRange = function(e, t) {
            var n = t.min;
            void 0 !== n && e < (n += t.excludeMin || 0) && (e = n);
            var r = t.max;
            void 0 !== r && (r -= t.excludeMax || 0) < e && (e = r);
            return e;
        }, l.defaults("fluid.transforms.indexOf", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.indexOf.invert"
        }), l.transforms.indexOf = function(e, t) {
            "number" == typeof t.notFound && 0 <= t.notFound && l.fail("A positive number is not allowed as 'notFound' value for indexOf");
            var n = l.transforms.parseIndexationOffset(t.offset, "indexOf"), r = l.makeArray(t.array).indexOf(e);
            return -1 === r && t.notFound ? t.notFound : r + n;
        }, l.transforms.indexOf.invert = function(e, t) {
            var n = l.transforms.invertArrayIndexation(e, t);
            return n.type = "fluid.transforms.dereference", n;
        }, l.defaults("fluid.transforms.dereference", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.dereference.invert"
        }), l.transforms.dereference = function(e, t) {
            if ("number" == typeof e) {
                var n = l.transforms.parseIndexationOffset(t.offset, "dereference");
                return l.makeArray(t.array)[e + n];
            }
        }, l.transforms.dereference.invert = function(e, t) {
            var n = l.transforms.invertArrayIndexation(e, t);
            return n.type = "fluid.transforms.indexOf", n;
        }, l.transforms.parseIndexationOffset = function(e, t) {
            var n = 0;
            return void 0 !== e && (n = l.parseInteger(e), isNaN(n) && l.fail(t + ' requires the value of "offset" to be an integer or a string that can be converted to an integer. ' + e + " is invalid.")), 
            n;
        }, l.transforms.invertArrayIndexation = function(e) {
            return isNaN(Number(e.offset)) || (e.offset = -1 * Number(e.offset)), e;
        }, l.defaults("fluid.transforms.stringTemplate", {
            gradeNames: "fluid.standardOutputTransformFunction"
        }), l.transforms.stringTemplate = function(e) {
            return l.stringTemplate(e.template, e.terms);
        }, l.defaults("fluid.transforms.free", {
            gradeNames: "fluid.transformFunction"
        }), l.transforms.free = function(e) {
            var t = l.makeArray(e.args);
            return l.invokeGlobalFunction(e.func, t);
        }, l.defaults("fluid.transforms.quantize", {
            gradeNames: "fluid.standardTransformFunction",
            collectInputPaths: "fluid.transforms.quantize.collect"
        }), l.transforms.quantize = function(e, t, n) {
            t.ranges && t.ranges.length || l.fail("fluid.transforms.quantize should have a key called ranges containing an array defining ranges to quantize");
            for (var r = 0; r < t.ranges.length; r++) {
                var a = t.ranges[r];
                if (e <= a.upperBound || void 0 === a.upperBound && e >= Number.NEGATIVE_INFINITY) return l.isPrimitive(a.output) ? a.output : n.expand(a.output);
            }
        }, l.transforms.quantize.collect = function(e, t) {
            e.ranges.forEach(function(e) {
                l.isPrimitive(e.output) || t.expand(e.output);
            });
        }, l.defaults("fluid.transforms.inRange", {
            gradeNames: "fluid.standardTransformFunction"
        }), l.transforms.inRange = function(e, t) {
            return (void 0 === t.min || t.min <= e) && (void 0 === t.max || t.max >= e);
        }, l.transforms.stringToBoolean = function(e) {
            return !!e && !("0" === e || "false" === e);
        }, l.transforms.stringToBoolean.invert = function(e) {
            return e.type = "fluid.transforms.booleanToString", e;
        }, l.defaults("fluid.transforms.stringToBoolean", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.stringToBoolean.invert"
        }), l.transforms.booleanToString = function(e) {
            return e ? "true" : "false";
        }, l.transforms.booleanToString.invert = function(e) {
            return e.type = "fluid.transforms.stringToBoolean", e;
        }, l.defaults("fluid.transforms.booleanToString", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.booleanToString.invert"
        }), l.transforms.JSONstringToObject = function(e) {
            try {
                return JSON.parse(e);
            } catch (e) {
                return;
            }
        }, l.transforms.JSONstringToObject.invert = function(e) {
            return e.type = "fluid.transforms.objectToJSONString", e;
        }, l.defaults("fluid.transforms.JSONstringToObject", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.JSONstringToObject.invert"
        }), l.transforms.objectToJSONString = function(e, t) {
            var n = t.space || 0;
            return JSON.stringify(e, null, n);
        }, l.transforms.objectToJSONString.invert = function(e) {
            return e.type = "fluid.transforms.JSONstringToObject", e;
        }, l.defaults("fluid.transforms.objectToJSONString", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.objectToJSONString.invert"
        }), l.transforms.stringToDate = function(e) {
            var t = new Date(e);
            return isNaN(t.getTime()) ? void 0 : t;
        }, l.transforms.stringToDate.invert = function(e) {
            return e.type = "fluid.transforms.dateToString", e;
        }, l.defaults("fluid.transforms.stringToDate", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.stringToDate.invert"
        }), l.transforms.dateToString = function(e) {
            if (e instanceof Date) {
                var t = e.toISOString();
                return t.substring(0, t.indexOf("T"));
            }
        }, l.transforms.dateToString.invert = function(e) {
            return e.type = "fluid.transforms.stringToDate", e;
        }, l.defaults("fluid.transforms.dateToString", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.dateToString.invert"
        }), l.transforms.dateTimeToString = function(e) {
            return e instanceof Date ? e.toISOString() : void 0;
        }, l.defaults("fluid.transforms.dateTimeToString", {
            gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
            invertConfiguration: "fluid.transforms.dateToString.invert"
        });
    }(t, n = n || {}), function(e, o) {
        "use strict";
        o.registerNamespace("fluid.contextAware"), o.defaults("fluid.contextAware.marker", {
            gradeNames: [ "fluid.component" ]
        }), o.contextAware.makeCheckMarkers = function(e, n, r) {
            o.each(e, function(e, t) {
                o.constructSingle(n, {
                    type: t,
                    gradeNames: "fluid.contextAware.marker",
                    value: e
                }, r);
            });
        }, o.contextAware.performChecks = function(e) {
            return o.transform(e, function(e) {
                return "function" == typeof e ? e = {
                    func: e
                } : "string" == typeof e && (e = {
                    funcName: e
                }), o.isPrimitive(e) ? e : "value" in e ? e.value : "func" in e ? e.func() : "funcName" in e ? o.invokeGlobalFunction(e.funcName) : void o.fail("Error in contextAwareness check record ", e, " - must contain an entry with name value, func, or funcName");
            });
        }, o.contextAware.makeChecks = function(e, t, n) {
            var r = o.contextAware.performChecks(e);
            o.contextAware.makeCheckMarkers(r, t, n);
        }, o.contextAware.forgetChecks = function(e, r, a) {
            a = a || o.globalInstantiator, r = r || [];
            var t = o.makeArray(e);
            o.each(t, function(e) {
                var t = o.typeNameToMemberName(e), n = o.model.parseToSegments(r, a.parseEL, !0);
                n.push(t), o.destroy(n, a);
            });
        }, o.defaults("fluid.contextAware", {
            gradeNames: [ "{that}.check" ],
            mergePolicy: {
                contextAwareness: "noexpand"
            },
            contextAwareness: {},
            invokers: {
                check: {
                    funcName: "fluid.contextAware.check",
                    args: [ "{that}", "{that}.options.contextAwareness" ]
                }
            }
        }), o.contextAware.getCheckValue = function(e, t) {
            var n = o.parseContextReference(t), r = o.resolveContext(n.context, e), a = n.path || [ "options", "value" ];
            return o.getForComponent(r, a);
        }, o.contextAware.checkOne = function(n, e) {
            e.checks && e.checks.contextValue && o.fail("Nesting error in contextAwareness record ", e, ' - the "checks" entry must contain a hash and not a contextValue/gradeNames record at top level');
            var t = o.parsePriorityRecords(e.checks, "contextAwareness checkRecord");
            return o.find(t, function(e) {
                e.contextValue || o.fail("Cannot perform check for contextAwareness record ", e, ' without a valid field named "contextValue"');
                var t = o.contextAware.getCheckValue(n, e.contextValue);
                if (void 0 === e.equals ? t : t === e.equals) return e.gradeNames;
            }, e.defaultGradeNames);
        }, o.contextAware.check = function(n, e) {
            var r = [], t = o.parsePriorityRecords(e, "contextAwareness adaptationRecord");
            return o.each(t, function(e) {
                var t = o.contextAware.checkOne(n, e);
                r = r.concat(o.makeArray(t));
            }), r;
        }, o.contextAware.makeAdaptation = function(e) {
            o.expect("fluid.contextAware.makeAdaptation", e, [ "distributionName", "targetName", "adaptationName", "checkName", "record" ]), 
            o.defaults(e.distributionName, {
                gradeNames: [ "fluid.component" ],
                distributeOptions: {
                    target: "{/ " + e.targetName + "}.options.contextAwareness." + e.adaptationName + ".checks." + e.checkName,
                    record: e.record
                }
            }), o.constructSingle([], e.distributionName);
        }, o.contextAware.isBrowser = function() {
            return "undefined" != typeof window && !!window.document;
        }, o.contextAware.makeChecks({
            "fluid.browser": {
                funcName: "fluid.contextAware.isBrowser"
            }
        }), o.registerNamespace("fluid.contextAware.browser"), o.contextAware.browser.getPlatformName = function() {
            return "undefined" != typeof navigator && navigator.platform ? navigator.platform : void 0;
        }, o.contextAware.browser.getUserAgent = function() {
            return "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent : void 0;
        }, o.contextAware.makeChecks({
            "fluid.browser.platformName": {
                funcName: "fluid.contextAware.browser.getPlatformName"
            },
            "fluid.browser.userAgent": {
                funcName: "fluid.contextAware.browser.getUserAgent"
            }
        });
    }(0, n = n || {}), function() {
        var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
        if (!e.ArrayMath) {
            var t = {
                add: function(e, t, n) {
                    var r;
                    if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; 0 <= r; --r) e[r] = t[r] + n[r]; else for (r = Math.min(e.length, n.length) - 1; 0 <= r; --r) e[r] = t + n[r];
                },
                sub: function(e, t, n) {
                    var r;
                    if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; 0 <= r; --r) e[r] = t[r] - n[r]; else for (r = Math.min(e.length, n.length) - 1; 0 <= r; --r) e[r] = t - n[r];
                },
                mul: function(e, t, n) {
                    var r;
                    if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; 0 <= r; --r) e[r] = t[r] * n[r]; else for (r = Math.min(e.length, n.length) - 1; 0 <= r; --r) e[r] = t * n[r];
                },
                mulCplx: function(e, t, n, r, a, o) {
                    var i, u, s, l, c;
                    if (n instanceof Float32Array) for (i = Math.min(e.length, t.length, n.length, r.length, a.length, o.length) - 1; 0 <= i; --i) u = n[i], 
                    s = r[i], l = a[i], c = o[i], e[i] = u * l - s * c, t[i] = u * c + s * l; else for (i = Math.min(e.length, t.length, a.length, o.length) - 1; 0 <= i; --i) l = a[i], 
                    c = o[i], e[i] = n * l - r * c, t[i] = n * c + r * l;
                },
                div: function(e, t, n) {
                    var r;
                    if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; 0 <= r; --r) e[r] = t[r] / n[r]; else for (r = Math.min(e.length, n.length) - 1; 0 <= r; --r) e[r] = t / n[r];
                },
                divCplx: function(e, t, n, r, a, o) {
                    var i, u, s, l, c, d;
                    if (n instanceof Float32Array) for (i = Math.min(e.length, t.length, n.length, r.length, a.length, o.length) - 1; 0 <= i; --i) u = n[i], 
                    s = r[i], d = 1 / ((l = a[i]) * l + (c = o[i]) * c), e[i] = (u * l + s * c) * d, 
                    t[i] = (s * l - u * c) * d; else for (i = Math.min(e.length, t.length, a.length, o.length) - 1; 0 <= i; --i) d = 1 / ((l = a[i]) * l + (c = o[i]) * c), 
                    e[i] = (n * l + r * c) * d, t[i] = (r * l - n * c) * d;
                },
                madd: function(e, t, n, r) {
                    var a;
                    if (t instanceof Float32Array) for (a = Math.min(e.length, t.length, n.length, r.length) - 1; 0 <= a; --a) e[a] = t[a] * n[a] + r[a]; else for (a = Math.min(e.length, n.length, r.length) - 1; 0 <= a; --a) e[a] = t * n[a] + r[a];
                },
                abs: function(e, t) {
                    for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.abs(t[n]);
                },
                absCplx: function(e, t, n) {
                    for (var r = Math.min(e.length, t.length, n.length) - 1; 0 <= r; --r) e[r] = Math.sqrt(t[r] * t[r] + n[r] * n[r]);
                },
                acos: function(e, t) {
                    for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.acos(t[n]);
                },
                asin: function(e, t) {
                    for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.asin(t[n]);
                },
                atan: function(e, t) {
                    for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.atan(t[n]);
                },
                atan2: function(e, t, n) {
                    for (var r = Math.min(e.length, n.length, t.length) - 1; 0 <= r; --r) e[r] = Math.atan2(t[r], n[r]);
                },
                ceil: function(e, t) {
                    for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.ceil(t[n]);
                },
                cos: function(e, t) {
                    for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.cos(t[n]);
                },
                exp: function(e, t) {
                    for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.exp(t[n]);
                },
                floor: function(e, t) {
                    for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.floor(t[n]);
                },
                log: function(e, t) {
                    for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.log(t[n]);
                },
                max: function(e) {
                    for (var t = -1 / 0, n = e.length - 1; 0 <= n; --n) {
                        var r = e[n];
                        t < r && (t = r);
                    }
                    return t;
                },
                min: function(e) {
                    for (var t = 1 / 0, n = e.length - 1; 0 <= n; --n) {
                        var r = e[n];
                        r < t && (t = r);
                    }
                    return t;
                },
                pow: function(e, t, n) {
                    var r;
                    if (n instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; 0 <= r; --r) e[r] = Math.pow(t[r], n[r]); else for (r = Math.min(e.length, t.length) - 1; 0 <= r; --r) e[r] = Math.pow(t[r], n);
                },
                random: function(e, t, n) {
                    t || (t = 0), isNaN(parseFloat(n)) && (n = 1);
                    for (var r = n - t, a = e.length - 1; 0 <= a; --a) e[a] = Math.random() * r + t;
                },
                round: function(e, t) {
                    for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.round(t[n]);
                },
                sin: function(e, t) {
                    for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.sin(t[n]);
                },
                sqrt: function(e, t) {
                    for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.sqrt(t[n]);
                },
                tan: function(e, t) {
                    for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.tan(t[n]);
                },
                clamp: function(e, t, n, r) {
                    for (var a = Math.min(e.length, t.length) - 1; 0 <= a; --a) {
                        var o = t[a];
                        e[a] = o < n ? n : r < o ? r : o;
                    }
                },
                fract: function(e, t) {
                    for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) {
                        var r = t[n];
                        e[n] = r - Math.floor(r);
                    }
                },
                fill: function(e, t) {
                    for (var n = e.length - 1; 0 <= n; --n) e[n] = t;
                },
                ramp: function(e, t, n) {
                    var r = e.length - 1;
                    if (0 <= r && (e[0] = t), 0 < r) for (var a = (n - t) / r, o = 1; o <= r; ++o) e[o] = t + a * o;
                },
                sign: function(e, t) {
                    for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = t[n] < 0 ? -1 : 1;
                },
                sum: function(e) {
                    for (var t = 0, n = e.length - 1; 0 <= n; --n) t += e[n];
                    return t;
                },
                sampleLinear: function(e, t, n) {
                    for (var r = t.length - 1, a = Math.min(e.length, n.length) - 1; 0 <= a; --a) {
                        var o = n[a];
                        o = o < 0 ? 0 : r < o ? r : o;
                        var i = Math.floor(o), u = o - i, s = t[i], l = t[i < r ? i + 1 : r];
                        e[a] = s + u * (l - s);
                    }
                },
                sampleLinearRepeat: function(e, t, n) {
                    for (var r = t.length, a = r - 1, o = Math.min(e.length, n.length) - 1; 0 <= o; --o) {
                        var i = n[o];
                        i -= Math.floor(i / r) * r;
                        var u = Math.floor(i), s = i - u, l = t[u], c = t[u < a ? u + 1 : 0];
                        e[o] = l + s * (c - l);
                    }
                },
                sampleCubic: function(e, t, n) {
                    for (var r = t.length - 1, a = Math.min(e.length, n.length) - 1; 0 <= a; --a) {
                        var o = n[a];
                        o = o < 0 ? 0 : r < o ? r : o;
                        var i = Math.floor(o), u = o - i, s = u * u, l = s * u, c = -2 * l + 3 * s, d = 1 - c, f = l - s, p = f - s + u, m = t[0 < i ? i - 1 : 0], g = t[i], h = t[i < r ? i + 1 : r], v = t[i < r - 1 ? i + 2 : r];
                        e[a] = d * g + c * h + .5 * (p * (h - m) + f * (v - g));
                    }
                },
                sampleCubicRepeat: function(e, t, n) {
                    for (var r = t.length, a = r - 1, o = Math.min(e.length, n.length) - 1; 0 <= o; --o) {
                        var i = n[o];
                        i -= Math.floor(i / r) * r;
                        var u = Math.floor(i), s = i - u, l = s * s, c = l * s, d = -2 * c + 3 * l, f = 1 - d, p = c - l, m = p - l + s, g = t[0 < u ? u - 1 : a], h = t[u], v = t[u < a ? u + 1 : 0], y = t[u < a - 1 ? u + 2 : u + 2 - Math.floor((u + 2) / r) * r];
                        e[o] = f * h + d * v + .5 * (m * (v - g) + p * (y - h));
                    }
                },
                pack: function(e, t, n, r, a, o, i) {
                    var u = Math.floor(Math.max(0, e.length - t) / n), s = Math.min(u, r.length);
                    if (a) {
                        s = Math.min(s, a.length);
                        if (o) {
                            s = Math.min(s, o.length);
                            if (i) {
                                s = Math.min(s, i.length);
                                for (var l = 0; l < s; ++l) e[t] = r[l], e[t + 1] = a[l], e[t + 2] = o[l], e[t + 3] = i[l], 
                                t += n;
                            } else for (l = 0; l < s; ++l) e[t] = r[l], e[t + 1] = a[l], e[t + 2] = o[l], t += n;
                        } else for (l = 0; l < s; ++l) e[t] = r[l], e[t + 1] = a[l], t += n;
                    } else for (l = 0; l < s; ++l) e[t] = r[l], t += n;
                },
                unpack: function(e, t, n, r, a, o, i) {
                    var u = Math.floor(Math.max(0, e.length - t) / n), s = Math.min(u, r.length);
                    if (a) {
                        s = Math.min(s, a.length);
                        if (o) {
                            s = Math.min(s, o.length);
                            if (i) {
                                s = Math.min(s, i.length);
                                for (var l = 0; l < s; ++l) r[l] = e[t], a[l] = e[t + 1], o[l] = e[t + 2], i[l] = e[t + 3], 
                                t += n;
                            } else for (l = 0; l < s; ++l) r[l] = e[t], a[l] = e[t + 1], o[l] = e[t + 2], t += n;
                        } else for (l = 0; l < s; ++l) r[l] = e[t], a[l] = e[t + 1], t += n;
                    } else for (l = 0; l < s; ++l) r[l] = e[t], t += n;
                }
            };
            e.ArrayMath = t;
        }
    }(), function() {
        var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
        if (!e.Filter) {
            function t(e, t) {
                !isNaN(parseFloat(e)) && isFinite(e) || (e = 1), t || (t = 0), this._b = new Float32Array(e), 
                this._b[0] = 1, this._a = new Float32Array(t), this._bHist = new Float32Array(e), 
                this._aHist = new Float32Array(t);
            }
            t.prototype.filter = function(e, t) {
                var n, r = this._a, a = r.length, o = this._b, i = o.length, u = this._aHist, s = this._bHist, l = t.length, c = e.length, d = i - 1, f = a;
                for (n = 0; (d || f) && n < l; ++n) {
                    var p;
                    p = i - d, d && d--;
                    var m = o[0] * t[n];
                    for (I = 1; I < p; ++I) m += o[I] * t[n - I];
                    for (;I < i; ++I) m += o[I] * s[I - p];
                    for (p = a - f, f && f--, I = 0; I < p; ++I) m -= r[I] * e[n - 1 - I];
                    for (;I < a; ++I) m -= r[I] * u[I - p];
                    e[n] = m;
                }
                if (3 == i && 2 == a) for (var g, h, v = o[0], y = o[1], b = o[2], k = r[0], S = r[1], C = t[n - 1], x = t[n - 2], A = e[n - 1], w = e[n - 2]; n < l; ++n) g = x, 
                x = C, h = w, A = v * (C = t[n]) + y * x + b * g - k * (w = A) - S * h, e[n] = A; else for (;n < l; ++n) {
                    var I;
                    m = o[0] * t[n];
                    for (I = 1; I < i; ++I) m += o[I] * t[n - I];
                    for (I = 0; I < a; ++I) m -= r[I] * e[n - 1 - I];
                    e[n] = m;
                }
                var N = Math.min(i - 1, l);
                for (n = i - 2; N <= n; --n) s[n] = s[n - N];
                for (n = 0; n < N; ++n) s[n] = t[l - 1 - n];
                for (N = Math.min(a, c), n = a - 1; N <= n; --n) u[n] = u[n - N];
                for (n = 0; n < N; ++n) u[n] = e[l - 1 - n];
            }, t.prototype.clearHistory = function() {
                for (var e = this._bHist.length - 1; 0 <= e; --e) this._bHist[e] = 0;
                for (e = this._aHist.length - 1; 0 <= e; --e) this._aHist[e] = 0;
            }, t.prototype.setB = function(e) {
                for (var t = Math.min(this._b.length, e.length), n = 0; n < t; ++n) this._b[n] = e[n];
            }, t.prototype.setA = function(e) {
                for (var t = Math.min(this._a.length, e.length), n = 0; n < t; ++n) this._a[n] = e[n];
            }, e.Filter = t;
        }
    }(), function() {
        var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
        if (!e.FFT) {
            function t(e) {
                e || (e = 256), Object.defineProperty(this, "size", {
                    configurable: !1,
                    writable: !1,
                    value: e
                }), this._twiddlesFwdRe = new Float32Array(e), this._twiddlesFwdIm = new Float32Array(e), 
                this._twiddlesInvRe = this._twiddlesFwdRe, this._twiddlesInvIm = new Float32Array(e);
                for (var t = 0; t < e; ++t) {
                    var n = -2 * Math.PI * t / e, r = Math.cos(n), a = Math.sin(n);
                    this._twiddlesFwdRe[t] = r, this._twiddlesFwdIm[t] = a, this._twiddlesInvIm[t] = -a;
                }
                this._factors = new Int32Array(64), function(e, t) {
                    var n = 4, r = Math.floor(Math.sqrt(e)), a = 0;
                    do {
                        for (;e % n; ) {
                            switch (n) {
                              case 4:
                                n = 2;
                                break;

                              case 2:
                                n = 3;
                                break;

                              default:
                                n += 2;
                            }
                            r < n && (n = e);
                        }
                        e = Math.floor(e / n), t[a++] = n, t[a++] = e;
                    } while (1 < e);
                }(e, this._factors);
            }
            var b = function(e, t, n, r, a, o, i, u, s, l, c, d, f, p) {
                var m = s[l++], g = s[l++], h = n, v = n + m * g, y = i * u;
                if (1 == g) for (;e[n] = r[o], t[n] = a[o], o += y, ++n != v; ) ; else for (;b(e, t, n, r, a, o, i * m, u, s, l, c, d, f, p), 
                o += y, (n += g) != v; ) ;
                switch (n = h, m) {
                  case 2:
                    !function(e, t, n, r, a, o, i) {
                        for (var u, s, l, c, d, f, p, m, g = 0, h = n, v = n + i, y = .7071067811865475, b = h + i; h < b; ) l = e[h] * y, 
                        c = t[h] * y, d = e[v] * y, f = t[v] * y, u = d * (p = a[g]) - f * (m = o[g]), s = d * m + f * p, 
                        e[v] = l - u, t[v] = c - s, e[h] = l + u, t[h] = c + s, g += r, ++h, ++v;
                    }(e, t, n, i, c, d, g);
                    break;

                  case 3:
                    !function(e, t, n, r, a, o, i) {
                        for (var u, s, l, c, d, f, p, m, g, h, v, y, b, k, S, C, x = 0, A = 0, w = 2 * r, I = n, N = n + i, M = n + 2 * i, P = o[r * i], O = .5773502691896258, T = I + i; I < T; ) g = e[I] * O, 
                        h = t[I] * O, v = e[N] * O, y = t[N] * O, b = e[M] * O, k = t[M] * O, S = a[x], 
                        c = v * (C = o[x]) + y * S, u = (l = v * S - y * C) - (d = b * (S = a[A]) - k * (C = o[A])), 
                        s = c - (f = b * C + k * S), v = g - .5 * (p = l + d), y = h - .5 * (m = c + f), 
                        u *= P, s *= P, e[I] = g + p, t[I] = h + m, e[M] = v + s, t[M] = y - u, e[N] = v - s, 
                        t[N] = y + u, x += r, A += w, ++I, ++N, ++M;
                    }(e, t, n, i, c, d, g);
                    break;

                  case 4:
                    !function(e, t, n, r, a, o, i, u) {
                        for (var s, l, c, d, f, p, m, g, h, v, y, b, k, S, C, x, A, w, I, N, M, P, O = 0, T = 0, D = 0, V = 2 * r, L = 3 * r, R = n, E = n + i, F = n + 2 * i, B = n + 3 * i, G = R + i; R < G; ) k = .5 * e[R], 
                        S = .5 * t[R], C = .5 * e[E], x = .5 * t[E], A = .5 * e[F], w = .5 * t[F], I = .5 * e[B], 
                        N = .5 * t[B], s = C * (M = a[O]) - x * (P = o[O]), l = C * P + x * M, y = k - (c = A * (M = a[T]) - w * (P = o[T])), 
                        b = S - (d = A * P + w * M), k += c, S += d, m = s + (f = I * (M = a[D]) - N * (P = o[D])), 
                        g = l + (p = I * P + N * M), h = s - f, v = l - p, e[F] = k - m, t[F] = S - g, e[R] = k + m, 
                        t[R] = S + g, u ? (e[E] = y - v, t[E] = b + h, e[B] = y + v, t[B] = b - h) : (e[E] = y + v, 
                        t[E] = b - h, e[B] = y - v, t[B] = b + h), O += r, T += V, D += L, ++R, ++E, ++F, 
                        ++B;
                    }(e, t, n, i, c, d, g, p);
                    break;

                  case 5:
                    !function(e, t, n, r, a, o, i) {
                        for (var u, s, l, c, d, f, p, m, g, h, v, y, b, k, S, C, x, A, w, I, N, M, P, O, T, D, V, L, R, E, F, B, G, q, _, U, j, W, z = 0, H = 0, K = 0, J = 0, $ = 2 * r, Q = 3 * r, Y = 4 * r, X = n, Z = n + i, ee = n + 2 * i, te = n + 3 * i, ne = n + 4 * i, re = a[r * i], ae = o[r * i], oe = a[2 * r * i], ie = o[2 * r * i], ue = .4472135954999579, se = X + i; X < se; ) V = e[X] * ue, 
                        L = t[X] * ue, R = e[Z] * ue, E = t[Z] * ue, F = e[ee] * ue, B = t[ee] * ue, G = e[te] * ue, 
                        q = t[te] * ue, _ = e[ne] * ue, U = t[ne] * ue, u = V, s = L, l = R * (j = a[z]) - E * (W = o[z]), 
                        c = R * W + E * j, d = F * (j = a[H]) - B * (W = o[H]), f = F * W + B * j, p = G * (j = a[K]) - q * (W = o[K]), 
                        m = G * W + q * j, S = l + (g = _ * (j = a[J]) - U * (W = o[J])), C = c + (h = _ * W + U * j), 
                        N = l - g, M = c - h, x = d + p, A = f + m, w = d - p, I = f - m, e[X] = V + S + x, 
                        t[X] = L + C + A, v = u + S * re + x * oe, y = s + C * re + A * oe, b = M * ae + I * ie, 
                        k = -N * ae - w * ie, e[Z] = v - b, t[Z] = y - k, e[ne] = v + b, t[ne] = y + k, 
                        P = u + S * oe + x * re, O = s + C * oe + A * re, T = -M * ie + I * ae, D = N * ie - w * ae, 
                        e[ee] = P + T, t[ee] = O + D, e[te] = P - T, t[te] = O - D, z += r, H += $, K += Q, 
                        J += Y, ++X, ++Z, ++ee, ++te, ++ne;
                    }(e, t, n, i, c, d, g);
                    break;

                  default:
                    !function(e, t, n, r, a, o, i, u, s) {
                        var l, c, d, f, p, m, g, h, v, y, b = new Float32Array(u), k = new Float32Array(u), S = Math.sqrt(1 / u);
                        for (l = 0; l < i; ++l) {
                            for (f = n + l, c = 0; c < u; ++c) b[c] = e[f] * S, k[c] = t[f] * S, f += i;
                            f = n + l;
                            var C = r * l;
                            for (c = 0; c < u; ++c) {
                                p = b[0], m = k[0];
                                var x = 0;
                                for (d = 1; d < u; ++d) s <= (x += C) && (x -= s), g = b[d], h = k[d], p += g * (v = a[x]) - h * (y = o[x]), 
                                m += g * y + h * v;
                                e[f] = p, t[f] = m, f += i, C += r;
                            }
                        }
                    }(e, t, n, i, c, d, g, m, f);
                }
            };
            t.prototype.forwardCplx = function(e, t, n, r) {
                var a = this._twiddlesFwdRe, o = this._twiddlesFwdIm;
                b(e, t, 0, n, r, 0, 1, 1, this._factors, 0, a, o, this.size, !1);
            }, t.prototype.forward = function(e, t, n) {
                this.forwardCplx(e, t, n, new Float32Array(this.size));
            }, t.prototype.inverseCplx = function(e, t, n, r) {
                var a = this._twiddlesInvRe, o = this._twiddlesInvIm;
                b(e, t, 0, n, r, 0, 1, 1, this._factors, 0, a, o, this.size, !0);
            }, t.prototype.inverse = function(e, t, n) {
                this.inverseCplx(e, new Float32Array(this.size), t, n);
            }, e.FFT = t;
        }
    }();
    function r(e) {
        if ("number" != typeof (e = void 0 === e ? new Date().getTime() : e) || Math.ceil(e) != Math.floor(e)) throw new TypeError("seed value must be an integer");
        this.N = 624, this.M = 397, this.MATRIX_A = 2567483615, this.UPPER_MASK = 2147483648, 
        this.LOWER_MASK = 2147483647, this.mt = new Array(this.N), this.mti = this.N + 1, 
        this.init_by_array([ e ], 1);
    }
    r.prototype.init_genrand = function(e) {
        for (this.mt[0] = e >>> 0, this.mti = 1; this.mti < this.N; this.mti++) {
            e = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
            this.mt[this.mti] = (1812433253 * ((4294901760 & e) >>> 16) << 16) + 1812433253 * (65535 & e) + this.mti, 
            this.mt[this.mti] >>>= 0;
        }
    }, r.prototype.init_by_array = function(e, t) {
        var n, r, a;
        for (this.init_genrand(19650218), n = 1, r = 0, a = this.N > t ? this.N : t; a; a--) {
            var o = this.mt[n - 1] ^ this.mt[n - 1] >>> 30;
            this.mt[n] = (this.mt[n] ^ (1664525 * ((4294901760 & o) >>> 16) << 16) + 1664525 * (65535 & o)) + e[r] + r, 
            this.mt[n] >>>= 0, r++, ++n >= this.N && (this.mt[0] = this.mt[this.N - 1], n = 1), 
            t <= r && (r = 0);
        }
        for (a = this.N - 1; a; a--) {
            o = this.mt[n - 1] ^ this.mt[n - 1] >>> 30;
            this.mt[n] = (this.mt[n] ^ (1566083941 * ((4294901760 & o) >>> 16) << 16) + 1566083941 * (65535 & o)) - n, 
            this.mt[n] >>>= 0, ++n >= this.N && (this.mt[0] = this.mt[this.N - 1], n = 1);
        }
        this.mt[0] = 2147483648;
    }, r.prototype.genrand_int32 = function() {
        var e, t = new Array(0, this.MATRIX_A);
        if (this.mti >= this.N) {
            var n;
            for (this.mti == this.N + 1 && this.init_genrand(5489), n = 0; n < this.N - this.M; n++) e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, 
            this.mt[n] = this.mt[n + this.M] ^ e >>> 1 ^ t[1 & e];
            for (;n < this.N - 1; n++) e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, 
            this.mt[n] = this.mt[n + (this.M - this.N)] ^ e >>> 1 ^ t[1 & e];
            e = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK, this.mt[this.N - 1] = this.mt[this.M - 1] ^ e >>> 1 ^ t[1 & e], 
            this.mti = 0;
        }
        return e = this.mt[this.mti++], e ^= e >>> 11, e ^= e << 7 & 2636928640, e ^= e << 15 & 4022730752, 
        (e ^= e >>> 18) >>> 0;
    }, r.prototype.genrand_int31 = function() {
        return this.genrand_int32() >>> 1;
    }, r.prototype.genrand_real1 = function() {
        return this.genrand_int32() * (1 / 4294967295);
    }, r.prototype.random = function() {
        return this.pythonCompatibility && (this.skip && this.genrand_int32(), this.skip = !0), 
        this.genrand_int32() * (1 / 4294967296);
    }, r.prototype.genrand_real3 = function() {
        return (this.genrand_int32() + .5) * (1 / 4294967296);
    }, r.prototype.genrand_res53 = function() {
        return 1 / 9007199254740992 * (67108864 * (this.genrand_int32() >>> 5) + (this.genrand_int32() >>> 6));
    }, r.prototype.LOG4 = Math.log(4), r.prototype.SG_MAGICCONST = 1 + Math.log(4.5), 
    r.prototype.exponential = function(e) {
        if (1 != arguments.length) throw new SyntaxError("exponential() must  be called with 'lambda' parameter");
        var t = this.random();
        return -Math.log(t) / e;
    }, r.prototype.gamma = function(e, t) {
        if (2 != arguments.length) throw new SyntaxError("gamma() must be called with alpha and beta parameters");
        if (!(1 < e)) {
            if (1 == e) {
                for (var n = this.random(); n <= 1e-7; ) n = this.random();
                return -Math.log(n) * t;
            }
            for (;;) {
                n = this.random();
                var r = (Math.E + e) / Math.E, a = r * n;
                if (a <= 1) l = Math.pow(a, 1 / e); else l = -Math.log((r - a) / e);
                s = this.random();
                if (1 < a) {
                    if (s <= Math.pow(l, e - 1)) break;
                } else if (s <= Math.exp(-l)) break;
            }
            return l * t;
        }
        for (var o = Math.sqrt(2 * e - 1), i = e - this.LOG4, u = e + o; ;) {
            var s;
            if (!((s = this.random()) < 1e-7 || .9999999 < n)) {
                var l, c = 1 - this.random(), d = Math.log(s / (1 - s)) / o, f = s * s * c, p = i + u * d - (l = e * Math.exp(d));
                if (0 <= p + this.SG_MAGICCONST - 4.5 * f || p >= Math.log(f)) return l * t;
            }
        }
    }, r.prototype.normal = function(e, t) {
        if (2 != arguments.length) throw new SyntaxError("normal() must be called with mu and sigma parameters");
        var n = this.lastNormal;
        if (this.lastNormal = NaN, !n) {
            var r = 2 * this.random() * Math.PI, a = Math.sqrt(-2 * Math.log(1 - this.random()));
            n = Math.cos(r) * a, this.lastNormal = Math.sin(r) * a;
        }
        return e + n * t;
    }, r.prototype.pareto = function(e) {
        if (1 != arguments.length) throw new SyntaxError("pareto() must be called with alpha parameter");
        var t = this.random();
        return 1 / Math.pow(1 - t, 1 / e);
    }, r.prototype.triangular = function(e, t, n) {
        if (3 != arguments.length) throw new SyntaxError("triangular() must be called with lower, upper and mode parameters");
        var r = (n - e) / (t - e), a = this.random();
        return a <= r ? e + Math.sqrt(a * (t - e) * (n - e)) : t - Math.sqrt((1 - a) * (t - e) * (t - n));
    }, r.prototype.uniform = function(e, t) {
        if (2 != arguments.length) throw new SyntaxError("uniform() must be called with lower and upper parameters");
        return e + this.random() * (t - e);
    }, r.prototype.weibull = function(e, t) {
        if (2 != arguments.length) throw new SyntaxError("weibull() must be called with alpha and beta parameters");
        var n = 1 - this.random();
        return e * Math.pow(-Math.log(n), 1 / t);
    }, "undefined" == typeof window && "undefined" != typeof module && module.exports && (module.exports = r);
    var D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var o = m.registerNamespace("jQuery");
        if (D.fluid = m, D.init = function(e) {
            var t = e ? {
                components: {
                    audioSystem: {
                        options: {
                            model: e
                        }
                    }
                }
            } : void 0;
            return D.enviro(t);
        }, D.ALL_CHANNELS = 32, D.OUT_UGEN_ID = "flocking-out", D.PI = Math.PI, D.TWOPI = 2 * Math.PI, 
        D.HALFPI = Math.PI / 2, D.LOG01 = Math.log(.1), D.LOG001 = Math.log(.001), D.ROOT2 = Math.sqrt(2), 
        D.rates = {
            AUDIO: "audio",
            CONTROL: "control",
            SCHEDULED: "scheduled",
            DEMAND: "demand",
            CONSTANT: "constant"
        }, m.registerNamespace("flock.debug"), D.debug.failHard = !0, D.browser = function() {
            if ("undefined" == typeof navigator) return {};
            var e, t, n = navigator.userAgent.toLowerCase(), r = {};
            return (t = {
                browser: (e = /(chrome)[ \/]([\w.]+)/.exec(n) || /(webkit)[ \/]([\w.]+)/.exec(n) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(n) || /(msie) ([\w.]+)/.exec(n) || n.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(n) || [])[1] || "",
                version: e[2] || "0"
            }).browser && (r[t.browser] = !0, r.version = t.version), r.chrome ? r.webkit = !0 : r.webkit && (r.safari = !0), 
            r;
        }, m.registerNamespace("flock.platform"), D.platform.isBrowser = "undefined" != typeof window, 
        D.platform.hasRequire = "undefined" != typeof require, D.platform.os = D.platform.isBrowser ? window.navigator.platform : require("os").platform(), 
        D.platform.isLinux = -1 < D.platform.os.indexOf("Linux"), D.platform.isAndroid = D.platform.isLinux && -1 < D.platform.os.indexOf("arm"), 
        D.platform.isIOS = "iPhone" === D.platform.os || "iPad" === D.platform.os || "iPod" === D.platform.os, 
        D.platform.isMobile = D.platform.isAndroid || D.platform.isIOS, D.platform.browser = D.browser(), 
        D.platform.isWebAudio = "undefined" != typeof AudioContext || "undefined" != typeof webkitAudioContext, 
        D.platform.audioEngine = D.platform.isBrowser ? "webAudio" : "unknown", D.platform.browser && void 0 !== D.platform.browser.version) {
            var e = D.platform.browser.version.indexOf(".");
            D.platform.browser.majorVersionNumber = Number(e < 0 ? D.platform.browser.version : D.platform.browser.version.substring(0, e));
        }
        D.shim = {
            URL: D.platform.isBrowser ? window.URL || window.webkitURL || window.msURL : void 0
        }, D.requireModule = function(e, t) {
            if (D.platform.isBrowser) return window[t || e];
            if (D.platform.hasRequire) {
                var n = D.requireModule.paths[e] || e, r = require(n);
                return t ? r[t] : r;
            }
        }, D.requireModule.paths = {
            webarraymath: "../third-party/webarraymath/js/webarraymath.js",
            Random: "../third-party/simjs/js/random-0.26.js"
        }, D.noOp = function() {}, D.isIterable = function(e) {
            var t = typeof e;
            return e && void 0 !== e.length && "string" != t && "function" != t;
        }, D.hasValue = function(e, t) {
            var n = !1;
            for (var r in e) if (e[r] === t) {
                n = !0;
                break;
            }
            return n;
        }, D.hasTag = function(e, t) {
            return !(!e || !t) && (e.tags && -1 < e.tags.indexOf(t));
        }, D.randomValue = function(e, t) {
            var n = t - e;
            return Math.random() * n + e;
        }, D.randomAudioValue = function() {
            return 2 * Math.random() - 1;
        }, D.fillBuffer = function(e, t) {
            for (var n = 0; n < e.length; n++) e[n] = t(n, e);
            return e;
        }, D.fillBufferWithValue = function(e, t) {
            for (var n = 0; n < e.length; n++) e[n] = t;
            return e;
        }, D.generateBuffer = function(e, t) {
            var n = new Float32Array(e);
            return D.fillBuffer(n, t);
        }, D.generateBufferWithValue = function(e, t) {
            var n = new Float32Array(e);
            return D.fillBufferWithValue(n, t);
        }, D.generate = function(e, t) {
            var n = "number" == typeof e;
            return ("function" == typeof t ? n ? D.generateBuffer : D.fillBuffer : n ? D.generateBufferWithValue : D.fillBufferWithValue)(e, t);
        }, D.generate.silence = function(e) {
            return new Float32Array(e);
        }, D.clearBuffer = function(e) {
            for (var t = 0; t < e.length; t++) e[t] = 0;
            return e;
        }, D.reverse = function(e) {
            if (!e || !D.isIterable(e) || e.length < 2) return e;
            if ("function" == typeof e.reverse) return e.reverse();
            for (var t, n = 0, r = e.length - 1; n < r; n++, r--) t = e[n], e[n] = e[r], e[r] = t;
            return e;
        }, D.randomIndex = function(e) {
            var t = e.length - 1;
            return Math.round(Math.random() * t);
        }, D.arrayChoose = function(e, t) {
            return t = t || D.randomIndex, (e = m.makeArray(e))[t(e)];
        }, D.choose = function(e, t) {
            return D.isIterable(e) ? D.arrayChoose(e, t) : e[D.arrayChoose(e.keys, t)];
        }, D.shuffle = function(e) {
            for (var t = e.length - 1; 0 < t; t -= 1) {
                var n = Math.floor(Math.random() * (t + 1)), r = e[t];
                e[t] = e[n], e[n] = r;
            }
            return e;
        }, D.normalize = function(e, t, n) {
            n = n || e;
            var r, a, o, i = 0;
            for (t = void 0 === t ? 1 : t, r = 0; r < e.length; r++) i < (a = Math.abs(e[r])) && (i = a);
            if (0 < i) for (r = 0; r < e.length; r++) o = e[r], n[r] = o / i * t;
            return n;
        }, D.generateFourierTable = function(e, o, i, u, s) {
            return u *= D.TWOPI, D.generateBuffer(e, function(e) {
                var t, n, r, a = 0;
                for (t = 0; t < i; t++) n = s ? s[t] : 1, r = (t + 1) * (e * o), a += n * Math.cos(r + u);
                return a;
            });
        }, D.generateNormalizedFourierTable = function(e, t, n, r, a) {
            var o = D.generateBuffer(n, function(e) {
                return a(e + 1);
            }), i = D.generateFourierTable(e, t, n, r, o);
            return D.normalize(i);
        }, D.fillTable = function(e, t) {
            var n = "number" == typeof e ? e : e.length;
            return t(e, D.TWOPI / n);
        }, D.tableGenerators = {
            sin: function(e, t) {
                return D.generateBuffer(e, function(e) {
                    return Math.sin(e * t);
                });
            },
            tri: function(e, t) {
                return D.generateNormalizedFourierTable(e, t, 1e3, 1, function(e) {
                    return e % 2 == 0 ? 0 : 1 / (e * e);
                });
            },
            saw: function(e, t) {
                return D.generateNormalizedFourierTable(e, t, 10, -.25, function(e) {
                    return 1 / e;
                });
            },
            square: function(e, t) {
                return D.generateNormalizedFourierTable(e, t, 10, -.25, function(e) {
                    return e % 2 == 0 ? 0 : 1 / e;
                });
            },
            hann: function(n) {
                return D.generateBuffer(n, function(e) {
                    var t = Math.sin(Math.PI * e / n);
                    return t * t;
                });
            },
            sinWindow: function(t) {
                return D.generateBuffer(t, function(e) {
                    return Math.sin(Math.PI * e / t);
                });
            }
        }, D.range = function(e) {
            var t, n, r = {
                max: Number.NEGATIVE_INFINITY,
                min: 1 / 0
            };
            for (t = 0; t < e.length; t++) (n = e[t]) > r.max && (r.max = n), n < r.min && (r.min = n);
            return r;
        }, D.scale = function(e) {
            if (e) {
                var t, n = D.range(e), r = (n.max - n.min) / 2, a = (n.max + n.min) / 2;
                for (t = 0; t < e.length; t++) e[t] = (e[t] - a) / r;
                return e;
            }
        }, D.copyBuffer = function(e, t, n) {
            void 0 === n && (n = e.length);
            var r, a, o = new Float32Array(n - t);
            for (r = t, a = 0; r < n; r++, a++) o[a] = e[r];
            return o;
        }, D.copyToBuffer = function(e, t) {
            for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) t[r] = e[r];
        }, D.parseMidiString = function(e) {
            if (!e || e.length < 2) return NaN;
            var t = (e = e.toLowerCase()).charAt(1), n = "#" === t || "b" === t ? 2 : 1, r = e.substring(0, n);
            return 12 * Number(e.substring(n)) + D.midiFreq.noteNames[r];
        }, D.midiFreq = function(e, t, n, r) {
            return t = void 0 === t ? 440 : t, n = void 0 === n ? 69 : n, r = r || 12, "string" == typeof e && (e = D.parseMidiString(e)), 
            t * Math.pow(2, 1 * (e - n) / r);
        }, D.midiFreq.noteNames = {
            "b#": 0,
            c: 0,
            "c#": 1,
            db: 1,
            d: 2,
            "d#": 3,
            eb: 3,
            e: 4,
            "e#": 5,
            f: 5,
            "f#": 6,
            gb: 6,
            g: 7,
            "g#": 8,
            ab: 8,
            a: 9,
            "a#": 10,
            bb: 10,
            b: 11,
            cb: 11
        }, D.interpolate = {
            none: function(e, t) {
                return t[0 | (e %= t.length)];
            },
            linear: function(e, t) {
                var n = t.length, r = 0 | (e %= n), a = (1 + r) % n, o = e - r, i = t[r];
                return i + o * (t[a] - i);
            },
            hermite: function(e, t) {
                var n = t.length, r = Math.floor(e), a = r % n, o = e - r, i = (1 + a) % n, u = (2 + a) % n, s = t[0 < a ? a - 1 : n - 1], l = t[a], c = t[i], d = .5 * (c - s), f = l - c, p = d + f, m = p + f + .5 * (t[u] - l);
                return ((m * o - (p + m)) * o + d) * o + l;
            }
        }, D.interpolate.cubic = D.interpolate.hermite, D.log = {
            fail: function(e) {
                m.log(m.logLevel.FAIL, e);
            },
            warn: function(e) {
                m.log(m.logLevel.WARN, e);
            },
            debug: function(e) {
                m.log(m.logLevel.INFO, e);
            }
        }, D.fail = function(e) {
            if (D.debug.failHard) throw e = e instanceof Error ? e : new Error(e);
            D.log.fail(e);
        }, D.pathParseError = function(e, t, n) {
            var r = "Error parsing path '" + t + "'. Segment '" + n + "' could not be resolved.";
            D.fail(r);
        }, D.get = function(e, t) {
            if (!e) return m.getGlobalValue(t);
            if (1 === arguments.length && "string" == typeof e) return m.getGlobalValue(e);
            if (t && "" !== t) {
                var n, r = "" === t ? [] : String(t).split("."), a = e[r[0]];
                for (n = 1; n < r.length; n++) {
                    if (null == a) return void D.pathParseError(e, t, r[n - 1]);
                    a = a[r[n]];
                }
                return a;
            }
        }, D.set = function(e, t, n) {
            if (e && t && "" !== t) {
                var r, a = String(t).split("."), o = a.length, i = a[0];
                for (r = 1; r < o; r++) {
                    if ("object" != typeof (e = e[i])) return void D.fail("Error while setting a value at path '" + t + "'. A non-container object was found at segment '" + i + "'. Value: " + e);
                    void 0 === e[i = a[r]] && (e[i] = {});
                }
                return e[i] = n;
            }
        }, D.invoke = function(e, t, n) {
            var r = "function" == typeof e ? e : D.get(e, t);
            if ("function" == typeof r) return r.apply(null, n);
            D.fail("Path '" + t + "' does not resolve to a function.");
        }, D.input = {}, D.input.shouldExpand = function(e) {
            return D.parse.specialInputs.indexOf(e) < 0;
        }, D.input.pathExpander = function(e) {
            var t, n = m.model.parseEL(e), r = n.length - 1, a = [];
            for (t = 0; t < r; t++) {
                var o = n[t], i = n[t + 1];
                if (a.push(o), "model" === i || "options" === i) {
                    a = a.concat(n.slice(t + 1, r));
                    break;
                }
                isNaN(Number(i)) && a.push("inputs");
            }
            return a.push(n[r]), a.join(".");
        }, D.input.expandPaths = function(e) {
            var t, n, r, a = {};
            for (t in e) n = D.input.pathExpander(t), r = e[t], a[n] = r;
            return a;
        }, D.input.expandPath = function(e) {
            return "string" == typeof e ? D.input.pathExpander(e) : D.input.expandPaths(e);
        }, D.input.getValueForPath = function(e, t) {
            t = D.input.expandPath(t);
            var n = D.get(e, t);
            return D.hasTag(n, "flock.ugen.valueType") ? n.inputs.value : n;
        }, D.input.getValuesForPathArray = function(e, t) {
            var n, r, a = {};
            for (n = 0; n < t.length; n++) a[r = t[n]] = D.input.get(e, r);
            return a;
        }, D.input.getValuesForPathObject = function(e, t) {
            var n;
            for (n in t) t[n] = D.input.get(e, n);
            return t;
        }, D.input.get = function(e, t) {
            return "string" == typeof t ? D.input.getValueForPath(e, t) : D.isIterable(t) ? D.input.getValuesForPathArray(e, t) : D.input.getValuesForPathObject(e, t);
        }, D.input.resolveValue = function(e, t, n, r, a, o, i) {
            if ("string" == typeof n) {
                var u = m.extractEL(n, D.input.valueExpressionSpec);
                if (u) {
                    var s = D.input.getValueForPath(e, u);
                    return void 0 === s && D.log.debug("The value expression '" + n + "' resolved to undefined. If this isn't expected, check to ensure that your path is valid."), 
                    s;
                }
            }
            return D.input.shouldExpand(a) && i ? i(n, t, r, o) : n;
        }, D.input.valueExpressionSpec = {
            ELstyle: "${}"
        }, D.input.setValueForPath = function(e, t, n, r, a) {
            t = D.input.expandPath(t);
            var o = D.get(e, t), i = t.lastIndexOf("."), u = t.slice(i + 1), s = -1 < i ? D.get(e, t.slice(0, t.lastIndexOf(".inputs"))) : r, l = D.input.resolveValue(e, t, n, s, u, o, a);
            return D.set(e, t, l), s && s.onInputChanged && s.onInputChanged(u), l;
        }, D.input.setValuesForPaths = function(e, t, n, r) {
            var a, o, i, u = {};
            for (a in t) o = t[a], i = D.input.set(e, a, o, n, r), u[a] = i;
            return u;
        }, D.input.set = function(e, t, n, r, a) {
            return "string" == typeof t ? D.input.setValueForPath(e, t, n, r, a) : D.input.setValuesForPaths(e, t, r, a);
        }, m.defaults("flock.audioSystem", {
            gradeNames: [ "fluid.modelComponent" ],
            channelRange: {
                min: 1,
                max: 32
            },
            outputBusRange: {
                min: 2,
                max: 1024
            },
            inputBusRange: {
                min: 1,
                max: 32
            },
            model: {
                rates: {
                    audio: 44100,
                    control: 689.0625,
                    scheduled: 0,
                    demand: 0,
                    constant: 0
                },
                blockSize: 64,
                numBlocks: 16,
                chans: 2,
                numInputBuses: 2,
                numBuses: 8,
                bufferSize: "@expand:flock.audioSystem.defaultBufferSize()"
            },
            modelRelay: [ {
                target: "rates.control",
                singleTransform: {
                    type: "fluid.transforms.binaryOp",
                    left: "{that}.model.rates.audio",
                    operator: "/",
                    right: "{that}.model.blockSize"
                }
            }, {
                target: "numBlocks",
                singleTransform: {
                    type: "fluid.transforms.binaryOp",
                    left: "{that}.model.bufferSize",
                    operator: "/",
                    right: "{that}.model.blockSize"
                }
            }, {
                target: "chans",
                singleTransform: {
                    type: "fluid.transforms.limitRange",
                    input: "{that}.model.chans",
                    min: "{that}.options.channelRange.min",
                    max: "{that}.options.channelRange.max"
                }
            }, {
                target: "numInputBuses",
                singleTransform: {
                    type: "fluid.transforms.limitRange",
                    input: "{that}.model.numInputBuses",
                    min: "{that}.options.inputBusRange.min",
                    max: "{that}.options.inputBusRange.max"
                }
            }, {
                target: "numBuses",
                singleTransform: {
                    type: "fluid.transforms.free",
                    func: "flock.audioSystem.clampNumBuses",
                    args: [ "{that}.model.numBuses", "{that}.options.outputBusRange", "{that}.model.chans" ]
                }
            } ]
        }), D.audioSystem.clampNumBuses = function(e, t, n) {
            return e = Math.max(e, Math.max(n, t.min)), e = Math.min(e, t.max);
        }, D.audioSystem.defaultBufferSize = function() {
            return D.platform.isMobile ? 8192 : D.platform.browser.mozilla ? 2048 : 1024;
        }, m.defaults("flock.busManager", {
            gradeNames: [ "fluid.modelComponent" ],
            model: {
                nextAvailableBus: {
                    input: 0,
                    interconnect: 0
                }
            },
            members: {
                buses: {
                    expander: {
                        funcName: "flock.enviro.createAudioBuffers",
                        args: [ "{audioSystem}.model.numBuses", "{audioSystem}.model.blockSize" ]
                    }
                }
            },
            invokers: {
                acquireNextBus: {
                    funcName: "flock.busManager.acquireNextBus",
                    args: [ "{arguments}.0", "{that}.buses", "{that}.applier", "{that}.model", "{audioSystem}.model.chans", "{audioSystem}.model.numInputBuses" ]
                },
                reset: {
                    changePath: "nextAvailableBus",
                    value: {
                        input: 0,
                        interconnect: 0
                    }
                }
            },
            listeners: {
                "onDestroy.reset": "{that}.reset()"
            }
        }), D.busManager.acquireNextBus = function(e, t, n, r, a, o) {
            var i = r.nextAvailableBus[e];
            if (void 0 !== i) {
                var u = i + a, s = a + o;
                if ("interconnect" === e && (u += o, s = t.length), !(s <= u)) return n.change("nextAvailableBus." + e, ++i), 
                u;
                D.fail("Unable to aquire a bus. There are insufficient buses available. Please use an existing bus or configure additional buses using the enviroment's numBuses and numInputBuses parameters.");
            } else D.fail("An invalid bus type was specified when invoking flock.busManager.acquireNextBus(). Type was: " + e);
        }, m.defaults("flock.outputManager", {
            gradeNames: [ "fluid.modelComponent" ],
            model: {
                audioSettings: "{audioSystem}.model"
            },
            invokers: {
                start: "{that}.events.onStart.fire()",
                stop: "{that}.events.onStop.fire()",
                reset: "{that}.events.onReset.fire"
            },
            events: {
                onStart: "{enviro}.events.onStart",
                onStop: "{enviro}.events.onStop",
                onReset: "{enviro}.events.onReset"
            }
        }), m.defaults("flock.nodeListComponent", {
            gradeNames: "fluid.component",
            members: {
                nodeList: "@expand:flock.nodeList()"
            },
            invokers: {
                insert: "flock.nodeList.insert({that}.nodeList, {arguments}.0, {arguments}.1)",
                head: "flock.nodeList.head({that}.nodeList, {arguments}.0)",
                tail: "flock.nodeList.tail({that}.nodeList, {arguments}.0)",
                before: "flock.nodeList.before({that}.nodeList, {arguments}.0, {arguments}.1)",
                after: "flock.nodeList.after({that}.nodeList, {arguments}.0, {arguments}.1)",
                remove: "flock.nodeList.remove({that}.nodeList, {arguments}.0)",
                replace: "flock.nodeList.after({that}.nodeList, {arguments}.0, {arguments}.1)"
            }
        }), m.defaults("flock.enviro", {
            gradeNames: [ "fluid.modelComponent", "flock.nodeListComponent", "fluid.resolveRootSingle" ],
            singleRootType: "flock.enviro",
            isGlobalSingleton: !0,
            members: {
                buffers: {},
                bufferSources: {}
            },
            components: {
                asyncScheduler: {
                    type: "flock.scheduler.async"
                },
                audioSystem: {
                    type: "flock.audioSystem"
                },
                busManager: {
                    type: "flock.busManager"
                }
            },
            model: {
                isPlaying: !1
            },
            invokers: {
                generate: {
                    funcName: "flock.enviro.generate",
                    args: [ "{busManager}.buses", "{audioSystem}.model", "{that}.nodeList.nodes" ]
                },
                start: "flock.enviro.start({that}.model, {that}.events.onStart.fire)",
                play: "{that}.start",
                stop: "flock.enviro.stop({that}.model, {that}.events.onStop.fire)",
                reset: "{that}.events.onReset.fire()",
                registerBuffer: "flock.enviro.registerBuffer({arguments}.0, {that}.buffers)",
                releaseBuffer: "flock.enviro.releaseBuffer({arguments}.0, {that}.buffers)",
                saveBuffer: {
                    funcName: "flock.enviro.saveBuffer",
                    args: [ "{arguments}.0", "{that}.buffers", "{audioSystem}" ]
                }
            },
            events: {
                onStart: null,
                onPlay: "{that}.events.onStart",
                onStop: null,
                onReset: null
            },
            listeners: {
                "onCreate.registerSingleton": {
                    funcName: "flock.enviro.registerGlobalSingleton",
                    args: [ "{that}" ]
                },
                "onStart.updatePlayState": {
                    changePath: "isPlaying",
                    value: !0
                },
                "onStop.updatePlayState": {
                    changePath: "isPlaying",
                    value: !1
                },
                "onReset.stop": "{that}.stop()",
                "onReset.clearScheduler": {
                    priority: "after:stop",
                    func: "{asyncScheduler}.clearAll"
                },
                "onReset.clearAllNodes": {
                    priority: "after:clearScheduler",
                    func: "flock.nodeList.clearAll",
                    args: [ "{that}.nodeList" ]
                },
                "onReset.resetBusManager": {
                    priority: "after:clearAllNodes",
                    func: "{busManager}.reset"
                },
                "onReset.clearBuffers": {
                    priority: "after:resetBusManager",
                    funcName: "fluid.clear",
                    args: [ "{that}.buffers" ]
                }
            }
        }), D.enviro.registerGlobalSingleton = function(e) {
            e.options.isGlobalSingleton && (D.environment = D.enviro.shared = e);
        }, D.enviro.registerBuffer = function(e, t) {
            e.id && (t[e.id] = e);
        }, D.enviro.releaseBuffer = function(e, t) {
            e && delete t["string" == typeof e ? e : e.id];
        }, D.enviro.saveBuffer = function(e, t, n) {
            if ("string" == typeof e && (e = {
                buffer: e
            }), "string" == typeof e.buffer) {
                var r = e.buffer;
                e.buffer = t[r], e.buffer.id = r;
            }
            return e.type = e.type || "wav", e.path = e.path || e.buffer.id + "." + e.type, 
            e.format = e.format || "int16", n.bufferWriter.save(e, e.buffer);
        }, D.enviro.generate = function(e, t, n) {
            D.evaluate.clearBuses(e, t.numBuses, t.blockSize), D.evaluate.synths(n);
        }, D.enviro.start = function(e, t) {
            e.isPlaying || t();
        }, D.enviro.stop = function(e, t) {
            e.isPlaying && t();
        }, D.enviro.createAudioBuffers = function(e, t) {
            var n, r = [];
            for (n = 0; n < e; n++) r[n] = new Float32Array(t);
            return r;
        }, m.defaults("flock.autoEnviro", {
            gradeNames: [ "fluid.component" ],
            members: {
                enviro: "@expand:flock.autoEnviro.initEnvironment()"
            }
        }), D.autoEnviro.initEnvironment = function() {
            return D.environment ? D.environment : D.init();
        }, m.defaults("flock.silentEnviro", {
            gradeNames: "flock.enviro",
            listeners: {
                "onCreate.insertGainNode": {
                    funcName: "flock.silentEnviro.insertOutputGainNode",
                    args: "{that}"
                }
            }
        }), D.silentEnviro.insertOutputGainNode = function(e) {
            e.audioSystem.nativeNodeManager && e.audioSystem.nativeNodeManager.createOutputNode({
                node: "Gain",
                params: {
                    gain: 0
                }
            });
        }, m.defaults("flock.node", {
            gradeNames: [ "flock.autoEnviro", "fluid.modelComponent" ],
            addToEnvironment: "tail",
            model: {},
            members: {
                generatorFunc: "@expand:fluid.getGlobalValue({that}.options.invokers.generate.funcName)"
            },
            components: {
                enviro: "{flock.enviro}"
            },
            invokers: {
                play: {
                    funcName: "flock.node.play",
                    args: [ "{that}", "{that}.enviro", "{that}.addToEnvironment" ]
                },
                pause: "{that}.removeFromEnvironment()",
                addToEnvironment: {
                    funcName: "flock.node.addToEnvironment",
                    args: [ "{that}", "{arguments}.0", "{that}.enviro.nodeList" ]
                },
                removeFromEnvironment: {
                    funcName: "flock.node.removeFromEnvironment",
                    args: [ "{that}", "{that}.enviro.nodeList" ]
                },
                isPlaying: {
                    funcName: "flock.nodeList.isNodeActive",
                    args: [ "{that}.enviro.nodeList", "{that}" ]
                },
                generate: {
                    funcName: "fluid.identity"
                }
            },
            listeners: {
                "onCreate.addToEnvironment": {
                    func: "{that}.addToEnvironment",
                    args: [ "{that}.options.addToEnvironment" ]
                },
                "onDestroy.removeFromEnvironment": {
                    func: "{that}.removeFromEnvironment"
                }
            }
        }), D.node.addToEnvironment = function(e, t, n) {
            if (void 0 === t && (t = e.options.addToEnvironment), null != t && !1 !== t) {
                var r = typeof t;
                "string" == r && "head" === t || "tail" === t ? D.nodeList[t](n, e) : "number" == r ? D.nodeList.insert(n, e, t) : D.nodeList.tail(n, e);
            }
        }, D.node.removeFromEnvironment = function(e, t) {
            D.nodeList.remove(t, e);
        }, D.node.play = function(e, t, n) {
            -1 === t.nodeList.nodes.indexOf(e) && n(e.options.addToEnvironment || "tail");
            t.model.isPlaying || t.play();
        }, m.defaults("flock.noteTarget", {
            gradeNames: "fluid.component",
            noteChanges: {
                on: {
                    "env.gate": 1
                },
                off: {
                    "env.gate": 0
                }
            },
            invokers: {
                set: {
                    funcName: "fluid.notImplemented"
                },
                noteOn: {
                    func: "{that}.events.noteOn.fire"
                },
                noteOff: {
                    func: "{that}.events.noteOff.fire"
                },
                noteChange: {
                    funcName: "flock.noteTarget.change",
                    args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
                }
            },
            events: {
                noteOn: null,
                noteOff: null
            },
            listeners: {
                "noteOn.handleChange": [ "{that}.noteChange(on, {arguments}.0)" ],
                "noteOff.handleChange": [ "{that}.noteChange(off, {arguments}.0)" ]
            }
        }), D.noteTarget.change = function(e, t, n) {
            var r = e.options.noteChanges[t], a = o.extend({}, r, n);
            e.set(a);
        }, D.bufferDesc = function() {
            throw new Error("flock.bufferDesc is not defined. Did you forget to include the buffers.js file?");
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.nodeList = function() {
            return {
                nodes: [],
                namedNodes: {}
            };
        }, D.nodeList.insert = function(e, t, n) {
            return n < 0 && (n = 0), e.nodes.splice(n, 0, t), D.nodeList.registerNode(e, t), 
            n;
        }, D.nodeList.registerNode = function(e, t) {
            var n = t.name || t.id;
            n && (e.namedNodes[n] = t);
        }, D.nodeList.head = function(e, t) {
            return D.nodeList.insert(e, t, 0);
        }, D.nodeList.before = function(e, t, n) {
            var r = e.nodes.indexOf(n);
            return D.nodeList.insert(e, t, r);
        }, D.nodeList.after = function(e, t, n) {
            var r = e.nodes.indexOf(n) + 1;
            return D.nodeList.insert(e, t, r);
        }, D.nodeList.tail = function(e, t) {
            var n = e.nodes.length;
            return D.nodeList.insert(e, t, n);
        }, D.nodeList.unregisterNode = function(e, t) {
            var n = t.name || t.id;
            n && delete e.namedNodes[n];
        }, D.nodeList.isNodeActive = function(e, t) {
            return -1 < e.nodes.indexOf(t);
        }, D.nodeList.remove = function(e, t) {
            if (e) {
                var n = e.nodes.indexOf(t);
                return -1 < n && (e.nodes.splice(n, 1), D.nodeList.unregisterNode(e, t)), n;
            }
        }, D.nodeList.replace = function(e, t, n) {
            var r = e.nodes.indexOf(n);
            return r < 0 ? D.nodeList.tail(e, t) : (e.nodes[r] = t, D.nodeList.unregisterNode(e, n), 
            D.nodeList.registerNode(e, t), r);
        }, D.nodeList.clearAll = function(e) {
            for (var t in e.nodes.length = 0, e.namedNodes) delete e.namedNodes[t];
        }, D.ugenNodeList = function() {
            return D.nodeList();
        }, D.ugenNodeList.insertTree = function(e, t, n) {
            var r, a, o = t.inputs;
            for (r in o) a = o[r], D.isUGen(a) && (n = D.ugenNodeList.insertTree(e, a, n), n++);
            return D.nodeList.insert(e, t, n);
        }, D.ugenNodeList.removeTree = function(e, t) {
            var n, r, a = t.inputs;
            for (n in a) r = a[n], D.isUGen(r) && D.ugenNodeList.removeTree(e, r);
            return D.nodeList.remove(e, t);
        }, D.ugenNodeList.tailTree = function(e, t) {
            var n = e.nodes.length;
            return D.ugenNodeList.insertTree(e, t, n);
        }, D.ugenNodeList.replaceTree = function(e, t, n) {
            if (!n) return D.ugenNodeList.tailTree(e, t);
            var r = D.ugenNodeList.removeTree(e, n);
            return D.ugenNodeList.insertTree(e, t, r), r;
        }, D.ugenNodeList.swapTree = function(e, t, n, r) {
            return r ? (D.ugenNodeList.reattachInputs(e, t, n, r), D.ugenNodeList.replaceInputs(e, t, n, r)) : t.inputs = n.inputs, 
            D.nodeList.replace(e, t, n);
        }, D.ugenNodeList.reattachInputs = function(e, t, n, r) {
            for (var a in n.inputs) r.indexOf(a) < 0 ? D.ugenNodeList.removeTree(e, n.inputs[a]) : t.inputs[a] = n.inputs[a];
        }, D.ugenNodeList.replaceInputs = function(e, t, n, r) {
            for (var a in t.inputs) r.indexOf(a) < 0 && D.ugenNodeList.replaceTree(e, t.inputs[a], n.inputs[a]);
        }, D.makeUGens = function(e, t, n, r, a) {
            e || m.log(m.logLevel.IMPORTANT, "Warning: An empy synthDef was found while instantiating a unit generator tree.Did you forget to include a 'synthDef' option for your Synth?");
            var o = t === D.rates.SCHEDULED || t === D.rates.DEMAND;
            return D.parse.synthDef(e, r, {
                rate: t,
                overrideRate: o,
                visitors: [ D.makeUGens.visitor(n) ],
                buffers: r.buffers,
                buses: r.busManager.buses,
                audioSettings: a || r.audioSystem.model
            });
        }, D.makeUGens.visitor = function(t) {
            return function(e) {
                D.nodeList.tail(t, e);
            };
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.evaluate = {
            synth: function(e) {
                D.evaluate.ugens(e.nodeList.nodes);
            },
            synthValue: function(e) {
                return D.evaluate.synth(e), e.out && (e.value = e.out.model.value), e.value;
            },
            synthModel: function(e) {
                var t = D.evaluate.synthValue(e);
                e.applier.change("value", t);
            },
            synths: function(e) {
                for (var t = 0; t < e.length; t++) {
                    var n = e[t];
                    n.generatorFunc(n);
                }
            },
            synthGroup: function(e) {
                D.evaluate.synths(e.nodeList.nodes);
            },
            clearBuses: function(e, t, n) {
                for (var r = 0; r < t; r++) for (var a = e[r], o = 0; o < n; o++) a[o] = 0;
            },
            ugens: function(e) {
                for (var t, n = 0; n < e.length; n++) void 0 !== (t = e[n]).gen && t.gen(t.model.blockSize);
            }
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        m.defaults("flock.band", {
            gradeNames: [ "fluid.component" ],
            synthGrade: "flock.noteTarget",
            invokers: {
                play: {
                    func: "{that}.events.onPlay.fire"
                },
                pause: {
                    func: "{that}.events.onPause.fire"
                },
                set: {
                    func: "{that}.events.onSet.fire"
                },
                getSynths: {
                    funcName: "fluid.queryIoCSelector",
                    args: [ "{that}", "{that}.options.synthGrade" ]
                }
            },
            events: {
                onPlay: null,
                onPause: null,
                onSet: null
            },
            distributeOptions: [ {
                source: "{that}.options.synthListeners",
                removeSource: !0,
                target: "{that flock.synth}.options.listeners"
            } ],
            synthListeners: {
                "{band}.events.onPlay": {
                    func: "{that}.play"
                },
                "{band}.events.onPause": {
                    func: "{that}.pause"
                },
                "{band}.events.onSet": {
                    func: "{that}.set"
                }
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    m.defaults("flock.synth.frameRate", {
        gradeNames: [ "flock.synth.value" ],
        rate: "scheduled",
        fps: 60,
        members: {
            audioSettings: {
                rates: {
                    scheduled: "{that}.options.fps"
                }
            }
        }
    });
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        m.defaults("flock.synth.group", {
            gradeNames: [ "flock.node", "flock.noteTarget" ],
            methodEventMap: {
                onSet: "set"
            },
            members: {
                nodeList: "@expand:flock.nodeList()"
            },
            invokers: {
                play: "{that}.events.onPlay.fire",
                pause: "{that}.events.onPause.fire",
                set: "{that}.events.onSet.fire",
                get: "flock.synth.group.get({arguments}, {that}.nodeList.nodes)",
                head: "flock.synth.group.head({arguments}.0, {that})",
                tail: "flock.synth.group.tail({arguments}.0, {that})",
                insert: "flock.synth.group.insert({arguments}.0, {arguments}.1, {that})",
                before: "flock.synth.group.before({arguments}.0, {arguments}.1, {that})",
                after: "flock.synth.group.after({arguments}.0, {arguments}.1, {that})",
                remove: "{that}.events.onRemove.fire",
                generate: {
                    funcName: "flock.evaluate.synthGroup",
                    args: [ "{that}" ]
                }
            },
            events: {
                onSet: null,
                onGen: null,
                onPlay: null,
                onPause: null,
                onInsert: null,
                onRemove: null
            },
            listeners: {
                "onInsert.bindMethods": {
                    funcName: "flock.synth.group.bindMethods",
                    args: [ "{arguments}.0", "{that}.options.methodEventMap", "{that}.events", "addListener" ]
                },
                "onInsert.removeNode": {
                    priority: "after:bindMethods",
                    funcName: "flock.synth.group.removeNodeFromEnvironment",
                    args: [ "{arguments}.0" ]
                },
                "onRemove.bindMethods": {
                    funcName: "flock.synth.group.bindMethods",
                    args: [ "{arguments}.0", "{that}.options.methodEventMap", "{that}.events", "removeListener" ]
                },
                "onRemove.removeNode": {
                    priority: "after:bindMethods",
                    this: "{that}.nodeList",
                    method: "remove",
                    args: [ "{arguments}.0" ]
                }
            }
        }), D.synth.group.head = function(e, t) {
            D.nodeList.head(t.nodeList, e), t.events.onInsert.fire(e);
        }, D.synth.group.tail = function(e, t) {
            D.nodeList.tail(t.nodeList, e), t.events.onInsert.fire(e);
        }, D.synth.group.insert = function(e, t, n) {
            D.nodeList.insert(n.nodeList, e, t), n.events.onInsert.fire(e);
        }, D.synth.group.before = function(e, t, n) {
            D.nodeList.before(n.nodeList, e, t), n.events.onInsert.fire(e);
        }, D.synth.group.after = function(e, t, n) {
            D.nodeList.after(n.nodeList, e, t), n.events.onInsert.fire(e);
        }, D.synth.group.removeNodeFromEnvironment = function(e) {
            e.removeFromEnvironment();
        }, D.synth.group.get = function(e, t) {
            var n = t[t.length - 1];
            return n.get.apply(n, e);
        }, D.synth.group.input = function(e, t, n) {
            return (1 < e.length ? n : t).apply(null, e);
        }, D.synth.group.bindMethods = function(e, t, n, r) {
            for (var a in t) {
                var o = e[t[a]];
                (0, n[a][r])(o);
            }
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        m.defaults("flock.modelSynth", {
            gradeNames: "flock.synth",
            model: {
                inputs: {},
                value: void 0
            },
            modelListeners: {
                inputs: [ {
                    funcName: "flock.modelSynth.updateUGens",
                    args: [ "{that}.set", "{that}.options.ugens", "{change}" ]
                } ]
            },
            invokers: {
                generate: {
                    funcName: "flock.evaluate.synthModel"
                }
            }
        }), D.modelSynth.updateUGens = function(e, t, n) {
            var r = {};
            D.modelSynth.flattenModel("", n.value, r), e(r);
        }, D.modelSynth.shouldFlattenValue = function(e) {
            return m.isPrimitive(e) || D.isIterable(e) || e.ugen;
        }, D.modelSynth.flattenModel = function(e, t, n) {
            for (var r in t) {
                var a = t[r], o = m.pathUtil.composePath(e, r.toString());
                D.modelSynth.shouldFlattenValue(a) ? n[o] = a : D.modelSynth.flattenModel(o, a, n);
            }
            return n;
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var i = m.registerNamespace("jQuery");
        m.defaults("flock.synth.polyphonic", {
            gradeNames: [ "flock.synth.group" ],
            maxVoices: 16,
            amplitudeNormalizer: "static",
            amplitudeKey: "env.sustain",
            noteSpecs: "{that}.options.noteChanges",
            distributeOptions: {
                source: "{that}.options.voiceAllocatorOptions",
                target: "{that flock.synth.voiceAllocator}.options",
                removeSource: !0
            },
            voiceAllocatorOptions: {
                synthDef: "{polyphonic}.options.synthDef",
                maxVoices: "{polyphonic}.options.maxVoices",
                amplitudeNormalizer: "{polyphonic}.options.amplitudeNormalizer",
                amplitudeKey: "{polyphonic}.options.amplitudeKey",
                listeners: {
                    "onCreateVoice.addVoiceToTail": {
                        funcName: "flock.nodeList.tail",
                        args: [ "{polyphonic}.nodeList", "{arguments}.0" ]
                    }
                }
            },
            components: {
                voiceAllocator: {
                    type: "flock.synth.voiceAllocator.lazy"
                }
            },
            invokers: {
                noteChange: {
                    funcName: "flock.synth.polyphonic.noteChange",
                    args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
                },
                createVoice: {
                    func: "{voiceAllocator}.createVoice",
                    args: [ "{that}.options", "{that}.insert" ]
                }
            },
            listeners: {
                "noteOn.handleChange": [ {
                    funcName: "flock.synth.polyphonic.noteOn",
                    args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
                } ],
                "noteOff.handleChange": [ {
                    funcName: "flock.synth.polyphonic.noteOff",
                    args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
                } ]
            }
        }), D.synth.polyphonic.noteChange = function(e, t, n, r) {
            var a = e.options.noteChanges[t], o = i.extend({}, a, r);
            n.set(o);
        }, D.synth.polyphonic.noteOn = function(e, t, n) {
            var r = e.voiceAllocator.getFreeVoice();
            return e.voiceAllocator.activeVoices[t] && e.noteOff(t), e.voiceAllocator.activeVoices[t] = r, 
            e.noteChange("on", r, n), r;
        }, D.synth.polyphonic.noteOff = function(e, t, n) {
            var r = e.voiceAllocator.activeVoices[t];
            return r ? (e.noteChange("off", r, n), delete e.voiceAllocator.activeVoices[t], 
            e.voiceAllocator.freeVoices.push(r), r) : null;
        }, m.defaults("flock.synth.voiceAllocator", {
            gradeNames: [ "fluid.component" ],
            maxVoices: 16,
            amplitudeNormalizer: "static",
            amplitudeKey: "env.sustain",
            members: {
                activeVoices: {},
                freeVoices: []
            },
            invokers: {
                createVoice: {
                    funcName: "flock.synth.voiceAllocator.createVoice",
                    args: [ "{that}.options", "{that}.events.onCreateVoice.fire" ]
                }
            },
            events: {
                onCreateVoice: null
            }
        }), D.synth.voiceAllocator.createVoice = function(e, t) {
            var n, r = D.synth({
                synthDef: e.synthDef,
                addToEnvironment: !1
            }), a = e.amplitudeNormalizer, o = e.amplitudeKey;
            return a && ("function" == typeof a ? a(r, o) : "static" === a && (n = 1 / e.maxVoices, 
            r.set(o, n))), t(r), r;
        }, m.defaults("flock.synth.voiceAllocator.lazy", {
            gradeNames: [ "flock.synth.voiceAllocator" ],
            invokers: {
                getFreeVoice: {
                    funcName: "flock.synth.voiceAllocator.lazy.get",
                    args: [ "{that}.freeVoices", "{that}.activeVoices", "{that}.createVoice", "{that}.options.maxVoices" ]
                }
            }
        }), D.synth.voiceAllocator.lazy.get = function(e, t, n, r) {
            return 1 < e.length ? e.pop() : Object.keys(t).length > r ? null : n();
        }, m.defaults("flock.synth.voiceAllocator.pool", {
            gradeNames: [ "flock.synth.voiceAllocator" ],
            invokers: {
                getFreeVoice: "flock.synth.voiceAllocator.pool.get({that}.freeVoices)"
            }
        }), D.synth.voiceAllocator.pool.get = function(e) {
            if (0 < e.length) return e.pop();
        }, D.synth.voiceAllocator.pool.allocateVoices = function(e, t, n) {
            for (var r = 0; r < n; r++) e[r] = t();
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    m.defaults("flock.synth", {
        gradeNames: [ "flock.node", "flock.noteTarget" ],
        rate: D.rates.AUDIO,
        addToEnvironment: !0,
        mergePolicy: {
            ugens: "nomerge"
        },
        ugens: {
            expander: {
                funcName: "flock.makeUGens",
                args: [ "{that}.options.synthDef", "{that}.rate", "{that}.nodeList", "{that}.enviro", "{that}.audioSettings" ]
            }
        },
        members: {
            rate: "{that}.options.rate",
            audioSettings: "{that}.enviro.audioSystem.model",
            nodeList: "@expand:flock.nodeList()",
            out: "{that}.options.ugens"
        },
        model: {
            blockSize: "@expand:flock.synth.calcBlockSize({that}.rate, {that}.enviro.audioSystem.model)"
        },
        invokers: {
            set: {
                funcName: "flock.synth.set",
                args: [ "{that}", "{that}.nodeList.namedNodes", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            },
            get: {
                funcName: "flock.input.get",
                args: [ "{that}.nodeList.namedNodes", "{arguments}.0" ]
            },
            generate: {
                funcName: "flock.evaluate.synth",
                args: [ "{that}" ]
            }
        }
    }), D.synth.createUGenTree = function(e, t, n) {
        return new D.UGenTree(e, t, n);
    }, D.synth.calcBlockSize = function(e, t) {
        return e === D.rates.AUDIO ? t.blockSize : 1;
    }, D.synth.set = function(a, e, t, n, o) {
        return D.input.set(e, t, n, void 0, function(e, t, n, r) {
            return D.synth.ugenValueParser(a, e, r, o);
        });
    }, D.synth.input = function(e, t, n) {
        var r = e[0];
        return r ? "string" == typeof r ? e.length < 2 ? t(r) : n.apply(null, e) : D.isIterable(r) ? t(r) : n.apply(null, e) : void 0;
    }, D.synth.ugenValueParser = function(e, t, n, r) {
        if (null == t) return n;
        var a, o, i, u = D.parse.ugenDef(t, e.enviro, {
            audioSettings: e.audioSettings,
            buses: e.enviro.busManager.buses,
            buffers: e.enviro.buffers
        }), s = D.isIterable(u) ? u : void 0 !== u ? [ u ] : [], l = D.isIterable(n) ? n : void 0 !== n ? [ n ] : [], c = Math.min(s.length, l.length), d = r ? "swapTree" : "replaceTree";
        for (a = 0; a < c; a++) o = D.ugenNodeList[d](e.nodeList, s[a], l[a]);
        for (i = a; i < s.length; i++) o++, D.ugenNodeList.insertTree(e.nodeList, s[i], o);
        for (i = a; i < l.length; i++) D.ugenNodeList.removeTree(e.nodeList, l[i]);
        return u;
    };
    D = (m = m || require("infusion")).registerNamespace("flock");
    m.defaults("flock.synth.value", {
        gradeNames: [ "flock.synth" ],
        rate: "demand",
        addToEnvironment: !1,
        invokers: {
            generate: {
                funcName: "flock.evaluate.synthValue"
            }
        }
    });
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        function e() {
            var a = [], r = {
                state: "pending",
                value: void 0,
                resolve: function(e) {
                    t("resolve", e), r.state = "fulfilled";
                },
                reject: function(e) {
                    t("reject", e), r.state = "rejected";
                },
                then: function(e, t) {
                    a ? a.push({
                        resolve: e,
                        reject: t
                    }) : ("fulfilled" === r.state ? e : t)(r.value);
                    return this;
                },
                safe: {
                    then: function(e, t) {
                        return r.then(e, t), this;
                    }
                }
            };
            function t(e, n) {
                r.value = n, r.then = "reject" === e ? function(e, t) {
                    return t(n), this;
                } : function(e) {
                    return e(n), this;
                }, r.resolve = r.reject = function() {
                    throw new Error("Promise already completed");
                }, function(e, t) {
                    var n, r;
                    for (n = 0; n < a.length; n++) (r = a[n])[e] && r[e](t);
                    a = null;
                }(e, n);
            }
            return r;
        }
        m.defaults("flock.promise", {
            gradeNames: [ "fluid.component" ],
            members: {
                promise: {
                    expander: {
                        funcName: "flock.promise.make"
                    }
                }
            }
        }), D.promise.make = function() {
            return new e();
        }, D.bufferDesc = function(e, t, n) {
            return (D.platform.isWebAudio && e instanceof AudioBuffer ? D.bufferDesc.fromAudioBuffer : D.isIterable(e) ? D.bufferDesc.fromChannelArray : D.bufferDesc.expand)(e, t, n);
        }, D.bufferDesc.inferFormat = function(e, t, n) {
            var r = e.format, a = e.data;
            return r.sampleRate = t || r.sampleRate || 44100, r.numChannels = n || r.numChannels || e.data.channels.length, 
            r.numSampleFrames = r.numSampleFrames || 0 < a.channels.length ? a.channels[0].length : 0, 
            r.duration = r.numSampleFrames / r.sampleRate, e;
        }, D.bufferDesc.fromChannelArray = function(e, t, n) {
            e instanceof Float32Array && (e = [ e ]);
            var r = {
                container: {},
                format: {
                    numChannels: n,
                    sampleRate: t,
                    numSampleFrames: e[0].length
                },
                data: {
                    channels: e
                }
            };
            return D.bufferDesc.inferFormat(r, t, n);
        }, D.bufferDesc.expand = function(e, t, n) {
            if ((e = e || {
                data: {
                    channels: []
                }
            }).container = e.container || {}, e.format = e.format || {}, e.format.numChannels = n || e.format.numChannels || e.data.channels.length, 
            e.data && e.data.channels && (1 === e.format.numChannels && 1 !== e.data.channels.length && (e.data.channels = [ e.data.channels ]), 
            e.format.numChannels !== e.data.channels.length)) throw new Error("The specified number of channels does not match the actual channel data. numChannels was: " + e.format.numChannels + " but the sample data contains " + e.data.channels.length + " channels.");
            return D.bufferDesc.inferFormat(e, t, n);
        }, D.bufferDesc.fromAudioBuffer = function(e) {
            var t, n = {
                container: {},
                format: {
                    sampleRate: e.sampleRate,
                    numChannels: e.numberOfChannels,
                    numSampleFrames: e.length,
                    duration: e.duration
                },
                data: {
                    channels: []
                }
            };
            for (t = 0; t < e.numberOfChannels; t++) n.data.channels.push(e.getChannelData(t));
            return n;
        }, D.bufferDesc.toAudioBuffer = function(e, t) {
            for (var n = e.createBuffer(t.format.numChannels, t.format.numSampleFrames, t.format.sampleRate), r = 0; r < t.format.numChannels; r++) n.copyToChannel(t.data.channels[r], r);
            return n;
        }, m.defaults("flock.bufferSource", {
            gradeNames: [ "fluid.modelComponent" ],
            sampleRate: "{enviro}.audioSystem.model.sampleRate",
            model: {
                state: "start",
                src: null
            },
            components: {
                bufferPromise: {
                    createOnEvent: "onRefreshPromise",
                    type: "flock.promise",
                    options: {
                        listeners: {
                            "onCreate.bindPromiseEvents": {
                                this: "{that}.promise",
                                method: "then",
                                args: [ "{bufferSource}.events.afterFetch.fire", "{bufferSource}.events.onError.fire" ]
                            }
                        }
                    }
                }
            },
            invokers: {
                get: {
                    funcName: "flock.bufferSource.get",
                    args: [ "{that}", "{arguments}.0" ]
                },
                set: {
                    funcName: "flock.bufferSource.set",
                    args: [ "{that}", "{arguments}.0" ]
                },
                error: {
                    funcName: "flock.bufferSource.error",
                    args: [ "{that}", "{arguments}.0" ]
                }
            },
            listeners: {
                "onCreate.fireRefresh": {
                    funcName: "{that}.events.onRefreshPromise.fire"
                },
                "onRefreshPromise.updateState": {
                    changePath: "state",
                    value: "start"
                },
                "onFetch.updateState": {
                    changePath: "state",
                    value: "in-progress"
                },
                "afterFetch.updateState": {
                    changePath: "state",
                    value: "fetched"
                },
                "afterFetch.fireBufferUpdated": {
                    priority: "after:updateState",
                    funcName: "{that}.events.onBufferUpdated.fire",
                    args: [ "{arguments}.0" ]
                },
                "onBufferUpdated.registerBuffer": {
                    func: "{enviro}.registerBuffer",
                    args: [ "{arguments}.0" ]
                },
                "onError.updateState": {
                    changePath: "state",
                    value: "error"
                }
            },
            events: {
                onRefreshPromise: null,
                onError: null,
                onFetch: null,
                afterFetch: null,
                onBufferUpdated: null
            }
        }), D.bufferSource.get = function(t, n) {
            return "in-progress" === t.model.state || n.src === t.model.src && !n.replace || n.src && ("fetched" !== t.model.state && "errored" !== t.model.state || t.model.src === n.src && !n.replace || t.events.onRefreshPromise.fire(), 
            "start" === t.model.state && (t.model.src = n.src, t.events.onFetch.fire(n), D.audio.decode({
                src: n.src,
                sampleRate: t.options.sampleRate,
                success: function(e) {
                    n.id && (e.id = n.id), t.set(e);
                },
                error: t.error
            }))), t.bufferPromise.promise;
        }, D.bufferSource.set = function(e, t) {
            var n = e.model.state;
            return "start" !== n && "in-progress" !== n || e.bufferPromise.promise.resolve(t), 
            e.bufferPromise.promise;
        }, D.bufferSource.error = function(e, t) {
            return e.bufferPromise.promise.reject(t), e.bufferPromise.promise;
        }, m.defaults("flock.bufferLoader", {
            gradeNames: [ "fluid.component" ],
            bufferDefs: [],
            members: {
                buffers: [],
                bufferDefs: "@expand:flock.bufferLoader.expandBufferDefs({that}.options.bufferDefs)"
            },
            components: {
                enviro: "{flock.enviro}"
            },
            events: {
                afterBuffersLoaded: null,
                onError: null
            },
            listeners: {
                "onCreate.loadBuffers": {
                    funcName: "flock.bufferLoader.loadBuffers",
                    args: [ "{that}" ]
                },
                "onError.logError": {
                    funcName: "flock.log.fail"
                }
            }
        }), D.bufferLoader.idFromURL = function(e) {
            var t = e.lastIndexOf("/"), n = -1 < t ? t + 1 : 0, r = e.lastIndexOf("."), a = -1 < r ? r : e.length;
            return e.substring(n, a);
        }, D.bufferLoader.idsFromURLs = function(e) {
            return m.transform(e, D.bufferLoader.idFromURL);
        }, D.bufferLoader.expandFileSequence = function(e) {
            e = e || [];
            var t, n, r, a = [];
            for (t = 0; t < e.length; t++) n = e[t], r = D.bufferLoader.idFromURL(n), a.push({
                id: r,
                url: n
            });
            return a;
        }, D.bufferLoader.expandBufferDef = function(e) {
            return "string" == typeof e && (e = {
                url: e
            }), void 0 === e.id && void 0 !== e.url && (e.id = D.bufferLoader.idFromURL(e.url)), 
            e;
        }, D.bufferLoader.expandBufferDefs = function(e) {
            return e ? (e = m.makeArray(e), m.transform(e, D.bufferLoader.expandBufferDef)) : [];
        }, D.bufferLoader.loadBuffer = function(e, t, n) {
            try {
                D.parse.bufferForDef(e, t, n.enviro);
            } catch (e) {
                n.events.onError.fire(e.message);
            }
        }, D.bufferLoader.loadBuffers = function(n) {
            var r = 1, a = {
                setBuffer: function(e) {
                    if (n.buffers.push(e), n.buffers.length === n.options.bufferDefs.length) n.events.afterBuffersLoaded.fire(n.buffers); else if (r < n.bufferDefs.length) {
                        var t = n.bufferDefs[r];
                        D.bufferLoader.loadBuffer(t, a, n), r++;
                    }
                }
            };
            D.bufferLoader.loadBuffer(n.bufferDefs[0], a, n);
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var p = m.registerNamespace("jQuery");
        m.registerNamespace("flock.parse"), D.parse.synthDef = function(e, t, n) {
            return e || (e = []), D.parse.synthDef.hasOutUGen(e) || (e = D.parse.synthDef.makeOutUGenDef(e, n)), 
            D.parse.ugenForDef(e, t, n);
        }, D.parse.synthDef.hasOutUGen = function(e) {
            return !D.isIterable(e) && (e.id === D.OUT_UGEN_ID || "flock.ugen.out" === e.ugen || "flock.ugen.valueOut" === e.ugen);
        }, D.parse.synthDef.makeOutUGenDef = function(e, t) {
            return e = {
                id: D.OUT_UGEN_ID,
                ugen: "flock.ugen.valueOut",
                inputs: {
                    sources: e
                }
            }, t.rate === D.rates.AUDIO && (e.ugen = "flock.ugen.out", e.inputs.bus = 0, e.inputs.expand = t.audioSettings.chans), 
            e;
        }, D.parse.makeUGen = function(e, t, n, r) {
            var a, o = r.audioSettings.rates, i = r.audioSettings.blockSize;
            if (e.rate || (e.rate = D.rates.AUDIO), !D.hasValue(D.rates, e.rate) && (D.fail("An invalid rate was specified for a unit generator. ugenDef was: " + m.prettyPrintJSON(e)), 
            !D.debug.failHard)) {
                var u = e.rate;
                e.rate = D.rates.AUDIO, D.log.warn("Overriding invalid unit generator rate. Rate is now '" + e.rate + "'; was: " + m.prettyPrintJSON(u));
            }
            a = e.options && void 0 !== e.options.sampleRate ? e.options.sampleRate : o[e.rate], 
            e.options = p.extend(!0, {}, e.options, {
                sampleRate: a,
                rate: e.rate,
                audioSettings: {
                    rates: o,
                    blockSize: i
                }
            });
            var s, l = e.rate === D.rates.AUDIO ? i : 1;
            if (D.hasTag(e.options, "flock.ugen.multiChannelOutput")) {
                var c = e.options.numOutputs || 1;
                s = [];
                for (var d = 0; d < c; d++) s.push(new Float32Array(l));
            } else s = new Float32Array(l);
            var f = m.copy(e.options);
            return f.buffers = r.buffers, f.buses = r.buses, f.enviro = n, D.invoke(void 0, e.ugen, [ t, s, f ]);
        }, D.parse.reservedWords = [ "id", "ugen", "rate", "inputs", "options" ], D.parse.specialInputs = [ "value", "buffer", "list", "table", "envelope", "durations", "values" ], 
        D.parse.expandInputs = function(e) {
            if (e.inputs) return e;
            var t, n = {};
            for (t in e) -1 === D.parse.reservedWords.indexOf(t) && (n[t] = e[t], delete e[t]);
            return e.inputs = n, e;
        }, D.parse.ugenDefForConstantValue = function(e) {
            return {
                ugen: "flock.ugen.value",
                rate: D.rates.CONSTANT,
                inputs: {
                    value: e
                }
            };
        }, D.parse.expandValueDef = function(e) {
            var t = typeof e;
            if ("number" == t) return D.parse.ugenDefForConstantValue(e);
            if ("object" == t) return e;
            throw new Error("Invalid value type found in ugen definition. UGenDef was: " + m.prettyPrintJSON(e));
        }, D.parse.rateMap = {
            ar: D.rates.AUDIO,
            kr: D.rates.CONTROL,
            sr: D.rates.SCHEDULED,
            dr: D.rates.DEMAND,
            cr: D.rates.CONSTANT
        }, D.parse.expandRate = function(e, t) {
            return e.rate = D.parse.rateMap[e.rate] || e.rate, t.overrideRate && e.rate !== D.rates.CONSTANT && (e.rate = t.rate), 
            e;
        }, D.parse.ugenDef = function(e, t, n) {
            return (D.isIterable(e) ? D.parse.ugensForDefs : D.parse.ugenForDef)(e, t, n);
        }, D.parse.ugenDef.mergeOptions = function(e) {
            var t = D.ugenDefaults(e.ugen) || {};
            return (t = m.copy(t)).options = t.ugenOptions, delete t.ugenOptions, p.extend(!0, {}, t, e);
        }, D.parse.ugensForDefs = function(e, t, n) {
            var r, a = [];
            for (r = 0; r < e.length; r++) a[r] = D.parse.ugenForDef(e[r], t, n);
            return a;
        }, D.parse.ugenForDef = function(e, t, n) {
            t = t || D.environment;
            var r = n = p.extend(!0, {
                audioSettings: t.audioSystem.model,
                buses: t.busManager.buses,
                buffers: t.buffers
            }, n), a = r.visitors, o = r.audioSettings.rates;
            if (e = D.parse.expandValueDef(e), D.isIterable(e)) return D.parse.ugensForDefs(e, t, n);
            e = D.parse.expandInputs(e), D.parse.expandRate(e, n);
            var i, u = (e = D.parse.ugenDef.mergeOptions(e, n)).inputs, s = {};
            for (i in u) {
                var l = u[i];
                null !== l && (s[i] = D.input.shouldExpand(i, e) ? D.parse.ugenForDef(l, t, n) : l);
            }
            if (!e.ugen) throw new Error("Unit generator definition lacks a 'ugen' property; can't initialize the synth graph. Value: " + m.prettyPrintJSON(e));
            var c = D.parse.makeUGen(e, s, t, n);
            if (e.id && (c.id = e.id), c.options.ugenDef = e, a) for (var d = 0; d < a.length; d++) a[d](c, e, o);
            return c;
        }, D.parse.expandBufferDef = function(e) {
            return "string" == typeof e ? {
                id: e
            } : D.isIterable(e) || e.data || e.format ? D.bufferDesc(e) : e;
        }, D.parse.bufferForDef = function(e, t, n) {
            (e = D.parse.expandBufferDef(e)).data && e.data.channels ? (e = D.bufferDesc(e), 
            D.parse.bufferForDef.resolveBuffer(e, t, n)) : D.parse.bufferForDef.resolveDef(e, t, n);
        }, D.parse.bufferForDef.createBufferSource = function(e) {
            return D.bufferSource({
                sampleRate: e.audioSystem.model.sampleRate
            });
        }, D.parse.bufferForDef.findSource = function(e, t) {
            var n;
            return t && e.id ? (n = t.bufferSources[e.id]) || (n = D.parse.bufferForDef.createBufferSource(t), 
            t.bufferSources[e.id] = n) : n = D.parse.bufferForDef.createBufferSource(t), n;
        }, D.parse.bufferForDef.bindToPromise = function(e, t, n) {
            var r = function(e) {
                t.events.onBufferUpdated.addListener(r), n && n.setBuffer(e);
            };
            e.then(r, function(e) {
                throw !e && t.model.src && t.model.src.indexOf(".aif") && (e = "if this is an AIFF file, you might need to include flocking-audiofile-compatibility.js in some browsers."), 
                new Error("Error while resolving buffer " + t.model.src + ": " + e);
            });
        }, D.parse.bufferForDef.resolveDef = function(e, t, n) {
            var r, a = D.parse.bufferForDef.findSource(e, n);
            e.src = e.url || e.src, e.selector && "undefined" != typeof document && (e.src = document.querySelector(e.selector).files[0]), 
            r = a.get(e), D.parse.bufferForDef.bindToPromise(r, a, t);
        }, D.parse.bufferForDef.resolveBuffer = function(e, t, n) {
            var r = D.parse.bufferForDef.findSource(e, n), a = r.set(e);
            D.parse.bufferForDef.bindToPromise(a, r, t);
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.applyDeferred = function(e, t, n) {
            e && (n = void 0 === n ? 0 : n, setTimeout(function() {
                e.apply(null, t);
            }, n));
        }, m.registerNamespace("flock.net"), D.net.readBufferFromUrl = function(e) {
            var t = e.src, n = new XMLHttpRequest();
            n.onreadystatechange = function() {
                if (4 === n.readyState) if (D.net.isXHRSuccessful(n)) e.success(n.response, D.file.parseFileExtension(t)); else {
                    if (!e.error) throw new Error(n.statusText);
                    e.error(n.statusText);
                }
            }, n.open(e.method || "GET", t, !0), n.responseType = e.responseType || "arraybuffer", 
            n.send(e.data);
        }, D.net.isXHRSuccessful = function(e) {
            return 200 === e.status || 0 === e.responseURL.indexOf("file://") && 0 === e.status && e.response;
        }, m.registerNamespace("flock.file"), D.file.mimeTypes = {
            "audio/wav": "wav",
            "audio/x-wav": "wav",
            "audio/wave": "wav",
            "audio/x-aiff": "aiff",
            "audio/aiff": "aiff",
            "sound/aiff": "aiff"
        }, D.file.typeAliases = {
            aif: "aiff",
            wave: "wav"
        }, D.file.parseFileExtension = function(e) {
            var t, n = e.lastIndexOf(".");
            if (!(n < 0)) return t = (t = e.substring(n + 1)).toLowerCase(), D.file.typeAliases[t] || t;
        }, D.file.parseMIMEType = function(e) {
            return D.file.mimeTypes[e];
        }, D.file.stringToBuffer = function(e) {
            var t, n = e.length, r = new ArrayBuffer(n), a = new Uint8Array(r);
            for (t = 0; t < n; t++) a[t] = e.charCodeAt(t);
            return a.buffer;
        }, D.file.readBufferFromDataUrl = function(t) {
            var e = t.src, n = e.indexOf(","), r = e.substring(0, n), a = e.substring(n + 1), o = r.indexOf(";base64"), i = -1 < o, u = e.indexOf("data:") + 5, s = i ? o : n, l = e.substring(u, s);
            i && (a = atob(a)), D.applyDeferred(function() {
                var e = D.file.stringToBuffer(a);
                t.success(e, D.file.parseMIMEType(l));
            });
        }, D.file.readBufferFromFile = function(t) {
            var e = new FileReader();
            return e.onload = function(e) {
                t.success(e.target.result, D.file.parseFileExtension(t.src.name));
            }, e.readAsArrayBuffer(t.src), e;
        }, m.registerNamespace("flock.audio"), D.audio.loadBuffer = function(e) {
            var t = e.src || e.url;
            t && (t instanceof ArrayBuffer && D.applyDeferred(e.success, [ t, e.type ]), D.audio.loadBuffer.readerForSource(t)(e));
        }, D.audio.loadBuffer.readerForSource = function(e) {
            return "undefined" != typeof File && e instanceof File ? D.file.readBufferFromFile : 0 === e.indexOf("data:") ? D.file.readBufferFromDataUrl : D.net.readBufferFromUrl;
        }, D.audio.decode = function(a) {
            var o = a.success;
            a.success = function(e, t) {
                var n = D.audio.decoderStrategies, r = n[t] || n.default;
                a.decoder && (r = "string" == typeof a.decoder ? m.getGlobalValue(a.decoder) : a.decoder), 
                r({
                    rawData: e,
                    type: t,
                    success: o,
                    error: a.error,
                    sampleRate: a.sampleRate
                });
            }, D.audio.loadBuffer(a);
        }, D.audio.decode.webAudio = function(n) {
            D.webAudio.audioSystem.audioContextSingleton.decodeAudioData(n.rawData, function(e) {
                var t = D.bufferDesc.fromAudioBuffer(e);
                n.success(t);
            }, n.error);
        }, D.audio.decoderStrategies = {
            default: D.audio.decode.webAudio
        }, D.audio.registerDecoderStrategy = function(e, t) {
            if (e) if ("object" != typeof e) "string" == typeof t && (t = m.getGlobalValue(t)), 
            D.audio.decoderStrategies[e] = t; else for (var n in e) D.audio.decoderStrategies[n] = e[n];
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var u = "undefined" != typeof window ? window : "undefined" != typeof self ? self : global;
        for (var e in m.registerNamespace("flock.audio.convert"), D.audio.convert.maxFloatValue = function(e) {
            return 1 - 1 / e.scale;
        }, D.audio.convert.pcm = {
            int8: {
                scale: 128,
                setter: "setInt8",
                width: 1
            },
            int16: {
                scale: 32768,
                setter: "setInt16",
                width: 2
            },
            int32: {
                scale: 2147483648,
                setter: "setInt32",
                width: 4
            },
            float32: {
                scale: 1,
                setter: "setFloat32",
                width: 4
            }
        }, D.audio.convert.pcm) {
            var t = D.audio.convert.pcm[e];
            t.maxFloatValue = D.audio.convert.maxFloatValue(t);
        }
        D.audio.convert.specForPCMType = function(e) {
            var t = "string" == typeof e ? D.audio.convert.pcm[e] : e;
            return t || D.fail("Flocking does not support " + e + " format PCM wave files."), 
            t;
        }, D.audio.convert.floatToInt = function(e, t) {
            var n = Math.min(t.maxFloatValue, e);
            return n = Math.max(-1, n), n *= t.scale, n = Math.round(n);
        }, D.audio.convert.floatsToInts = function(e, t) {
            if (e) {
                for (var n = "Int" + 8 * t.width + "Array", r = new u[n](e.length), a = 0; a < e.length; a++) {
                    var o = e[a], i = D.audio.convert.floatToInt(o, t);
                    r[a] = i;
                }
                return r;
            }
        }, D.audio.convert.intToFloat = function(e, t) {
            return e / t.scale;
        }, D.audio.convert.intsToFloats = function(e, t) {
            if (e) {
                for (var n = new Float32Array(e.length), r = 0; r < e.length; r++) {
                    var a = e[r], o = D.audio.convert.intToFloat(a, t);
                    n[r] = o;
                }
                return n;
            }
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        m.registerNamespace("flock.audio.encode"), D.audio.interleave = function(e) {
            var t, n, r = e.format.numSampleFrames, a = e.data.channels, o = e.format.numChannels, i = new Float32Array(r * o), u = 0;
            for (t = 0; t < r; t++) for (n = 0; n < o; n++) i[u] = a[n][t], u++;
            return i;
        }, D.audio.encode = function(e, t, n) {
            return "wav" !== (t = t || "wav").toLowerCase() && D.fail("Flocking currently only supports encoding WAVE files."), 
            D.audio.encode.wav(e, n);
        }, D.audio.encode.writeFloat32Array = function(e, t, n) {
            for (var r = 0; r < n.length; r++) t.setFloat32(e, n[r], !0), e += 4;
            return t;
        }, D.audio.encode.setString = function(e, t, n) {
            for (var r = 0; r < n.length; r++) e.setUint8(t + r, n.charCodeAt(r));
        }, D.audio.encode.setBytes = function(e, t, n) {
            for (var r = 0; r < n.length; r++) e.setUint8(t + r, n[r]);
        }, D.audio.encode.writeAsPCM = function(e, t, n, r) {
            if ("setFloat32" === e.setter && r instanceof Float32Array) return D.audio.encode.writeFloat32Array(t, n, r);
            for (var a = 0; a < r.length; a++) {
                var o = D.audio.convert.floatToInt(r[a], e);
                n[e.setter](t, o, !0), t += e.width;
            }
            return n;
        }, D.audio.encode.wav = function(e, t) {
            t = t || D.audio.convert.pcm.int16;
            var n = D.audio.convert.specForPCMType(t), r = D.audio.interleave(e), a = e.format.numChannels, o = e.format.sampleRate, i = "setFloat32" !== n.setter, u = 16, s = 1, l = r.length * n.width, c = 8 + l, d = n.width * a, f = 8 * n.width;
            if (2 < a || !i) {
                u += 12, s = 2 < a ? (u += 24, 65534) : (u += 2, 3);
            }
            var p = 12 + u + c, m = new ArrayBuffer(8 + p), g = new DataView(m);
            D.audio.encode.setString(g, 0, "RIFF"), g.setUint32(4, p, !0), D.audio.encode.setString(g, 8, "WAVE"), 
            D.audio.encode.setString(g, 12, "fmt "), g.setUint32(16, u, !0), g.setUint16(20, s, !0), 
            g.setUint16(22, a, !0), g.setUint32(24, o, !0), g.setUint32(28, o * d, !0), g.setUint16(32, d, !0), 
            g.setUint16(34, f, !0);
            var h = 36;
            return 3 === s ? (g.setUint16(h, 0, !0), h += 2, h = D.audio.encode.wav.writeFactChunk(g, h, e.format.numSampleFrames)) : 65534 === s && (g.setUint16(h, 22, !0), 
            h += 2, h = D.audio.encode.wav.additionalFormat(h, g, f, i), h = D.audio.encode.wav.writeFactChunk(g, h, e.format.numSampleFrames)), 
            D.audio.encode.wav.writeDataChunk(n, h, g, r, l), g.buffer;
        }, D.audio.encode.wav.subformats = {
            pcm: new Uint8Array([ 1, 0, 0, 0, 0, 0, 16, 0, 128, 0, 0, 170, 0, 56, 155, 113 ]),
            float: new Uint8Array([ 3, 0, 0, 0, 0, 0, 16, 0, 128, 0, 0, 170, 0, 56, 155, 113 ])
        }, D.audio.encode.wav.additionalFormat = function(e, t, n, r) {
            t.setUint16(e, n, !0), e += 2, t.setUint32(e, 2147483648, !0), e += 4;
            var a = D.audio.encode.wav.subformats[r ? "pcm" : "float"];
            return D.audio.encode.setBytes(t, e, a), e += 16;
        }, D.audio.encode.wav.writeFactChunk = function(e, t, n) {
            return D.audio.encode.setString(e, t, "fact"), t += 4, e.setUint32(t, 4, !0), t += 4, 
            e.setUint32(t, n, !0), t += 4;
        }, D.audio.encode.wav.writeDataChunk = function(e, t, n, r, a) {
            D.audio.encode.setString(n, t, "data"), t += 4, n.setUint32(t, a, !0), t += 4, D.audio.encode.writeAsPCM(e, t, n, r);
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.shim = {
            URL: "undefined" != typeof window ? window.URL || window.webkitURL || window.msURL : void 0
        }, D.worker = function(e) {
            var t, n, r = typeof e;
            if ("function" == r) e = "(" + e.toString() + ")();"; else if ("string" != r) throw new Error("A flock.worker must be initialized with a String or a Function.");
            return t = window.Blob ? (n = new Blob([ e ], {
                type: "text/javascript"
            }), D.shim.URL.createObjectURL(n)) : "data:text/javascript;base64," + window.btoa(e), 
            new Worker(t);
        }, m.registerNamespace("flock.scheduler"), m.defaults("flock.scheduler.clock", {
            gradeNames: [ "fluid.component" ],
            invokers: {
                end: "fluid.mustBeOverridden"
            },
            events: {
                tick: null
            },
            listeners: {
                "onDestroy.end": "{that}.end()"
            }
        }), m.defaults("flock.scheduler.intervalClock", {
            gradeNames: [ "flock.scheduler.clock" ],
            members: {
                scheduled: {}
            },
            invokers: {
                schedule: {
                    funcName: "flock.scheduler.intervalClock.schedule",
                    args: [ "{arguments}.0", "{that}.scheduled", "{that}.events.tick.fire", "{that}.events.onClear.fire" ]
                },
                clear: {
                    funcName: "flock.scheduler.intervalClock.clear",
                    args: [ "{arguments}.0", "{that}.scheduled", "{that}.events.onClear.fire" ]
                },
                clearAll: {
                    funcName: "flock.scheduler.intervalClock.clearAll",
                    args: [ "{that}.scheduled", "{that}.events.onClear.fire" ]
                },
                end: "{that}.clearAll"
            }
        }), D.scheduler.intervalClock.schedule = function(e, t, n) {
            var r = setInterval(function() {
                n(e);
            }, e);
            t[e] = r;
        }, D.scheduler.intervalClock.clear = function(e, t) {
            var n = t[e];
            clearInterval(n), delete t[e];
        }, D.scheduler.intervalClock.clearAll = function(e, t) {
            for (var n in e) D.scheduler.intervalClock.clear(n, e, t);
        }, m.defaults("flock.scheduler.scheduleClock", {
            gradeNames: [ "flock.scheduler.clock" ],
            members: {
                scheduled: []
            },
            invokers: {
                schedule: {
                    funcName: "flock.scheduler.scheduleClock.schedule",
                    args: [ "{arguments}.0", "{that}.scheduled", "{that}.events" ]
                },
                clear: {
                    funcName: "flock.scheduler.scheduleClock.clear",
                    args: [ "{arguments}.0", "{arguments}.1", "{that}.scheduled", "{that}.events.onClear.fire" ]
                },
                clearAll: {
                    funcName: "flock.scheduler.scheduleClock.clearAll",
                    args: [ "{that}.scheduled", "{that}.events.onClear.fire" ]
                },
                end: "{that}.clearAll"
            }
        }), D.scheduler.scheduleClock.schedule = function(e, t, n) {
            var r;
            r = setTimeout(function() {
                clearTimeout(r), n.tick.fire(e);
            }, e), t.push(r);
        }, D.scheduler.scheduleClock.clear = function(e, t, n) {
            -1 < (t = void 0 === t ? n.indexOf(e) : t) && (n.splice(t, 1), clearTimeout(e));
        }, D.scheduler.scheduleClock.clearAll = function(e) {
            for (var t = 0; t < e.length; t++) {
                var n = e[t];
                clearTimeout(n);
            }
            e.length = 0;
        }, m.defaults("flock.scheduler.webWorkerClock", {
            gradeNames: [ "fluid.component" ],
            members: {
                worker: {
                    expander: {
                        funcName: "flock.worker",
                        args: "@expand:fluid.getGlobalValue(flock.scheduler.webWorkerClock.workerImpl)"
                    }
                }
            },
            invokers: {
                postToWorker: {
                    funcName: "flock.scheduler.webWorkerClock.postToWorker",
                    args: [ "{arguments}.0", "{arguments}.1", "{that}.options.messages", "{that}.worker" ]
                },
                schedule: "{that}.postToWorker(schedule, {arguments}.0)",
                clear: "{that}.postToWorker(clear, {arguments}.0)",
                clearAll: "{that}.postToWorker(clearAll)",
                end: "{that}.postToWorker(end)"
            },
            events: {
                tick: null
            },
            listeners: {
                "onCreate.initClock": {
                    funcName: "flock.scheduler.webWorkerClock.init",
                    args: [ "{that}" ]
                },
                "onDestroy.clearAllScheduled": "{that}.clearAll",
                "onDestroy.endWorker": {
                    priority: "after:clearAllScheduled",
                    func: "{that}.end"
                }
            },
            startMsg: {
                msg: "start",
                value: "{that}.options.clockType"
            },
            messages: {
                schedule: {
                    msg: "schedule"
                },
                clear: {
                    msg: "clear"
                },
                clearAll: {
                    msg: "clearAll"
                },
                end: {
                    msg: "end"
                }
            }
        }), D.scheduler.webWorkerClock.init = function(t) {
            t.worker.addEventListener("message", function(e) {
                t.events.tick.fire(e.data.value);
            }, !1), t.worker.postMessage(t.options.startMsg);
        }, D.scheduler.webWorkerClock.postToWorker = function(e, t, n, r) {
            var a = n[e];
            void 0 !== t && (a.value = t), r.postMessage(a);
        }, D.scheduler.webWorkerClock.workerImpl = function() {
            var t = t || {};
            t.worker = t.worker || {}, t.worker.clock = function() {
                var e = {
                    tick: function(e) {
                        self.postMessage({
                            msg: "tick",
                            value: e
                        });
                    }
                };
                return e;
            }, t.worker.intervalClock = function() {
                var n = t.worker.clock();
                return n.scheduled = {}, n.schedule = function(e) {
                    var t = setInterval(function() {
                        n.tick(e);
                    }, e);
                    n.scheduled[e] = t;
                }, n.clear = function(e) {
                    var t = n.scheduled[e];
                    clearInterval(t), delete n.scheduled[e];
                }, n.clearAll = function() {
                    for (var e in n.scheduled) n.clear(e);
                }, n;
            }, t.worker.scheduleClock = function() {
                var n = t.worker.clock();
                return n.scheduled = [], n.schedule = function(e) {
                    var t;
                    t = setTimeout(function() {
                        n.clear(t), n.tick(e);
                    }, e), n.scheduled.push(t);
                }, n.clear = function(e, t) {
                    -1 < (t = void 0 === t ? n.scheduled.indexOf(e) : t) && n.scheduled.splice(t, 1), 
                    clearTimeout(e);
                }, n.clearAll = function() {
                    for (var e = 0; e < n.scheduled.length; e++) {
                        var t = n.scheduled[e];
                        clearTimeout(t);
                    }
                    n.scheduled.length = 0;
                }, n;
            }, self.addEventListener("message", function(e) {
                "start" === e.data.msg ? t.clock = t.worker[e.data.value]() : "end" === e.data.msg ? t.clock && (t.clock.clearAll(), 
                self.close()) : t.clock && t.clock[e.data.msg](e.data.value);
            }, !1);
        }, m.defaults("flock.scheduler.webWorkerIntervalClock", {
            gradeNames: [ "flock.scheduler.webWorkerClock" ],
            clockType: "intervalClock"
        }), m.defaults("flock.scheduler.webWorkerScheduleClock", {
            gradeNames: [ "flock.scheduler.webWorkerClock" ],
            clockType: "scheduleClock"
        }), m.defaults("flock.scheduler", {
            gradeNames: [ "fluid.component" ],
            events: {
                onScheduled: null,
                onFinished: null,
                onClearAll: null
            },
            listeners: {
                "onClearAll.clearClock": [ "{that}.clock.clearAll()" ]
            }
        }), D.scheduler.addListener = function(e, t, n) {
            return t.push(e), n(e), e;
        }, D.scheduler.removeListener = function(e, t, n) {
            if (e) {
                var r = t.indexOf(e);
                -1 < r ? (t.splice(r, 1), n(e)) : e.wrappedListener && D.scheduler.removeListener(e.wrappedListener, t, n);
            }
        }, m.defaults("flock.scheduler.repeat", {
            gradeNames: [ "flock.scheduler" ],
            members: {
                listeners: {}
            },
            components: {
                clock: {
                    type: "flock.scheduler.webWorkerIntervalClock"
                }
            },
            invokers: {
                schedule: {
                    funcName: "flock.scheduler.repeat.schedule",
                    args: [ "{arguments}.0", "{arguments}.1", "{timeConverter}", "{synthContext}", "{that}.listeners", "{that}.events.onScheduled.fire" ]
                },
                clear: "{that}.events.onFinished.fire",
                clearAll: {
                    funcName: "flock.scheduler.repeat.clearAll",
                    args: [ "{that}.listeners", "{that}.events.onFinished.fire", "{that}.events.onClearAll.fire" ]
                },
                clearInterval: {
                    funcName: "flock.scheduler.repeat.clearInterval",
                    args: [ "{arguments}.0", "{that}.listeners", "{that}.events.onFinished.fire" ]
                },
                addIntervalListener: {
                    funcName: "flock.scheduler.repeat.addIntervalListener",
                    args: [ "{arguments}.0", "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.addListener" ]
                },
                removeIntervalListener: {
                    funcName: "flock.scheduler.repeat.removeIntervalListener",
                    args: [ "{arguments}.0", "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.removeListener" ]
                }
            },
            listeners: {
                "onScheduled.addIntervalListener": {
                    func: "{that}.addIntervalListener",
                    args: [ "{arguments}.0", "{arguments}.1" ]
                },
                "onScheduled.scheduleEvent": {
                    priority: "after:addIntervalListener",
                    func: "{that}.clock.schedule",
                    args: [ "{arguments}.0" ]
                },
                "onFinished.removeIntervalListener": {
                    func: "{that}.removeIntervalListener",
                    args: [ "{arguments}.0", "{arguments}.1" ]
                }
            }
        }), D.scheduler.repeat.intervalListeners = function(e, t) {
            return t[e];
        }, D.scheduler.repeat.addIntervalListener = function(e, t, n, r) {
            var a = D.scheduler.repeat.intervalListeners(e, n);
            D.scheduler.addListener(t, a, r);
        }, D.scheduler.repeat.removeIntervalListener = function(e, t, n, r) {
            var a = D.scheduler.repeat.intervalListeners(e, n);
            D.scheduler.removeListener(t, a, r);
        }, D.scheduler.repeat.schedule = function(e, t, n, r, a, o) {
            e = n.value(e), t = D.scheduler.async.prepareListener(t, r);
            var i = D.scheduler.repeat.wrapValueListener(e, t);
            return D.scheduler.repeat.addInterval(e, a), o(e, i), i;
        }, D.scheduler.repeat.wrapValueListener = function(t, n) {
            function e(e) {
                e === t && n(e);
            }
            return e.wrappedListener = n, e;
        }, D.scheduler.repeat.addInterval = function(e, t) {
            var n = t[e];
            n || (n = t[e] = []);
        }, D.scheduler.repeat.clearAll = function(e, t, n) {
            for (var r in e) D.scheduler.repeat.clearInterval(r, e, t);
            n();
        }, D.scheduler.repeat.clearInterval = function(e, t, n) {
            var r = t[e];
            if (r) for (var a = 0; a < r.length; a++) {
                n(e, r[a]);
            }
        }, m.defaults("flock.scheduler.once", {
            gradeNames: [ "flock.scheduler" ],
            members: {
                listeners: []
            },
            components: {
                clock: {
                    type: "flock.scheduler.webWorkerScheduleClock"
                }
            },
            invokers: {
                schedule: {
                    funcName: "flock.scheduler.once.schedule",
                    args: [ "{arguments}.0", "{arguments}.1", "{timeConverter}", "{synthContext}", "{that}.clear", "{that}.events.onScheduled.fire" ]
                },
                clear: "{that}.events.onFinished.fire",
                clearAll: {
                    funcName: "flock.scheduler.once.clearAll",
                    args: [ "{that}.listeners", "{that}.events.onFinished.fire", "{that}.events.onClearAll.fire" ]
                }
            },
            listeners: {
                "onScheduled.addListener": {
                    funcName: "flock.scheduler.addListener",
                    args: [ "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.addListener" ]
                },
                "onScheduled.scheduleEvent": {
                    func: "{that}.clock.schedule",
                    args: [ "{arguments}.0" ]
                },
                "onFinished.removeListener": {
                    funcName: "flock.scheduler.removeListener",
                    args: [ "{arguments}.0", "{that}.listeners", "{that}.clock.events.tick.removeListener" ]
                }
            }
        }), D.scheduler.once.wrapValueListener = function(t, n, r) {
            var a = function(e) {
                e === t && (n(e), r(a));
            };
            return a.wrappedListener = n, a;
        }, D.scheduler.once.schedule = function(e, t, n, r, a, o) {
            e = n.value(e), t = D.scheduler.async.prepareListener(t, r);
            var i = D.scheduler.once.wrapValueListener(e, t, a);
            return o(e, i), i;
        }, D.scheduler.once.clearAll = function(e, t, n) {
            for (var r = 0; r < e.length; r++) t(e[r]);
            n();
        }, m.defaults("flock.scheduler.async", {
            gradeNames: [ "fluid.component" ],
            subSchedulerOptions: {
                components: {
                    timeConverter: "{async}.timeConverter"
                },
                listeners: {
                    "{async}.events.onClear": "{that}.clear()",
                    "{async}.events.onClearAll": "{that}.clearAll()",
                    "{async}.events.onEnd": "{that}.clock.end()"
                }
            },
            distributeOptions: {
                source: "{that}.options.subSchedulerOptions",
                removeSource: !0,
                target: "{that flock.scheduler}.options"
            },
            components: {
                timeConverter: {
                    type: "flock.convert.seconds"
                },
                onceScheduler: {
                    type: "flock.scheduler.once"
                },
                repeatScheduler: {
                    type: "flock.scheduler.repeat"
                },
                synthContext: void 0
            },
            invokers: {
                repeat: {
                    func: "{repeatScheduler}.schedule",
                    args: [ "{arguments}.0", "{arguments}.1" ]
                },
                once: {
                    func: "{onceScheduler}.schedule",
                    args: [ "{arguments}.0", "{arguments}.1" ]
                },
                sequence: {
                    funcName: "flock.scheduler.async.sequence",
                    args: [ "{arguments}.0", "{arguments}.1", "{that}.once" ]
                },
                schedule: {
                    funcName: "flock.scheduler.async.schedule",
                    args: [ "{arguments}.0", "{that}" ]
                },
                clear: "{that}.events.onClear.fire",
                clearAll: "{that}.events.onClearAll.fire",
                end: "{that}.events.onEnd.fire"
            },
            events: {
                onClear: null,
                onClearAll: null,
                onEnd: null
            },
            listeners: {
                "onCreate.scheduleScore": "{that}.schedule({that}.options.score)",
                "onEnd.clearAllEvents": "{that}.clearAll"
            }
        }), D.scheduler.async.sequence = function(e, t, n) {
            for (var r = [], a = 0; a < e.length; a++) {
                var o = n(e[a], t);
                r.push(o);
            }
            return r;
        }, D.scheduler.async.schedule = function(e, t) {
            if (e) {
                e = D.isIterable(e) ? e : [ e ];
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    D.invoke(t, r.interval, [ r.time, r.change ]);
                }
            }
        }, D.scheduler.async.prepareListener = function(e, t) {
            return "function" == typeof e ? e : D.scheduler.async.evaluateChangeSpec(e, t);
        }, D.scheduler.async.getTargetSynth = function(e, t) {
            var n = e.synth;
            return n ? "string" != typeof n ? n : m.get(t, n) : t;
        }, D.scheduler.async.makeSynthUpdater = function(r, a, o, i) {
            return function() {
                for (var e in r) {
                    var t = r[e];
                    o[e] = D.evaluate.synthValue(t);
                }
                var n = D.scheduler.async.getTargetSynth(a, i);
                n ? n.set(o) : D.fail("A target synth named " + a.synth + " could not be found in the specified synthContext. Synth context was: " + i);
            };
        }, D.scheduler.async.evaluateChangeSpec = function(e, t) {
            var n = {}, r = {};
            for (var a in e.values) {
                var o = e.values[a];
                o.synthDef ? n[a] = D.synth.value(o) : r[a] = o;
            }
            return D.scheduler.async.makeSynthUpdater(n, e, r, t);
        }, m.defaults("flock.scheduler.async.tempo", {
            gradeNames: [ "flock.scheduler.async" ],
            bpm: 60,
            components: {
                timeConverter: {
                    type: "flock.convert.beats",
                    options: {
                        bpm: "{tempo}.options.bpm"
                    }
                }
            }
        }), m.registerNamespace("flock.convert"), m.defaults("flock.convert.ms", {
            gradeNames: [ "fluid.component" ],
            invokers: {
                value: "fluid.identity({arguments}.0)"
            }
        }), m.defaults("flock.convert.seconds", {
            gradeNames: [ "fluid.component" ],
            invokers: {
                value: "flock.convert.seconds.toMillis({arguments}.0)"
            }
        }), D.convert.seconds.toMillis = function(e) {
            return 1e3 * e;
        }, m.defaults("flock.convert.beats", {
            gradeNames: [ "fluid.component" ],
            bpm: 60,
            invokers: {
                value: "flock.convert.beats.toMillis({arguments}.0, {that}.options.bpm)"
            }
        }), D.convert.beats.toMillis = function(e, t) {
            return t <= 0 ? 0 : e / t * 6e4;
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        m.registerNamespace("flock.webAudio"), D.webAudio.createNode = function(e, t) {
            var n = t.args ? m.makeArray(t.args) : void 0, r = "create" + t.node, a = r.indexOf("Node");
            -1 < a && (r = r.substring(0, a));
            var o = e[r].apply(e, n);
            return D.webAudio.initNodeParams(e, o, t), D.webAudio.initNodeProperties(o, t), 
            D.webAudio.initNodeInputs(o, t), o;
        }, D.webAudio.setAudioParamValue = function(e, t, n, r) {
            r = r || 0;
            var a = e.currentTime + r;
            t.setValueAtTime(n, a);
        }, D.webAudio.initNodeParams = function(e, t, n) {
            var r = n.params;
            if (t && r) {
                for (var a in r) {
                    var o = t[a], i = r[a];
                    D.webAudio.setAudioParamValue(e, o, i);
                }
                return t;
            }
        }, D.webAudio.safariPropertyProhibitions = [ "channelCount", "channelCountMode" ], 
        D.webAudio.shouldSetProperty = function(e) {
            return !D.platform.browser.safari || D.webAudio.safariPropertyProhibitions.indexOf(e) < 0;
        }, D.webAudio.initNodeProperties = function(e, t) {
            var n = t.props;
            if (n) {
                for (var r in n) {
                    var a = n[r];
                    D.webAudio.shouldSetProperty(r) && (e[r] = a);
                }
                return e;
            }
        }, D.webAudio.connectInput = function(e, t, n, r) {
            n.connect(e, r, t);
        }, D.webAudio.initNodeInputs = function(e, t) {
            var n = t.inputs;
            for (var r in n) {
                var a = n[r], o = parseInt(r, 10);
                a = m.makeArray(a);
                for (var i = 0; i < a.length; i++) {
                    var u = a[i];
                    D.webAudio.connectInput(e, o, u);
                }
            }
        }, m.defaults("flock.webAudio.node", {
            gradeNames: [ "fluid.modelComponent" ],
            members: {
                node: "@expand:flock.webAudio.createNode({audioSystem}.context, {that}.options.nodeSpec)"
            },
            nodeSpec: {
                args: [],
                params: {},
                properties: {}
            }
        }), m.defaults("flock.webAudio.gain", {
            gradeNames: [ "flock.webAudio.node" ],
            members: {
                node: "@expand:flock.webAudio.createNode({audioSystem}.context, {that}.options.nodeSpec)"
            },
            nodeSpec: {
                node: "Gain"
            }
        }), m.defaults("flock.webAudio.scriptProcessor", {
            gradeNames: [ "flock.webAudio.node" ],
            nodeSpec: {
                node: "ScriptProcessor",
                args: [ "{audioSystem}.model.bufferSize", "{audioSystem}.model.numInputBuses", "{audioSystem}.model.chans" ],
                params: {},
                properties: {
                    channelCountMode: "explicit"
                }
            }
        }), m.defaults("flock.webAudio.channelMerger", {
            gradeNames: [ "flock.webAudio.node" ],
            nodeSpec: {
                node: "ChannelMerger",
                args: [ "{audioSystem}.model.numInputBuses" ],
                properties: {
                    channelCountMode: "discrete"
                }
            }
        }), m.defaults("flock.webAudio.outputFader", {
            gradeNames: [ "fluid.component" ],
            fadeDuration: .5,
            gainSpec: {
                node: "Gain",
                params: {
                    gain: 0
                },
                properties: {
                    channelCount: "{flock.enviro}.audioSystem.model.chans",
                    channelCountMode: "explicit"
                }
            },
            members: {
                gainNode: "@expand:flock.webAudio.outputFader.createGainNode({flock.enviro}.audioSystem.nativeNodeManager, {that}.options.gainSpec)",
                context: "{flock.enviro}.audioSystem.context"
            },
            invokers: {
                fadeIn: {
                    funcName: "flock.webAudio.outputFader.fadeIn",
                    args: [ "{that}.context", "{that}.gainNode", "{arguments}.0", "{that}.options.fadeDuration" ]
                },
                fadeTo: {
                    funcName: "flock.webAudio.outputFader.fadeTo",
                    args: [ "{that}.context", "{that}.gainNode", "{arguments}.0", "{that}.options.fadeDuration" ]
                }
            }
        }), D.webAudio.outputFader.createGainNode = function(e, t) {
            return e.createOutputNode(t);
        }, D.webAudio.outputFader.fade = function(e, t, n, r, a) {
            a = a || 0;
            var o = e.currentTime + a;
            D.webAudio.setAudioParamValue(e, t.gain, n), t.gain.linearRampToValueAtTime(r, o);
        }, D.webAudio.outputFader.fadeTo = function(e, t, n, r) {
            D.webAudio.outputFader.fade(e, t, t.gain.value, n, r);
        }, D.webAudio.outputFader.fadeIn = function(e, t, n, r) {
            D.webAudio.outputFader.fade(e, t, 0, n, r);
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        m.defaults("flock.webAudio.audioSystem", {
            gradeNames: [ "flock.audioSystem" ],
            channelRange: {
                min: "@expand:flock.webAudio.audioSystem.calcMinChannels()",
                max: "@expand:flock.webAudio.audioSystem.calcMaxChannels({that}.context.destination)"
            },
            members: {
                context: "@expand:flock.webAudio.audioSystem.createContext()"
            },
            model: {
                rates: {
                    audio: "{that}.context.sampleRate"
                },
                channelCountMode: "explicit",
                channelInterpretation: "discrete"
            },
            modelListeners: {
                chans: {
                    funcName: "flock.webAudio.audioSystem.configureDestination",
                    args: [ "{that}.context.destination", "channelCount", "{change}.value" ]
                },
                channelCountMode: {
                    funcName: "flock.webAudio.audioSystem.configureDestination",
                    args: [ "{that}.context.destination", "channelCountMode", "{change}.value" ]
                },
                channelInterpretation: {
                    funcName: "flock.webAudio.audioSystem.configureDestination",
                    args: [ "{that}.context.destination", "channelInterpretation", "{change}.value" ]
                }
            },
            components: {
                outputManager: {
                    type: "flock.webAudio.outputManager"
                },
                nativeNodeManager: {
                    type: "flock.webAudio.nativeNodeManager"
                },
                inputDeviceManager: {
                    type: "flock.webAudio.inputDeviceManager"
                },
                bufferWriter: {
                    type: "flock.webAudio.bufferWriter"
                }
            }
        }), D.webAudio.audioSystem.createContext = function() {
            var e = D.webAudio.audioSystem;
            return e.audioContextSingleton || (e.audioContextSingleton = new D.shim.AudioContext()), 
            e.audioContextSingleton;
        }, D.webAudio.audioSystem.calcMaxChannels = function(e) {
            return D.platform.browser.safari ? e.channelCount : e.maxChannelCount;
        }, D.webAudio.audioSystem.calcMinChannels = function() {
            return D.platform.browser.safari ? 2 : 1;
        }, D.webAudio.audioSystem.configureDestination = function(e, t, n) {
            D.platform.browser.safari || void 0 === n || (e[t] = n);
        }, m.defaults("flock.webAudio.enviroContextDistributor", {
            gradeNames: [ "fluid.component" ],
            distributeOptions: [ {
                target: "{/ flock.enviro > audioSystem}.options",
                record: {
                    gradeNames: "flock.webAudio.audioSystem"
                }
            } ]
        }), m.constructSingle([], {
            singleRootType: "flock.enviroContextDistributor",
            type: "flock.webAudio.enviroContextDistributor"
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        m.defaults("flock.webAudio.bufferWriter", {
            gradeNames: "fluid.component",
            invokers: {
                save: "flock.webAudio.bufferWriter.saveBuffer({arguments}.0)"
            }
        }), D.webAudio.bufferWriter.saveBuffer = function(t) {
            try {
                var e = D.audio.encode.wav(t.buffer, t.format), n = new Blob([ e ], {
                    type: "audio/wav"
                });
                return D.webAudio.bufferWriter.download(t.path, n), t.success && t.success(e), e;
            } catch (e) {
                t.error ? t.error(e) : D.fail("There was an error while trying to download the buffer named " + t.buffer.id + ". Error: " + e);
            }
        }, D.webAudio.bufferWriter.download = function(e, t) {
            var n = D.shim.URL.createObjectURL(t), r = window.document.createElement("a"), a = document.createEvent("Event");
            r.href = n, r.download = e, a.initEvent("click", !0, !0), r.dispatchEvent(a);
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        m.registerNamespace("flock.webAudio.chrome"), D.webAudio.chrome.getSources = function(n) {
            return MediaStreamTrack.getSources(function(e) {
                var t = m.transform(e, function(e) {
                    return e.deviceId = e.id, e;
                });
                n(t);
            });
        }, D.webAudio.mediaStreamFailure = function(e) {
            var t = "This browser does not support getUserMedia() or the Media Streams API.";
            e ? e(new Error(t)) : m.log(m.logLevel.IMPORTANT, t);
        };
        var e = {
            AudioContext: window.AudioContext || window.webkitAudioContext,
            getUserMedia: function(e, t, n) {
                navigator.mediaDevices ? navigator.mediaDevices.getUserMedia(e).then(t).catch(n) : navigator.getUserMedia ? navigator.getUserMedia(e, t, n) : D.webAudio.mediaStreamFailure(n);
            },
            getMediaDevicesImpl: navigator.getMediaDevices ? navigator.getMediaDevices : void 0 !== window.MediaStreamTrack ? D.webAudio.chrome.getSources : D.webAudio.mediaStreamFailure,
            getMediaDevice: function() {
                D.shim.getMediaDevicesImpl.apply(navigator, arguments);
            }
        };
        t.extend(D.shim, e), m.defaults("flock.webAudio.inputDeviceManager", {
            gradeNames: [ "fluid.component" ],
            invokers: {
                openAudioDevice: {
                    funcName: "flock.webAudio.inputDeviceManager.openAudioDevice",
                    args: [ "{arguments}.0", "{that}.openAudioDeviceWithId", "{that}.openFirstAudioDeviceWithLabel", "{that}.openAudioDeviceWithConstraints" ]
                },
                openAudioDeviceWithConstraints: {
                    funcName: "flock.webAudio.inputDeviceManager.openAudioDeviceWithConstraints",
                    args: [ "{audioSystem}.context", "{enviro}", "{nativeNodeManager}.createMediaStreamInput", "{arguments}.0" ]
                },
                openAudioDeviceWithId: {
                    funcName: "flock.webAudio.inputDeviceManager.openAudioDeviceWithId",
                    args: [ "{arguments}.0", "{that}.openAudioDeviceWithConstraints" ]
                },
                openFirstAudioDeviceWithLabel: {
                    funcName: "flock.webAudio.inputDeviceManager.openFirstAudioDeviceWithLabel",
                    args: [ "{arguments}.0", "{that}.openAudioDeviceWithId" ]
                }
            }
        }), D.webAudio.inputDeviceManager.openAudioDevice = function(e, t, n, r) {
            if (e) {
                if (e.id) return t(e.id);
                if (e.label) return n(e.label);
            }
            return r();
        }, D.webAudio.inputDeviceManager.openAudioDeviceWithId = function(e, t) {
            t({
                audio: {
                    optional: [ {
                        sourceId: e
                    } ]
                }
            });
        }, D.webAudio.inputDeviceManager.openFirstAudioDeviceWithLabel = function(n, r) {
            n && D.shim.getMediaDevices(function(e) {
                var t = e.filter(function(e) {
                    if (e.label.toLowerCase() === n.toLowerCase()) return !0;
                });
                0 < t.length ? r(t[0].deviceId) : m.log(m.logLevel.IMPORTANT, "An audio device named '" + n + "' could not be found.");
            });
        }, D.webAudio.inputDeviceManager.openAudioDeviceWithConstraints = function(e, t, n, r) {
            r = r || {
                audio: !0
            };
            var a = t.busManager.acquireNextBus("input");
            return D.shim.getUserMedia(r, function(e) {
                n(e, a);
            }, function(e) {
                m.log(m.logLevel.IMPORTANT, "An error occurred while trying to access the user's microphone. " + e);
            }), a;
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        m.registerNamespace("flock.midi"), D.midi.requestAccess = function(e, t, n) {
            if (!navigator.requestMIDIAccess) {
                var r = "The Web MIDI API is not available. You may need to enable it in your browser's settings.";
                return m.log(m.logLevel.WARN, r), void n(r);
            }
            navigator.requestMIDIAccess({
                sysex: e
            }).then(t, n);
        }, D.midi.getPorts = function(e) {
            var t = {};
            return D.midi.collectPorts("inputs", e, t), D.midi.collectPorts("outputs", e, t), 
            t;
        }, D.midi.requestPorts = function(n, e) {
            D.midi.requestAccess(!1, function(e) {
                var t = D.midi.getPorts(e);
                n(t);
            }, e);
        }, D.midi.createPortViews = function(e) {
            return m.transform(e, function(e) {
                return {
                    id: e.id,
                    name: e.name,
                    manufacturer: e.manufacturer,
                    state: e.state,
                    connection: e.connection
                };
            });
        }, D.midi.prettyPrintPorts = function(e) {
            return m.prettyPrintJSON({
                inputs: D.midi.createPortViews(e.inputs),
                outputs: D.midi.createPortViews(e.outputs)
            });
        }, D.midi.logPorts = function() {
            D.midi.requestPorts(function(e) {
                var t = D.midi.prettyPrintPorts(e);
                console.log(t);
            }, function(e) {
                console.log(e);
            });
        }, D.midi.collectPorts = function(e, t, n) {
            for (var r = n[e] = n[e] || [], a = t[e].values(), o = a.next(); !o.done; ) r.push(o.value), 
            o = a.next();
            return n;
        }, D.midi.read = function(e) {
            var t, n = e[0], r = 15 & n;
            switch (n >> 4) {
              case 8:
                t = D.midi.read.noteOff;
                break;

              case 9:
                t = 0 < e[2] ? D.midi.read.noteOn : D.midi.read.noteOff;
                break;

              case 10:
                t = D.midi.read.polyAftertouch;
                break;

              case 11:
                t = D.midi.read.controlChange;
                break;

              case 12:
                t = D.midi.read.programChange;
                break;

              case 13:
                t = D.midi.read.channelAftertouch;
                break;

              case 14:
                t = D.midi.read.pitchbend;
                break;

              case 15:
                t = D.midi.read.system;
                break;

              default:
                return D.fail("Received an unrecognized MIDI message: " + m.prettyPrintJSON(e));
            }
            return t(r, e);
        }, D.midi.read.note = function(e, t, n) {
            return {
                type: e,
                channel: t,
                note: n[1],
                velocity: n[2]
            };
        }, D.midi.read.noteOn = function(e, t) {
            return D.midi.read.note("noteOn", e, t);
        }, D.midi.read.noteOff = function(e, t) {
            return D.midi.read.note("noteOff", e, t);
        }, D.midi.read.polyAftertouch = function(e, t) {
            return {
                type: "aftertouch",
                channel: e,
                note: t[1],
                pressure: t[2]
            };
        }, D.midi.read.controlChange = function(e, t) {
            return {
                type: "control",
                channel: e,
                number: t[1],
                value: t[2]
            };
        }, D.midi.read.programChange = function(e, t) {
            return {
                type: "program",
                channel: e,
                program: t[1]
            };
        }, D.midi.read.channelAftertouch = function(e, t) {
            return {
                type: "aftertouch",
                channel: e,
                pressure: t[1]
            };
        }, D.midi.read.twoByteValue = function(e) {
            return e[2] << 7 | e[1];
        }, D.midi.read.pitchbend = function(e, t) {
            return {
                type: "pitchbend",
                channel: e,
                value: D.midi.read.twoByteValue(t)
            };
        }, D.midi.read.system = function(e, t) {
            if (1 === e) return D.midi.messageFailure("quarter frame MTC");
            var n;
            switch (e) {
              case 0:
                n = D.midi.read.sysex;
                break;

              case 2:
                n = D.midi.read.songPointer;
                break;

              case 3:
                n = D.midi.read.songSelect;
                break;

              case 6:
                n = D.midi.read.tuneRequest;
                break;

              case 8:
                n = D.midi.read.clock;
                break;

              case 10:
                n = D.midi.read.start;
                break;

              case 11:
                n = D.midi.read.continue;
                break;

              case 12:
                n = D.midi.read.stop;
                break;

              case 14:
                n = D.midi.read.activeSense;
                break;

              case 15:
                n = D.midi.read.reset;
                break;

              default:
                return D.fail("Received an unrecognized MIDI system message: " + m.prettyPrintJSON(t));
            }
            return n(t);
        }, D.midi.messageFailure = function(e) {
            D.fail("Flocking does not currently support MIDI " + e + " messages.");
        }, D.midi.read.sysex = function(e) {
            var t = 240 === e[0] ? 1 : 0, n = e.length - (247 === e[e.length - 1] ? 1 : 0);
            return {
                type: "sysex",
                data: e instanceof Uint8Array ? e.subarray(t, n) : e.slice(t, n)
            };
        }, D.midi.read.valueMessage = function(e, t) {
            return {
                type: e,
                value: t
            };
        }, D.midi.read.songPointer = function(e) {
            var t = D.midi.read.twoByteValue(e);
            return D.midi.read.valueMessage("songPointer", t);
        }, D.midi.read.songSelect = function(e) {
            return D.midi.read.valueMessage("songSelect", e[1]);
        }, D.midi.read.tuneRequest = function() {
            return {
                type: "tuneRequest"
            };
        }, D.midi.systemRealtimeMessages = [ "tuneRequest", "clock", "start", "continue", "stop", "activeSense", "reset" ], 
        D.midi.createSystemRealtimeMessageReaders = function(e) {
            m.each(e, function(e) {
                D.midi.read[e] = function() {
                    return {
                        type: e
                    };
                };
            });
        }, D.midi.createSystemRealtimeMessageReaders(D.midi.systemRealtimeMessages), m.defaults("flock.midi.system", {
            gradeNames: [ "fluid.component" ],
            sysex: !1,
            members: {
                access: void 0,
                ports: void 0
            },
            invokers: {
                requestAccess: {
                    funcName: "flock.midi.requestAccess",
                    args: [ "{that}.options.sysex", "{that}.events.onAccessGranted.fire", "{that}.events.onAccessError.fire" ]
                },
                refreshPorts: {
                    funcName: "flock.midi.system.refreshPorts",
                    args: [ "{that}", "{that}.access", "{that}.events.onPortsAvailable.fire" ]
                }
            },
            events: {
                onAccessGranted: null,
                onAccessError: null,
                onReady: null,
                onPortsAvailable: null
            },
            listeners: {
                "onCreate.requestAccess": {
                    func: "{that}.requestAccess"
                },
                "onAccessGranted.setAccess": {
                    func: "flock.midi.system.setAccess",
                    args: [ "{that}", "{arguments}.0" ]
                },
                "onAccessGranted.refreshPorts": {
                    priority: "after:setAccess",
                    func: "{that}.refreshPorts"
                },
                "onAccessGranted.fireOnReady": {
                    priority: "after:refreshPorts",
                    func: "{that}.events.onReady.fire",
                    args: [ "{that}.ports)" ]
                },
                "onAccessError.logError": {
                    funcName: "fluid.log",
                    args: [ m.logLevel.WARN, "MIDI Access Error: ", "{arguments}.0" ]
                }
            }
        }), D.midi.system.setAccess = function(e, t) {
            e.access = t;
        }, D.midi.system.refreshPorts = function(e, t, n) {
            e.ports = D.midi.getPorts(t), n(e.ports);
        }, m.defaults("flock.midi.receiver", {
            gradeNames: [ "fluid.component" ],
            events: {
                raw: null,
                message: null,
                note: null,
                noteOn: null,
                noteOff: null,
                control: null,
                program: null,
                aftertouch: null,
                pitchbend: null,
                sysex: null,
                songPointer: null,
                songSelect: null,
                tuneRequest: null,
                clock: null,
                start: null,
                continue: null,
                stop: null,
                activeSense: null,
                reset: null
            }
        }), m.defaults("flock.midi.connection", {
            gradeNames: [ "flock.midi.receiver" ],
            openImmediately: !1,
            sysex: !1,
            distributeOptions: {
                source: "{that}.options.sysex",
                target: "{that > system}.options.sysex"
            },
            ports: 0,
            invokers: {
                sendRaw: {
                    func: "{that}.events.onSendRaw.fire"
                },
                send: {
                    funcName: "flock.midi.connection.send",
                    args: [ "{that}", "{arguments}.0" ]
                },
                open: {
                    funcName: "flock.midi.connection.bind",
                    args: [ "{that}.system.ports", "{that}.options.ports", "{that}.events.onReady.fire", "{that}.events.raw.fire", "{that}.events.onSendRaw" ]
                },
                close: {
                    funcName: "flock.midi.connection.close",
                    args: [ "{that}.system.ports", "{that}.events.raw.fire" ]
                }
            },
            components: {
                system: {
                    type: "flock.midi.system",
                    options: {
                        events: {
                            onReady: "{connection}.events.onPortsAvailable"
                        }
                    }
                }
            },
            events: {
                onPortsAvailable: null,
                onReady: null,
                onError: null,
                onSendRaw: null
            },
            listeners: {
                "onPortsAvailable.open": {
                    funcName: "flock.midi.connection.autoOpen",
                    args: [ "{that}.options.openImmediately", "{that}.open" ]
                },
                "onError.logError": {
                    funcName: "fluid.log",
                    args: [ m.logLevel.WARN, "{arguments}.0" ]
                },
                "raw.fireMidiEvent": {
                    funcName: "flock.midi.connection.fireEvent",
                    args: [ "{arguments}.0", "{that}.events" ]
                },
                "onDestroy.close": "{that}.close()"
            }
        }), D.midi.write = function(e) {
            if ("sysex" === e.type) return D.midi.write.sysex(e);
            switch (e.type) {
              case "noteOn":
                return D.midi.write.note(9, e);

              case "noteOff":
                return D.midi.write.note(8, e);

              case "aftertouch":
                return D.midi.write.aftertouch(e);

              case "control":
                return D.midi.write.controlChange(e);

              case "program":
                return D.midi.write.programChange(e);

              case "pitchbend":
                return D.midi.write.largeValueMessage(14, e.channel, e);

              case "songPointer":
                return D.midi.write.largeValueMessage(15, 2, e);

              case "songSelect":
                return D.midi.write.largeValueMessage(15, 3, e);

              case "tuneRequest":
                return D.midi.write.singleByteMessage(15, 6);

              case "clock":
                return D.midi.write.singleByteMessage(15, 8);

              case "start":
                return D.midi.write.singleByteMessage(15, 10);

              case "continue":
                return D.midi.write.singleByteMessage(15, 11);

              case "stop":
                return D.midi.write.singleByteMessage(15, 12);

              case "activeSense":
                return D.midi.write.singleByteMessage(15, 14);

              case "reset":
                return D.midi.write.singleByteMessage(15, 15);

              default:
                D.fail("Cannot write an unrecognized MIDI message of type '" + e.type + "'.");
            }
        }, D.midi.write.note = function(e, t) {
            return D.midi.write.threeByteMessage(e, t.channel, t.note, t.velocity);
        }, D.midi.write.controlChange = function(e) {
            return D.midi.write.threeByteMessage(11, e.channel, e.number, e.value);
        }, D.midi.write.programChange = function(e) {
            return D.midi.write.twoByteMessage(12, e.channel, e.program);
        }, D.midi.write.aftertouch = function(e) {
            return e.note ? D.midi.write.note(10, e) : D.midi.write.twoByteMessage(13, e.channel, e.pressure);
        }, D.midi.write.singleByteMessage = function(e, t) {
            var n = new Uint8Array(1);
            return n[0] = D.midi.write.statusByte(e, t), n;
        }, D.midi.write.twoByteMessage = function(e, t, n) {
            var r = new Uint8Array(2);
            return r[0] = D.midi.write.statusByte(e, t), r[1] = n, r;
        }, D.midi.write.threeByteMessage = function(e, t, n, r) {
            var a = new Uint8Array(3);
            return a[0] = D.midi.write.statusByte(e, t), a[1] = n, a[2] = r, a;
        }, D.midi.write.largeValueMessage = function(e, t, n) {
            var r = new Uint8Array(3);
            return r[0] = D.midi.write.statusByte(e, t), D.midi.write.twoByteValue(n.value, r, 1), 
            r;
        }, D.midi.write.statusByte = function(e, t) {
            return (e << 4) + t;
        }, D.midi.write.twoByteValue = function(e, t, n) {
            t[n = n || 0] = 127 & e, t[n + 1] = e >> 7 & 127;
        }, D.midi.write.sysex = function(e) {
            240 !== e.data[0] && 247 !== e.data[e.data.length - 1] || D.fail("Sysex payloads should not include framing bytes.");
            var t = e.data, n = t.length, r = new Uint8Array(n + 2);
            return r[0] = 240, r[n + 1] = 247, r.set(t, 1), r;
        }, D.midi.connection.send = function(e, t) {
            var n = D.midi.write(t);
            e.events.onSendRaw.fire(n);
        }, D.midi.connection.autoOpen = function(e, t) {
            e && t();
        }, D.midi.findPorts = function(n, e) {
            e = m.makeArray(e);
            var r = [];
            return m.each(e, function(e) {
                var t = D.midi.findPorts.portFinder(e)(n);
                r = r.concat(t);
            }), r;
        }, D.midi.findPorts.portFinder = function(e) {
            if ("number" == typeof e) return D.midi.findPorts.byIndex(e);
            "string" == typeof e && (e = {
                name: e
            });
            var t = e.id ? D.midi.findPorts.idMatcher(e.id) : e.manufacturer && e.name ? D.midi.findPorts.bothMatcher(e.manufacturer, e.name) : e.manufacturer ? D.midi.findPorts.manufacturerMatcher(e.manufacturer) : D.midi.findPorts.nameMatcher(e.name);
            return function(e) {
                return e.filter(t);
            };
        }, D.midi.findPorts.byIndex = function(n) {
            return function(e) {
                var t = e[n];
                return t ? [ t ] : [];
            };
        }, D.midi.findPorts.lowerCaseContainsMatcher = function(o) {
            return function(e) {
                var t;
                for (var n in o) {
                    var r = e[n], a = o[n];
                    if (!(t = "*" === a || r && -1 < r.toLowerCase().indexOf(a.toLowerCase()))) break;
                }
                return t;
            };
        }, D.midi.findPorts.idMatcher = function(t) {
            return function(e) {
                return e.id === t;
            };
        }, D.midi.findPorts.bothMatcher = function(e, t) {
            return D.midi.findPorts.lowerCaseContainsMatcher({
                manufacturer: e,
                name: t
            });
        }, D.midi.findPorts.manufacturerMatcher = function(e) {
            return D.midi.findPorts.lowerCaseContainsMatcher({
                manufacturer: e
            });
        }, D.midi.findPorts.nameMatcher = function(e) {
            return D.midi.findPorts.lowerCaseContainsMatcher({
                name: e
            });
        }, D.midi.findPorts.eachPortOfType = function(e, t, n) {
            var r = m.makeArray(e);
            m.each(r, function(e) {
                e.type === t && n(e);
            });
        }, D.midi.connection.openPort = function(e, t) {
            if (e.open) {
                var n = e.open();
                t.push(n);
            }
            return t;
        }, D.midi.connection.listen = function(e, t, n) {
            return D.midi.findPorts.eachPortOfType(e, "input", function(e) {
                D.midi.connection.openPort(e, n), e.addEventListener("midimessage", t, !1);
            }), n;
        }, D.midi.connection.stopListening = function(e, t) {
            D.midi.findPorts.eachPortOfType(e, "input", function(e) {
                e.close(), e.removeEventListener("midimessage", t, !1);
            });
        }, D.midi.connection.bindSender = function(e, t, n) {
            var r = m.makeArray(e);
            return m.each(r, function(e) {
                D.midi.connection.openPort(e, n), t.addListener(e.send.bind(e));
            }), n;
        }, D.midi.connection.fireReady = function(e, t) {
            !e || e.length < 1 || Promise.all(e).then(t);
        }, D.midi.connection.bind = function(e, t, n, r, a) {
            t = D.midi.connection.expandPortSpec(t);
            var o = D.midi.findPorts(e.inputs, t.input), i = D.midi.findPorts(e.outputs, t.output), u = [];
            o && 0 < o.length ? D.midi.connection.listen(o, r, u) : void 0 !== t.input && D.midi.connection.logNoMatchedPorts("input", t), 
            i && 0 < i.length ? D.midi.connection.bindSender(i, a, u) : void 0 !== t.output && D.midi.connection.logNoMatchedPorts("output", t), 
            D.midi.connection.fireReady(u, n);
        }, D.midi.connection.close = function(e, t) {
            D.midi.connection.stopListening(e.inputs, t);
        }, D.midi.connection.logNoMatchedPorts = function(e, t) {
            m.log(m.logLevel.WARN, "No matching " + e + " ports were found for port specification: ", t[e]);
        }, D.midi.connection.expandPortSpec = function(e) {
            if (void 0 !== e.input || void 0 !== e.output) return e;
            var t = {
                input: {},
                output: {}
            };
            return "number" == typeof e ? t.input = t.output = e : (D.midi.connection.expandPortSpecProperty("manufacturer", e, t), 
            D.midi.connection.expandPortSpecProperty("name", e, t)), t;
        }, D.midi.connection.expandPortSpecProperty = function(e, t, n) {
            return n.input[e] = n.output[e] = t[e], n;
        }, D.midi.connection.fireEvent = function(e, t) {
            var n = D.midi.read(e.data), r = n.type ? t[n.type] : void 0;
            t.message.fire(n, e), "noteOn" !== n.type && "noteOff" !== n.type || t.note.fire(n, e), 
            r && r.fire(n, e);
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        m.defaults("flock.midi.controller", {
            gradeNames: [ "fluid.component" ],
            members: {
                controlMap: {
                    expander: {
                        funcName: "flock.midi.controller.optimizeMIDIMap",
                        args: [ "{that}.options.controlMap" ]
                    }
                },
                noteMap: {
                    expander: {
                        funcName: "flock.midi.controller.optimizeNoteMap",
                        args: [ "{that}.options.noteMap" ]
                    }
                }
            },
            controlMap: {},
            noteMap: {},
            components: {
                synthContext: {
                    type: "flock.band"
                },
                connection: {
                    type: "flock.midi.connection",
                    options: {
                        ports: {
                            input: "*"
                        },
                        openImmediately: !0
                    }
                }
            },
            invokers: {
                mapControl: {
                    funcName: "flock.midi.controller.mapControl",
                    args: [ "{arguments}.0", "{that}.synthContext", "{that}.controlMap" ]
                },
                mapNote: {
                    funcName: "flock.midi.controller.mapNote",
                    args: [ "{arguments}.0", "{arguments}.1", "{that}.synthContext", "{that}.noteMap" ]
                }
            },
            events: {
                control: "{that}.connection.events.control",
                note: "{that}.connection.events.note",
                noteOn: "{that}.connection.events.noteOn",
                noteOff: "{that}.connection.events.noteOff"
            },
            listeners: {
                "control.map": "{that}.mapControl({arguments}.0)",
                "note.map": "{that}.mapNote(note, {arguments}.0)",
                "noteOn.map": "{that}.mapNote(noteOn, {arguments}.0)",
                "noteOff.map": "{that}.mapNote(noteOff, {arguments}.0)"
            }
        }), D.midi.controller.optimizeMIDIMap = function(e) {
            var r = new Array(127);
            return m.each(e, function(e, t) {
                var n = Number(t);
                r[n] = m.makeArray(e);
            }), r;
        }, D.midi.controller.optimizeNoteMap = function(e) {
            return {
                note: m.makeArray(e.note),
                noteOn: m.makeArray(e.noteOn),
                noteOff: m.makeArray(e.noteOff),
                velocity: m.makeArray(e.velocity)
            };
        }, D.midi.controller.expandControlMapSpec = function(e, t) {
            return t.transform.id = e, t.valuePath = t.valuePath || "value", t.transform.ugen || (t.transform.ugen = "flock.ugen.value"), 
            t;
        }, D.midi.controller.makeValueSynth = function(e, t, n) {
            var r = (n = D.midi.controller.expandControlMapSpec(t, n)).transform, a = n.valuePath;
            D.set(r, a, e);
            var o = D.synth.value({
                synthDef: r
            });
            return n.valuePath = t + "." + a, o;
        }, D.midi.controller.transformValue = function(e, t) {
            var n = t.transform;
            return "function" == typeof n ? n(e) : (t.transformSynth ? t.transformSynth.set(t.valuePath, e) : t.transformSynth = D.midi.controller.makeValueSynth(e, "flock-midi-controller-in", t), 
            t.transformSynth.value());
        }, D.midi.controller.setMappedValue = function(e, t, n) {
            e = void 0 !== t.value ? t.value : t.transform ? D.midi.controller.transformValue(e, t) : e, 
            (n[t.synth] || n).set(t.input, e);
        }, D.midi.controller.mapMIDIValue = function(e, t, n) {
            if (t && !(t.length < 1)) for (var r = 0; r < t.length; r++) {
                var a = t[r];
                D.midi.controller.setMappedValue(e, a, n);
            }
        }, D.midi.controller.mapControl = function(e, t, n) {
            var r = n[e.number], a = e.value;
            D.midi.controller.mapMIDIValue(a, r, t);
        }, D.midi.controller.mapNote = function(e, t, n, r) {
            var a = r[e], o = t.note, i = r.velocity, u = t.velocity;
            D.midi.controller.mapMIDIValue(o, a, n), D.midi.controller.mapMIDIValue(u, i, n);
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        m.defaults("flock.webAudio.nativeNodeManager", {
            gradeNames: [ "fluid.component" ],
            members: {
                outputNode: void 0,
                inputNodes: []
            },
            components: {
                scriptProcessor: {
                    createOnEvent: "onCreateScriptProcessor",
                    type: "flock.webAudio.scriptProcessor",
                    options: {
                        nodeSpec: {
                            inputs: {
                                0: "{inputMerger}"
                            }
                        }
                    }
                },
                merger: {
                    type: "flock.webAudio.channelMerger"
                }
            },
            invokers: {
                connect: "{that}.events.onConnect.fire",
                disconnect: "{that}.events.onDisconnect.fire",
                createNode: {
                    funcName: "flock.webAudio.createNode",
                    args: [ "{audioSystem}.context", "{arguments}.0" ]
                },
                createInputNode: {
                    funcName: "flock.webAudio.nativeNodeManager.createInputNode",
                    args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
                },
                createMediaStreamInput: {
                    funcName: "flock.webAudio.nativeNodeManager.createInputNode",
                    args: [ "{that}", {
                        node: "MediaStreamSource",
                        args: [ "{arguments}.0" ]
                    }, "{arguments}.1" ]
                },
                createMediaElementInput: {
                    funcName: "flock.webAudio.nativeNodeManager.createInputNode",
                    args: [ "{that}", {
                        node: "MediaElementSource",
                        args: [ "{arguments}.0" ]
                    }, "{arguments}.1" ]
                },
                createOutputNode: {
                    funcName: "flock.webAudio.nativeNodeManager.createOutputNode",
                    args: [ "{that}", "{arguments}.0" ]
                },
                insertInput: {
                    funcName: "flock.webAudio.nativeNodeManager.insertInput",
                    args: [ "{that}", "{audioSystem}.model", "{enviro}", "{arguments}.0", "{arguments}.1" ]
                },
                removeInput: {
                    funcName: "flock.webAudio.nativeNodeManager.removeInput",
                    args: [ "{arguments}.0", "{that}.inputNodes" ]
                },
                removeAllInputs: {
                    funcName: "flock.webAudio.nativeNodeManager.removeAllInputs",
                    args: "{that}.inputNodes"
                },
                insertOutput: {
                    funcName: "flock.webAudio.nativeNodeManager.insertOutput",
                    args: [ "{that}", "{arguments}.0" ]
                },
                removeOutput: {
                    funcName: "flock.webAudio.nativeNodeManager.removeOutput",
                    args: [ "{scriptProcessor}.node" ]
                }
            },
            events: {
                onStart: "{enviro}.events.onStart",
                onStop: "{enviro}.events.onStop",
                onReset: "{enviro}.events.onReset",
                onCreateScriptProcessor: null,
                onConnect: null,
                onDisconnectNodes: null,
                onDisconnect: null
            },
            listeners: {
                "onCreate.fireOnCreateScriptProcessor": {
                    func: "{that}.events.onCreateScriptProcessor.fire"
                },
                "onCreate.insertOutputNode": {
                    priority: "after:fireOnCreateScriptProcessor",
                    func: "{that}.insertOutput",
                    args: "{scriptProcessor}.node"
                },
                "onStart.connect": "{that}.connect()",
                "onConnect.connectMergerNode": {
                    this: "{merger}.node",
                    method: "connect",
                    args: [ "{scriptProcessor}.node" ]
                },
                "onConnect.connectOutputNode": {
                    priority: "after:connectMergerNode",
                    this: "{that}.outputNode",
                    method: "connect",
                    args: [ "{audioSystem}.context.destination" ]
                },
                "onConnect.connectOutput": {
                    priority: "after:connectOutputNode",
                    funcName: "flock.webAudio.nativeNodeManager.connectOutput",
                    args: [ "{scriptProcessor}.node", "{that}.outputNode" ]
                },
                "onStop.disconnect": "{that}.disconnect()",
                "onDisconnect.fireOnDisconnectNodes": {
                    func: "{that}.events.onDisconnectNodes.fire"
                },
                "onDisconnectNodes.disconnectMergerNode": {
                    this: "{merger}.node",
                    method: "disconnect",
                    args: [ 0 ]
                },
                "onDisconnect.disconnectScriptProcessorNode": {
                    priority: "after:disconnectMergerNode",
                    this: "{scriptProcessor}.node",
                    method: "disconnect",
                    args: [ 0 ]
                },
                "onDisconnectNodes.disconnectOuptutNode": {
                    priority: "after:disconnectScriptProcessorNode",
                    this: "{that}.outputNode",
                    method: "disconnect",
                    args: [ 0 ]
                },
                "onReset.removeAllInputs": {
                    func: "{that}.removeAllInputs"
                },
                "onReset.fireOnCreateScriptProcessor": {
                    func: "{that}.events.onCreateScriptProcessor.fire"
                },
                "onDestroy.fireOnDisconnectNodes": {
                    func: "{that}.events.onDisconnectNodes.fire"
                },
                "onDestroy.removeAllInputs": {
                    priority: "after:fireOnDisconnectNodes",
                    func: "{that}.removeAllInputs"
                },
                "onDestroy.disconnectOutput": {
                    priority: "after:removeAllInputs",
                    func: "flock.webAudio.nativeNodeManager.disconnectOutput",
                    args: [ "{that}" ]
                }
            }
        }), D.webAudio.nativeNodeManager.createInputNode = function(e, t, n) {
            var r = e.createNode(t);
            return e.insertInput(r, n);
        }, D.webAudio.nativeNodeManager.createOutputNode = function(e, t) {
            var n = e.createNode(t);
            return e.insertOutput(n);
        }, D.webAudio.nativeNodeManager.connectOutput = function(e, t) {
            e !== t && e.connect(t);
        }, D.webAudio.nativeNodeManager.disconnectOutput = function(e) {
            e.outputNode && e.outputNode.disconnect(0);
        }, D.webAudio.nativeNodeManager.removeAllInputs = function(e) {
            for (var t = 0; t < e.length; t++) {
                e[t].disconnect(0);
            }
            e.length = 0;
        }, D.webAudio.nativeNodeManager.insertInput = function(e, t, n, r, a) {
            var o = t.numInputBuses;
            if (!(e.inputNodes.length >= o)) {
                var i = (a = void 0 === a ? n.busManager.acquireNextBus("input") : a) - t.chans;
                return e.inputNodes.push(r), r.connect(e.merger.node, 0, i), a;
            }
            D.fail("There are too many input nodes connected to Flocking. The maximum number of input buses is currently set to " + o + ". Either remove an existing input node or increase Flockings numInputBuses option.");
        }, D.webAudio.nativeNodeManager.removeInput = function(e, t) {
            var n = t.indexOf(e);
            -1 < n && t.splice(n, 1), e.disconnect(0);
        }, D.webAudio.nativeNodeManager.insertOutput = function(e, t) {
            return D.webAudio.nativeNodeManager.disconnectOutput(e), e.outputNode = t;
        }, D.webAudio.nativeNodeManager.removeOutput = function(e) {
            D.webAudio.nativeNodeManager.insertOutput(e);
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        m.defaults("flock.webAudio.outputManager", {
            gradeNames: [ "flock.outputManager" ],
            model: {
                isGenerating: !1,
                audioSettings: {}
            },
            invokers: {
                bindAudioProcess: {
                    funcName: "flock.webAudio.outputManager.bindAudioProcess",
                    args: [ "{enviro}.nodeList", "{busManager}.buses", "{nativeNodeManager}", "{that}.model" ]
                },
                unbindAudioProcess: {
                    funcName: "flock.webAudio.outputManager.unbindAudioProcess",
                    args: [ "{nativeNodeManager}" ]
                }
            },
            listeners: {
                "{nativeNodeManager}.events.onConnect": [ "{that}.bindAudioProcess()" ],
                "{nativeNodeManager}.events.onDisconnect": [ "{that}.unbindAudioProcess()" ],
                onStart: [ {
                    func: "{that}.applier.change",
                    args: [ "isGenerating", !0 ]
                }, {
                    priority: "last",
                    this: "{audioSystem}.context",
                    method: "resume"
                } ],
                onStop: [ {
                    func: "{that}.applier.change",
                    args: [ "isGenerating", !1 ]
                } ],
                "onDestroy.unbindAudioProcess": "{that}.unbindAudioProcess()"
            }
        }), D.webAudio.outputManager.bindAudioProcess = function(e, t, n, r) {
            var a = n.scriptProcessor.node;
            a.model = r, a.nodeList = e, a.buses = t, a.inputNodes = n.inputNodes, a.onaudioprocess = D.webAudio.outputManager.writeSamples;
        }, D.webAudio.outputManager.unbindAudioProcess = function(e) {
            e.scriptProcessor.node.onaudioprocess = void 0;
        }, D.webAudio.outputManager.writeSamples = function(e) {
            var t, n, r, a = this.inputNodes ? this.inputNodes.length : 0, o = this.nodeList.nodes, i = this.model.audioSettings, u = e.inputBuffer, s = e.outputBuffer, l = i.numBlocks, c = this.buses, d = i.numBuses, f = i.blockSize, p = i.chans, m = u.numberOfChannels;
            if (o.length < 1) for (t = 0; t < p; t++) D.clearBuffer(s.getChannelData(t)); else for (n = 0; n < l; n++) {
                var g = n * f;
                if (D.evaluate.clearBuses(c, d, f), 0 < a) for (t = 0; t < m; t++) {
                    var h = u.getChannelData(t), v = c[p + t];
                    for (r = 0; r < f; r++) v[r] = h[r + g];
                }
                for (D.evaluate.synths(o), t = 0; t < p; t++) {
                    var y = c[t], b = s.getChannelData(t);
                    for (r = 0; r < f; r++) b[r + g] = y[r];
                }
            }
        };
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var o = m.registerNamespace("jQuery");
        D.ugenDefaults = function(e, t) {
            return 1 === arguments.length ? D.ugenDefaults.store[e] : D.ugenDefaults.store[e] = t;
        }, D.ugenDefaults.store = {}, D.isUGen = function(e) {
            return e && e.tags && -1 < e.tags.indexOf("flock.ugen");
        }, D.aliasUGen = function(e, t, n, r) {
            var a = D.get(e);
            D.set(a, t, function(e, t, n) {
                return n = o.extend(!0, {}, r, n), a(e, t, n);
            }), D.ugenDefaults(e + "." + t, n);
        }, D.aliasUGens = function(e, t) {
            var n, r;
            for (n in t) r = t[n], D.aliasUGen(e, n, {
                inputs: r.inputDefaults
            }, r.options);
        }, D.copyUGenDefinition = function(e, t) {
            var n = D.ugenDefaults(e), r = m.getGlobalValue(e);
            m.setGlobalValue(t, r), D.ugenDefaults(t, m.copy(n));
        }, D.krMul = function(e, t, n) {
            var r, a = n.output[0];
            for (r = 0; r < e; r++) t[r] = t[r] * a;
        }, D.mul = function(e, t, n) {
            var r, a = n.output;
            for (r = 0; r < e; r++) t[r] = t[r] * a[r];
        }, D.krAdd = function(e, t, n, r) {
            var a, o = r.output[0];
            for (a = 0; a < e; a++) t[a] = t[a] + o;
        }, D.add = function(e, t, n, r) {
            var a, o = r.output;
            for (a = 0; a < e; a++) t[a] = t[a] + o[a];
        }, D.krMulAdd = function(e, t, n, r) {
            var a, o = n.output[0], i = r.output;
            for (a = 0; a < e; a++) t[a] = t[a] * o + i[a];
        }, D.mulKrAdd = function(e, t, n, r) {
            var a, o = n.output, i = r.output[0];
            for (a = 0; a < e; a++) t[a] = t[a] * o[a] + i;
        }, D.krMulKrAdd = function(e, t, n, r) {
            var a, o = n.output[0], i = r.output[0];
            for (a = 0; a < e; a++) t[a] = t[a] * o + i;
        }, D.mulAdd = function(e, t, n, r) {
            var a, o = n.output, i = r.output;
            for (a = 0; a < e; a++) t[a] = t[a] * o[a] + i[a];
        }, D.onMulAddInputChanged = function(t) {
            var e, n = t.inputs.mul, r = t.inputs.add;
            n || r ? (e = n ? r ? n.rate !== D.rates.AUDIO ? r.rate !== D.rates.AUDIO ? D.krMulKrAdd : D.krMulAdd : r.rate !== D.rates.AUDIO ? D.mulKrAdd : D.mulAdd : n.rate !== D.rates.AUDIO ? D.krMul : D.mul : r.rate !== D.rates.AUDIO ? D.krAdd : D.add, 
            t.mulAddFn = e, t.mulAdd = function(e) {
                t.mulAddFn(e, t.output, t.inputs.mul, t.inputs.add);
            }) : t.mulAdd = t.mulAddFn = D.noOp;
        }, D.ugen = function(e, t, n) {
            var u = {
                enviro: (n = n || {}).enviro || D.environment,
                rate: n.rate || D.rates.AUDIO,
                inputs: e,
                output: t,
                options: n,
                model: n.model || {
                    unscaledValue: 0,
                    value: 0
                },
                multiInputs: {},
                tags: [ "flock.ugen" ]
            };
            return u.lastOutputIdx = u.output.length - 1, u.get = function(e) {
                return D.input.get(u.inputs, e);
            }, u.set = function(e, t) {
                return D.input.set(u.inputs, e, t, u, function(e) {
                    if (null != e) return D.parse.ugenDef(e, u.enviro, {
                        audioSettings: u.options.audioSettings,
                        buses: u.buses,
                        buffers: u.buffers
                    });
                });
            }, u.input = function(e, t) {
                return e ? "string" == typeof e ? arguments.length < 2 ? u.get(e) : u.set(e, t) : D.isIterable(e) ? u.get(e) : u.set(e, t) : void 0;
            }, u.calculateStrides = function() {
                var e, t, n, r = u.model, a = u.options.strideInputs, o = u.inputs;
                if (r.strides = r.strides || {}, a) for (e = 0; e < a.length; e++) (n = o[t = a[e]]) ? r.strides[t] = n.rate === D.rates.AUDIO ? 1 : 0 : m.log(m.logLevel.WARN, "An invalid input ('" + t + "') was found on a unit generator: " + u);
            }, u.collectMultiInputs = function() {
                var e, t, n, r, a = u.options.multiInputNames, o = u.multiInputs;
                for (e = 0; e < a.length; e++) (n = o[t = a[e]]) ? n.length = 0 : n = o[t] = [], 
                r = u.inputs[t], D.ugen.collectMultiInputs(r, n);
            }, u.onInputChanged = function(e) {
                var t = u.options.multiInputNames;
                D.onMulAddInputChanged(u), u.options.strideInputs && u.calculateStrides(), !t || e && !t.indexOf(e) || u.collectMultiInputs();
            }, u.init = function() {
                var e, t, n, r = m.makeArray(u.options.tags), a = u.model, o = u.options;
                for (e = 0; e < r.length; e++) u.tags.push(r[e]);
                if (t = o.audioSettings = o.audioSettings || u.enviro.audioSystem.model, a.sampleRate = o.sampleRate || t.rates[u.rate], 
                a.nyquistRate = a.sampleRate, a.blockSize = u.rate === D.rates.AUDIO ? t.blockSize : 1, 
                a.sampleDur = 1 / a.sampleRate, u.interpolate = D.interpolate.none, o.interpolation) {
                    var i = D.interpolate[o.interpolation];
                    i ? u.interpolate = i : m.log(m.logLevel.IMPORTANT, "An invalid interpolation type of '" + o.interpolation + "' was specified. Defaulting to none.");
                }
                u.rate === D.rates.DEMAND && u.inputs.freq && (n = D.parse.ugenDefForConstantValue(1), 
                u.inputs.freq = D.parse.ugenDef(n, u.enviro));
            }, u.init(), u;
        }, D.ugen.collectMultiInputs = function(e, t) {
            D.isIterable(e) || (e = e = m.makeArray(e));
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                D.ugen.collectChannelsForInput(r, t);
            }
            return t;
        }, D.ugen.collectChannelsForInput = function(e, t) {
            var n, r = D.hasTag(e, "flock.ugen.multiChannelOutput") ? e.output : [ e.output ];
            for (n = 0; n < r.length; n++) t.push({
                rate: e.rate,
                output: r[n]
            });
            return t;
        }, D.ugen.lastOutputValue = function(e, t) {
            return t[e - 1];
        }, D.ugen.buffer = function(r) {
            r.onBufferInputChanged = function(e) {
                var t = r.model, n = r.inputs;
                t.bufDef === n.buffer && "buffer" !== e || (t.bufDef = n.buffer, D.parse.bufferForDef(t.bufDef, r, r.enviro));
            }, r.setBuffer = function(e) {
                r.buffer = e, r.onBufferReady && r.onBufferReady(e);
            }, r.initBuffer = function() {
                r.buffer = r.model.bufDef = D.bufferDesc({
                    format: {
                        sampleRate: r.options.audioSettings.rates.audio
                    },
                    data: {
                        channels: [ new Float32Array(r.output.length) ]
                    }
                });
            };
        }, D.ugen.value = function(e, t, n) {
            var a = D.ugen(e, t, n);
            return a.value = function() {
                return a.model.value;
            }, a.dynamicGen = function(e) {
                for (var t = a.output, n = a.model, r = 0; r < e; r++) t[r] = n.unscaledValue;
                a.mulAdd(e), n.value = D.ugen.lastOutputValue(e, t);
            }, a.onInputChanged = function() {
                var e = a.inputs;
                a.model.unscaledValue = e.value, "constant" !== a.rate ? a.gen = a.dynamicGen : a.gen = void 0, 
                D.onMulAddInputChanged(a), a.dynamicGen(1);
            }, a.onInputChanged(), a;
        }, D.ugenDefaults("flock.ugen.value", {
            rate: "control",
            inputs: {
                value: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    unscaledValue: 1,
                    value: 1
                },
                tags: [ "flock.ugen.valueType" ]
            }
        }), D.ugen.silence = function(e, t, n) {
            var r = D.ugen(e, t, n);
            return r.onInputChanged = function() {
                for (var e = 0; e < r.output.length; e++) r.output[e] = 0;
            }, r.onInputChanged(), r;
        }, D.ugenDefaults("flock.ugen.silence", {
            rate: "constant"
        }), D.ugen.passThrough = function(e, t, n) {
            var i = D.ugen(e, t, n);
            return i.gen = function(e) {
                var t, n, r = i.model, a = i.inputs.source.output, o = i.output;
                for (t = 0; t < a.length; t++) o[t] = n = a[t];
                for (;t < e; t++) o[t] = n = 0;
                r.unscaledValue = n, i.mulAdd(e), r.value = D.ugen.lastOutputValue(e, o);
            }, i.onInputChanged(), i;
        }, D.ugenDefaults("flock.ugen.passThrough", {
            rate: "audio",
            inputs: {
                source: null,
                mul: null,
                add: null
            }
        }), D.ugen.out = function(e, t, n) {
            var h = D.ugen(e, t, n);
            return h.gen = function(e) {
                var t, n, r, a, o, i, u, s, l, c, d = h.model, f = h.multiInputs.sources, p = h.options.buses, m = h.inputs.bus.output[0], g = h.inputs.expand.output[0];
                if (t = f.length, n = Math.max(g, t), !(t < 1)) {
                    for (r = 0; r < n; r++) {
                        for (i = (o = f[r % t]).rate, u = p[m + r], s = i === D.rates.AUDIO ? 1 : 0, a = l = 0; a < e; a++, 
                        l += s) c = o.output[l], u[a] = u[a] + c;
                        h.mulAddFn(e, u, h.inputs.mul, h.inputs.add);
                    }
                    d.value = d.unscaledValue = c;
                }
            }, h.init = function() {
                h.sourceBuffers = [], h.onInputChanged();
            }, h.init(), h;
        }, D.ugenDefaults("flock.ugen.out", {
            rate: "audio",
            inputs: {
                sources: null,
                bus: 0,
                expand: 2
            },
            ugenOptions: {
                tags: [ "flock.ugen.outputType" ],
                multiInputNames: [ "sources" ]
            }
        }), D.ugen.valueOut = function(e, t, n) {
            var r = D.ugen(e, t, n);
            return r.arraySourceGen = function() {
                var e, t = r.model, n = r.inputs.sources;
                for (e = 0; e < n.length; e++) t.value[e] = n[e].output[0];
            }, r.ugenSourceGen = function() {
                r.model.value = r.model.unscaledValue = r.inputs.sources.output[0];
            }, r.onInputChanged = function() {
                var e = r.model, t = r.inputs.sources;
                D.isIterable(t) ? (r.gen = r.arraySourceGen, e.value = new Float32Array(t.length), 
                e.unscaledValue = e.value) : r.gen = r.ugenSourceGen;
            }, r.onInputChanged(), r;
        }, D.ugenDefaults("flock.ugen.valueOut", {
            rate: "control",
            inputs: {
                sources: null
            },
            ugenOptions: {
                model: {
                    unscaledValue: null,
                    value: null
                },
                tags: [ "flock.ugen.outputType", "flock.ugen.valueType" ]
            }
        }), D.ugen.in = function(e, t, n) {
            var s = D.ugen(e, t, n);
            return s.singleBusGen = function(e) {
                var t = s.model, n = s.output;
                D.ugen.in.readBus(e, n, s.inputs.bus, s.options.buses), t.unscaledValue = D.ugen.lastOutputValue(e, n), 
                s.mulAdd(e), t.value = D.ugen.lastOutputValue(e, n);
            }, s.multiBusGen = function(e) {
                var t, n, r, a = s.model, o = s.inputs.bus, i = s.options.buses, u = s.output;
                for (t = 0; t < e; t++) {
                    for (n = r = 0; n < o.length; n++) r += i[0 | o[n].output[0]][t];
                    u[t] = r;
                }
                a.unscaledValue = r, s.mulAdd(e), a.value = D.ugen.lastOutputValue(e, u);
            }, s.onInputChanged = function() {
                s.gen = D.isIterable(s.inputs.bus) ? s.multiBusGen : s.singleBusGen, D.onMulAddInputChanged(s);
            }, s.onInputChanged(), s;
        }, D.ugen.in.readBus = function(e, t, n, r) {
            var a, o = r[0 | n.output[0]];
            for (a = 0; a < e; a++) t[a] = o[a];
        }, D.ugenDefaults("flock.ugen.in", {
            rate: "audio",
            inputs: {
                bus: 0,
                mul: null,
                add: null
            }
        }), D.ugen.audioIn = function(e, t, n) {
            var i = D.ugen(e, t, n);
            return i.gen = function(e) {
                var t, n, r = i.model, a = i.output, o = i.bus;
                for (t = 0; t < e; t++) a[t] = n = o[t];
                r.unscaledValue = n, i.mulAdd(e), r.value = D.ugen.lastOutputValue(e, a);
            }, i.onInputChanged = function() {
                D.onMulAddInputChanged(i);
            }, i.init = function() {
                var e = i.enviro.audioSystem.inputDeviceManager.openAudioDevice(n);
                i.bus = i.options.buses[e], i.onInputChanged();
            }, i.init(), i;
        }, D.ugenDefaults("flock.ugen.audioIn", {
            rate: "audio",
            inputs: {
                mul: null,
                add: null
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.blit = function(e) {
            var t;
            return 2 <= e ? 0 : 1 <= e ? .16666666666666666 * (t = 2 - e) * t * t : 0 <= e ? .6666666666666666 - (t = e * e) + .5 * t * e : -1 <= e ? .6666666666666666 - (t = e * e) - .5 * t * e : -2 <= e ? .16666666666666666 * (t = 2 + e) * t * t : 0;
        }, D.blit.period = function(e, t) {
            var n = e / t;
            return n < 1 ? 1 : n;
        }, D.blit.updatePeriodState = function(e, t) {
            e.freq = t < 1e-6 ? 1e-6 : t, e.d0 = D.blit.period(e.sampleRate, e.freq);
        }, D.ugen.blit = function(e, t, n) {
            var u = D.ugen(e, t, n);
            return u.gen = function(e) {
                var t, n, r = u.model, a = u.output, o = u.inputs.freq.output[0], i = r.phase;
                for (t = 0; t < e; t++) (i -= 1) < -2 && (D.blit.updatePeriodState(r, o), i += r.d0), 
                n = D.blit(i), a[t] = n;
                r.phase = i, r.unscaledValue = n, u.mulAdd(e), r.value = D.ugen.lastOutputValue(e, a);
            }, u.init = function() {
                u.onInputChanged();
            }, u.init(), u;
        }, D.ugenDefaults("flock.ugen.blit", {
            rate: "audio",
            inputs: {
                freq: 440,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: -2,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), D.ugen.saw = function(e, t, n) {
            var s = D.ugen(e, t, n);
            return s.gen = function(e) {
                var t, n = s.model, r = s.output, a = s.inputs.freq.output[0], o = 1 - s.inputs.leakRate.output[0], i = n.phase, u = n.unscaledValue;
                for (void 0 === i && (D.ugen.saw.updatePeriodState(n, a), i = n.d0 / 2), t = 0; t < e; t++) (i -= 1) < -2 && (D.ugen.saw.updatePeriodState(n, a), 
                i += n.d0), r[t] = u = D.blit(i) - n.dcOffset + o * u;
                n.phase = i, n.unscaledValue = u, s.mulAdd(e), n.value = D.ugen.lastOutputValue(e, r);
            }, s.init = function() {
                s.onInputChanged();
            }, s.init(), s;
        }, D.ugen.saw.updatePeriodState = function(e, t) {
            D.blit.updatePeriodState(e, t), e.dcOffset = 1 / e.d0;
        }, D.ugenDefaults("flock.ugen.saw", {
            rate: "audio",
            inputs: {
                freq: 440,
                leakRate: .01,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: void 0,
                    dcOffset: void 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), D.ugen.square = function(e, t, n) {
            var s = D.ugen(e, t, n);
            return s.gen = function(e) {
                var t, n = s.model, r = s.output, a = s.inputs.freq.output[0], o = 1 - s.inputs.leakRate.output[0], i = n.phase, u = n.unscaledValue;
                for (void 0 === i && (D.ugen.square.updatePeriodState(n, a), i = n.phaseResetValue), 
                t = 0; t < e; t++) r[t] = u = D.blit(i) * n.sign + o * u, i < -2 && (D.ugen.square.updatePeriodState(n, a), 
                i += n.phaseResetValue), i -= 1;
                n.phase = i, n.unscaledValue = u, s.mulAdd(e), n.value = D.ugen.lastOutputValue(e, r);
            }, s.init = function() {
                s.onInputChanged();
            }, s.init(), s;
        }, D.ugen.square.updatePeriodState = function(e, t) {
            D.blit.updatePeriodState(e, t), e.phaseResetValue = e.d0 / 2, e.sign *= -1;
        }, D.ugenDefaults("flock.ugen.square", {
            rate: "audio",
            inputs: {
                freq: 440,
                leakRate: .01,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: void 0,
                    unscaledValue: .5,
                    value: .5,
                    sign: 1
                }
            }
        }), D.ugen.tri = function(e, t, n) {
            var c = D.ugen(e, t, n);
            return c.gen = function(e) {
                var t, n, r = c.model, a = c.output, o = c.inputs.freq.output[0], i = 1 - c.inputs.leakRate.output[0], u = r.phase, s = r.unscaledValue, l = r.secondPrevVal;
                for (void 0 === u && (D.ugen.tri.updatePeriodState(r, o), u = r.d0 / 4), t = 0; t < e; t++) l = n = (s = D.blit(u) * r.sign + i * s) + i * l, 
                a[t] = n * r.ampScale, (u -= 1) < -2 && (D.ugen.tri.updatePeriodState(r, o), u += r.phaseResetValue);
                r.phase = u, r.unscaledValue = s, r.secondPrevVal = l, c.mulAdd(e), r.value = D.ugen.lastOutputValue(e, a);
            }, c.init = function() {
                c.onInputChanged();
            }, c.init(), c;
        }, D.ugen.tri.updatePeriodState = function(e, t) {
            D.blit.updatePeriodState(e, t), e.phaseResetValue = e.d0 / 2, e.ampScale = 2 / e.d0, 
            e.sign *= -1;
        }, D.ugenDefaults("flock.ugen.tri", {
            rate: "audio",
            inputs: {
                freq: 440,
                leakRate: .01,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: void 0,
                    value: .5,
                    unscaledValue: .5,
                    secondPrevVal: 0,
                    sign: 1,
                    ampScale: void 0,
                    phaseResetValue: void 0
                }
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.ugen.playBuffer = function(y, e, t) {
            var b = D.ugen(y, e, t);
            return b.defaultKrTriggerGen = function(e) {
                var t, n, r = b.model, a = b.output, o = b.inputs.channel.output[0], i = b.buffer.data.channels[o], u = r.idx, s = b.inputs.loop.output[0], l = y.trigger.output[0];
                for (0 < l && r.prevTrig <= 0 && (u = 0), r.prevTrig = l, t = 0; t < e; t++) {
                    if (u > r.lastIdx) {
                        if (!(0 < s && 0 < l)) {
                            a[t] = n = 0;
                            continue;
                        }
                        u = 0;
                    }
                    n = b.interpolate(u, i), a[t] = n, u++;
                }
                r.idx = u, r.unscaledValue = n, b.mulAdd(e), r.value = D.ugen.lastOutputValue(e, a);
            }, b.otherwiseGen = function(e) {
                var t, n, r, a, o, i, u, s = b.model, l = b.output, c = b.inputs.channel.output[0], d = b.inputs.speed.output, f = b.buffer.data.channels[c], p = y.trigger.output, m = s.idx, g = b.inputs.loop.output[0], h = b.inputs.start.output[0] * s.lastIdx | 0, v = b.inputs.end.output[0] * s.lastIdx | 0;
                for (r = n = t = 0; t < e; t++, n += s.strides.trigger, r += s.strides.speed) {
                    if (a = p[n], o = s.prevTrig, i = d[r], 0 < (s.prevTrig = a) && o <= 0) m = D.ugen.playBuffer.resetIndex(i, h, v); else if (m < h || v < m) {
                        if (!(0 < g && 0 < a)) {
                            l[t] = u = 0;
                            continue;
                        }
                        m = D.ugen.playBuffer.resetIndex(i, h, v);
                    }
                    u = b.interpolate(m, f), l[t] = u, m += s.stepSize * i;
                }
                s.idx = m, s.unscaledValue = u, b.mulAdd(e), s.value = D.ugen.lastOutputValue(e, l);
            }, b.onInputChanged = function(e) {
                var t = b.inputs, n = t.speed, r = t.start, a = t.end, o = t.trigger;
                b.onBufferInputChanged(e), b.gen = n.rate === D.rates.CONSTANT && 1 === n.output[0] && r.rate === D.rates.CONSTANT && 0 === r.output[0] && a.rate === D.rates.CONSTANT && 1 === a.output[0] && o.rate !== D.rates.AUDIO ? b.defaultKrTriggerGen : b.otherwiseGen, 
                b.calculateStrides(), D.onMulAddInputChanged(b);
            }, b.onBufferReady = function() {
                var e = b.model, t = b.inputs.end.output[0], n = b.inputs.channel.output[0], r = b.buffer.data.channels[n].length;
                e.idx = t * r | 0, e.lastIdx = r - 1, e.stepSize = b.buffer.format.sampleRate / e.sampleRate;
            }, b.init = function() {
                D.ugen.buffer(b), b.initBuffer(), b.onInputChanged();
            }, b.init(), b;
        }, D.ugen.playBuffer.resetIndex = function(e, t, n) {
            return 0 < e ? t : n;
        }, D.ugenDefaults("flock.ugen.playBuffer", {
            rate: "audio",
            inputs: {
                channel: 0,
                loop: 0,
                speed: 1,
                start: 0,
                end: 1,
                trigger: 1,
                buffer: null,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    finished: !1,
                    unscaledValue: 0,
                    value: 0,
                    idx: 0,
                    stepSize: 0,
                    prevTrig: 0,
                    channel: void 0
                },
                strideInputs: [ "trigger", "speed" ],
                interpolation: "linear"
            }
        }), D.ugen.readBuffer = function(e, t, n) {
            var f = D.ugen(e, t, n);
            return f.gen = function(e) {
                var t, n, r, a, o = f.model, i = o.strides.phase, u = f.output, s = f.inputs.channel.output[0], l = f.inputs.phase.output, c = f.buffer.data.channels[s], d = c.length;
                for (t = r = 0; t < e; t++, r += i) n = l[r] * d, a = f.interpolate(n, c), u[t] = a;
                o.unscaledValue = a, f.mulAdd(e), o.value = D.ugen.lastOutputValue(e, u);
            }, f.onInputChanged = function(e) {
                f.onBufferInputChanged(e), f.calculateStrides(), D.onMulAddInputChanged(f);
            }, f.init = function() {
                D.ugen.buffer(f), f.initBuffer(), f.onInputChanged();
            }, f.init(), f;
        }, D.ugenDefaults("flock.ugen.readBuffer", {
            rate: "audio",
            inputs: {
                buffer: null,
                channel: 0,
                phase: 0,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    channel: void 0,
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "phase" ],
                interpolation: "linear"
            }
        }), D.ugen.writeBuffer = function(e, t, n) {
            var y = D.ugen(e, t, n);
            return y.gen = function(e) {
                var t, n, r, a = y.model, o = y.output, i = y.inputs, u = y.buffer, s = y.multiInputs.sources, l = s.length, c = u.data.channels, d = u.format.numSampleFrames, f = i.start.output[0], p = i.loop.output[0];
                for (a.prevStart !== f && (a.prevStart = f, a.writeIdx = Math.floor(f)), t = 0; t < l; t++) {
                    var m = s[t].output, g = c[t], h = o[t];
                    for (n = a.writeIdx, r = 0; r < e; r++) {
                        var v = m[r];
                        h && (h[r] = v), n < d ? g[n] = v : 0 < p && (g[n = Math.floor(f)] = v), n++;
                    }
                }
                a.writeIdx = n, y.mulAdd(e);
            }, y.createBuffer = function(e, t) {
                var n, r = e.options, a = r.audioSettings, o = r.buffers, i = e.multiInputs.sources.length, u = Math.round(e.options.duration * a.rates.audio), s = new Array(i);
                for (n = 0; n < i; n++) s[n] = new Float32Array(u);
                var l = D.bufferDesc(s, a.rates.audio, i);
                return t.id && (l.id = t.id, o[t.id] = l), l;
            }, y.setupBuffer = function(e) {
                var t;
                return (e = "string" == typeof e ? {
                    id: e
                } : e).id && (t = y.options.buffers[e.id]), y.buffer = t || y.createBuffer(y, e), 
                y.buffer;
            }, y.onInputChanged = function(e) {
                e ? "sources" === e ? y.collectMultiInputs() : "buffer" === e && y.setupBuffer(y.inputs.buffer) : (y.collectMultiInputs(), 
                y.setupBuffer(y.inputs.buffer)), D.onMulAddInputChanged(y);
            }, y.init = function() {
                y.onInputChanged();
            }, y.init(), y;
        }, D.ugenDefaults("flock.ugen.writeBuffer", {
            rate: "audio",
            inputs: {
                sources: null,
                buffer: null,
                start: 0,
                loop: 0
            },
            ugenOptions: {
                model: {
                    prevStart: void 0,
                    writeIdx: 0
                },
                tags: [ "flock.ugen.multiChannelOutput" ],
                numOutputs: 2,
                multiInputNames: [ "sources" ],
                duration: 600
            }
        }), D.ugen.bufferDuration = function(e, t, n) {
            var s = D.ugen(e, t, n);
            return s.krGen = function(e) {
                var t, n = s.model, r = s.output, a = s.inputs.channel.output[0], o = s.buffer.data.channels[a], i = s.buffer.format.sampleRate, u = o.length / i;
                for (t = 0; t < e; t++) r[t] = u;
                n.unscaledValue = u, s.mulAdd(e), n.value = D.ugen.lastOutputValue(e, r);
            }, s.onInputChanged = function(e) {
                D.onMulAddInputChanged(s), s.onBufferInputChanged(e);
            }, s.onBufferReady = function() {
                s.krGen(1);
            }, s.init = function() {
                var e = s.rate;
                s.gen = e === D.rates.CONTROL || e === D.rates.AUDIO ? s.krGen : void 0, s.output[0] = 0, 
                D.ugen.buffer(s), s.initBuffer(), s.onInputChanged();
            }, s.init(), s;
        }, D.ugenDefaults("flock.ugen.bufferDuration", {
            rate: "constant",
            inputs: {
                buffer: null,
                channel: 0
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), D.ugen.bufferLength = function(e, t, n) {
            var i = D.ugen(e, t, n);
            return i.krGen = function(e) {
                var t, n = i.model, r = i.output, a = i.inputs.channel.output[0], o = i.buffer.data.channels[a].length;
                for (t = 0; t < e; t++) r[t] = o;
                n.unscaledValue = o, i.mulAdd(e), n.value = D.ugen.lastOutputValue(e, r);
            }, i.onInputChanged = function(e) {
                D.onMulAddInputChanged(i), i.onBufferInputChanged(e);
            }, i.onBufferReady = function() {
                i.krGen(1);
            }, i.init = function() {
                var e = i.rate;
                i.gen = e === D.rates.CONTROL || e === D.rates.AUDIO ? i.krGen : void 0, i.output[0] = 0, 
                D.ugen.buffer(i), i.initBuffer(), i.onInputChanged();
            }, i.init(), i;
        }, D.ugenDefaults("flock.ugen.bufferLength", {
            rate: "constant",
            inputs: {
                buffer: null,
                channel: 0
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), D.ugen.bufferPhaseStep = function(e, t, n) {
            var i = D.ugen(e, t, n);
            return i.krGen = function(e) {
                var t, n = i.model, r = i.output, a = n.unscaledValue;
                for (t = 0; t < e; t++) r[t] = a;
                i.mulAdd(e), n.value = D.ugen.lastOutputValue(e, r);
            }, i.onInputChanged = function(e) {
                i.onBufferInputChanged(e), D.onMulAddInputChanged(i);
            }, i.onBufferReady = function(e) {
                var t = i.model, n = i.inputs.channel.output[0], r = e.data.channels[n], a = i.options.audioSettings.rates.audio, o = i.buffer.format.sampleRate || a;
                t.scale = o / a, i.output[0] = t.unscaledValue = 1 / (r.length * t.scale);
            }, i.init = function() {
                var e = i.rate;
                i.gen = e === D.rates.CONTROL || e === D.rates.AUDIO ? i.krGen : void 0, i.output[0] = 0, 
                D.ugen.buffer(i), i.initBuffer(), i.onInputChanged();
            }, i.init(), i;
        }, D.ugenDefaults("flock.ugen.bufferPhaseStep", {
            rate: "constant",
            inputs: {
                buffer: null,
                channel: 0
            },
            ugenOptions: {
                model: {
                    scale: 1,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), D.ugen.sampleRate = function(e, t, n) {
            var r = D.ugen(e, t, n), a = r.model;
            return r.output[0] = a.value = a.unscaledValue = r.options.audioSettings.rates.audio, 
            r;
        }, D.ugenDefaults("flock.ugen.sampleRate", {
            rate: "constant",
            inputs: {}
        }), D.ugen.triggerBuffers = function(e, t, n) {
            var T = D.ugen(e, t, n);
            return T.gen = function(e) {
                var t, n, r, a, o, i, u, s, l, c, d = T.model, f = d.strides, p = T.output, m = T.inputs, g = T.buffers, h = g.length - 1, v = d.prevTrigger, y = d.maxVoices, b = d.activeVoices, k = d.freeVoices, S = m.trigger.output, C = f.trigger, x = 0, A = m.bufferIndex.output, w = f.bufferIndex, I = 0, N = m.speed.output, M = f.speed, P = 0, O = T.inputs.channel.output[0];
                for (t = 0; t < e; t++) {
                    if (0 < (n = S[x]) && v <= 0 && b.length < y) {
                        if (a = Math.round(A[I] * h), a = Math.max(0, a), !(o = g[a = Math.min(a, h)])) continue;
                        (r = k.pop()).speed = N[P], r.currentIdx = 0, r.writePos = t, r.buffer = o.data.channels[O], 
                        b.push(r);
                    }
                    x += C, P += M, I += w, p[t] = 0, v = n;
                }
                for (i = 0; i < b.length; ) {
                    for (u = (r = b[i]).buffer, s = Math.min(u.length - r.currentIdx, e), l = r.writePos; l < s; l++) c = T.interpolate ? T.interpolate(r.currentIdx, u) : u[0 | r.currentIdx], 
                    p[l] += c, r.currentIdx += r.speed;
                    r.currentIdx >= u.length ? (k.push(r), b.splice(i, 1)) : (r.writePos = 0, i++);
                }
                d.prevTrigger = v, d.unscaledValue = c, T.mulAdd(e), d.value = D.ugen.lastOutputValue(e, p);
            }, T.init = function() {
                T.buffers = [], T.allocateVoices(), T.onInputChanged();
            }, T.allocateVoices = function() {
                for (var e = 0; e < T.model.maxVoices; e++) T.model.freeVoices.push({});
            }, T.onInputChanged = function() {
                var e, t, n = T.enviro.buffers, r = T.options.bufferIDs;
                for (e = T.buffers.length = 0; e < r.length; e++) t = n[r[e]], T.buffers.push(t);
                D.onMulAddInputChanged(T), T.calculateStrides();
            }, T.init(), T;
        }, D.ugenDefaults("flock.ugen.triggerBuffers", {
            inputs: {
                trigger: 0,
                bufferIndex: 0,
                speed: 1,
                channel: 0
            },
            ugenOptions: {
                model: {
                    prevTrigger: 0,
                    maxVoices: 128,
                    activeVoices: [],
                    freeVoices: [],
                    channel: 0
                },
                bufferIDs: [],
                strideInputs: [ "trigger", "bufferIndex", "speed" ]
            }
        }), D.ugen.chopBuffer = function(e, t, n) {
            var r = D.ugen(e, t, n);
            return D.ugen.buffer(r), r.gen = function(e) {
                var t = r.model, n = r.output;
                D.ugen.chopBuffer.prepareVoices(r, e), D.ugen.chopBuffer.generateSamplesForAllVoices(r, e), 
                t.unscaledValue = D.ugen.lastOutputValue(e, n), r.mulAdd(e), t.value = D.ugen.lastOutputValue(e, n);
            }, r.onInputChanged = function(e) {
                r.onBufferInputChanged(e), r.calculateStrides(), D.onMulAddInputChanged(r);
            }, r.onBufferReady = function() {
                var e = r.model;
                e.stepSize = r.buffer.format.sampleRate / e.sampleRate, e.lastIdx = r.buffer.format.numSampleFrames - 1;
            }, r.init = function() {
                D.ugen.chopBuffer.initVoices(r), r.initBuffer(), r.onInputChanged();
                var e = r.buffer.data.channels[r.inputs.channel.output[0]];
                r.model.lastIdx = e.length - 1;
            }, r.init(), r;
        }, D.ugen.chopBuffer.initVoice = function() {
            return {
                currentStage: 4,
                samplesRemaining: 0,
                duration: 0,
                attackDur: 0,
                releaseDur: 0,
                hasTriggeredNextVoice: !1,
                idx: 0,
                stages: [ {
                    samplesRemaining: 0
                }, {
                    samplesRemaining: 0
                }, {
                    samplesRemaining: 0
                }, {
                    samplesRemaining: 0
                } ]
            };
        }, D.ugen.chopBuffer.initVoices = function(e) {
            for (var t = e.model, n = 0; n < e.options.maxVoices; n++) {
                var r = D.ugen.chopBuffer.initVoice(e);
                t.freeVoices[n] = r;
            }
        }, D.ugen.chopBuffer.randomIndex = D.randomValue, D.ugen.chopBuffer.randomStartIndex = function(e) {
            var t = e.model, n = e.inputs, r = n.end.output[0] - t.inputState.numDurationSamps;
            return r = Math.max(0, r), D.ugen.chopBuffer.randomIndex(n.start.output[0], r) * t.lastIdx;
        }, D.ugen.chopBuffer.allocateVoice = function(e) {
            var t = e.model, n = t.stageSampleState;
            if (!(t.freeVoices.length < 1)) {
                var r = t.freeVoices.pop();
                t.activeVoices.push(r);
                for (var a = 0; a < n.length; a++) {
                    r.stages[a].samplesRemaining = n[a];
                }
                return r.hasTriggeredNextVoice = !1, r.currentStage = D.ugen.chopBuffer.stages.WAIT, 
                r.samplesRemaining = t.inputState.numDurationSamps + t.inputState.numGapSamps, r.idx = D.ugen.chopBuffer.randomStartIndex(e), 
                r;
            }
        }, D.ugen.chopBuffer.updateVoiceState = function(e, t) {
            for (var n = e.model, r = n.stageSampleState, a = n.inputState, o = t.currentStage; o < r.length; o++) {
                var i = t.stages[o], u = r[o];
                i.samplesRemaining > u && (i.samplesRemaining = u);
            }
            t.samplesRemaining > a.numDurationSamps && (t.samplesRemaining = a.numDurationSamps, 
            0 === t.currentStage && (t.samplesRemaining += a.numGapSamps));
        }, D.ugen.chopBuffer.triggerNextVoice = function(e, t, n, r, a) {
            var o = t.samplesRemaining + a;
            o < n && (e.model.stageSampleState[0] = o, D.ugen.chopBuffer.allocateVoice(e), t.hasTriggeredNextVoice = !0);
        }, D.ugen.chopBuffer.envLength = function(e, t, n) {
            return Math.floor((t < e ? t : e) * n);
        }, D.ugen.chopBuffer.deactivateVoice = function(e, t) {
            var n = e.model, r = n.activeVoices.indexOf(t);
            -1 < r && n.activeVoices.splice(r, 1), n.freeVoices.push(t);
        }, D.ugen.chopBuffer.prepareVoice = function(e, t, n) {
            D.ugen.chopBuffer.updateVoiceState(e, t), t.currentStage < D.ugen.chopBuffer.stages.DONE ? t.hasTriggeredNextVoice || D.ugen.chopBuffer.triggerNextVoice(e, t, n) : D.ugen.chopBuffer.deactivateVoice(e, t);
        }, D.ugen.chopBuffer.durationSamples = function(e, t, n) {
            return 0 === t ? n.lastIdx : Math.floor(e / t * n.sampleRate);
        }, D.ugen.chopBuffer.updateInputState = function(e, t) {
            var n = t.inputState, r = e.amount.output[0], a = e.minDuration.output[0], o = a / 2;
            return n.numDurationSamps = D.ugen.chopBuffer.durationSamples(a, r, t), n.numAttackSamps = D.ugen.chopBuffer.envLength(e.attack.output[0], o, t.sampleRate), 
            n.numReleaseSamps = D.ugen.chopBuffer.envLength(e.release.output[0], o, t.sampleRate), 
            n.numSustainSamps = n.numDurationSamps - n.numAttackSamps - n.numReleaseSamps, n.numGapSamps = Math.floor(e.gap.output[0] * t.sampleRate), 
            n;
        }, D.ugen.chopBuffer.prepareVoices = function(e, t) {
            var n = e.model;
            D.ugen.chopBuffer.updateInputState(e.inputs, n), n.stageSampleState[0] = n.inputState.numGapSamps, 
            n.stageSampleState[1] = n.inputState.numAttackSamps, n.stageSampleState[3] = n.inputState.numReleaseSamps, 
            n.stageSampleState[2] = n.inputState.numSustainSamps;
            for (var r = 0; r < n.activeVoices.length; r++) {
                var a = n.activeVoices[r];
                D.ugen.chopBuffer.prepareVoice(e, a, t);
            }
            0 === n.activeVoices.length && D.ugen.chopBuffer.allocateVoice(e);
        }, D.ugen.chopBuffer.generateSamplesForVoice = function(e, t, n) {
            for (var r = e.model, a = e.output, o = e.inputs, i = o.speed.output, u = e.buffer.data.channels[o.channel.output[0]], s = 0, l = 0; s < Math.min(n, t.samplesRemaining) && !(t.currentStage >= D.ugen.chopBuffer.stages.DONE); s++, 
            l += r.strides.speed) {
                var c = r.stepSize * i[l], d = t.stages[t.currentStage];
                a[s] += e.interpolate(t.idx, u), t.samplesRemaining -= c, d.samplesRemaining -= c, 
                t.idx += c, d.samplesRemaining <= 0 && t.currentStage++;
            }
            t.samplesRemaining <= 0 && t.currentStage < D.ugen.chopBuffer.stages.DONE && (t.currentStage = D.ugen.chopBuffer.stages.DONE);
        }, D.ugen.chopBuffer.generateSamplesForAllVoices = function(e, t) {
            var n = e.model;
            D.clearBuffer(e.output);
            for (var r = n.activeVoices.length - 1; 0 <= r; r--) {
                var a = n.activeVoices[r];
                D.ugen.chopBuffer.generateSamplesForVoice(e, a, t);
            }
        }, D.ugen.chopBuffer.stages = {
            WAIT: 0,
            ATTACK: 1,
            SUSTAIN: 2,
            RELEASE: 3,
            DONE: 4
        }, D.ugenDefaults("flock.ugen.chopBuffer", {
            rate: "audio",
            inputs: {
                buffer: null,
                channel: 0,
                start: 0,
                end: 1,
                speed: 1,
                amount: 1,
                minDuration: .1,
                attack: .01,
                release: .01,
                gap: 0
            },
            ugenOptions: {
                model: {
                    stepSize: 1,
                    activeVoices: [],
                    freeVoices: [],
                    stageSampleState: [ 0, 0, 0, 0 ],
                    lastIdx: 0,
                    inputState: {
                        numAttackSamps: 0,
                        numSustainSamps: 0,
                        numReleaseSamps: 0,
                        numDurationSamps: 0,
                        numGapSamps: 0
                    }
                },
                interpolation: "linear",
                envelopeType: "linear",
                maxVoices: 2,
                strideInputs: [ "speed" ]
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.ugen.print = function(e, t, n) {
            var f = D.ugen(e, t, n);
            return f.gen = function(e) {
                var t, n, r, a = f.inputs, o = f.output, i = f.model, u = i.label, s = a.channel, l = s ? a.source.output[s.output[0]] : a.source.output, c = a.trigger.output[0], d = a.freq.output[0];
                for (0 < c && i.prevTrig <= 0 && m.log(m.logLevel.IMPORTANT, u + l), i.freq !== d && (i.sampInterval = Math.round(i.sampleRate / d), 
                i.freq = d, i.counter = i.sampInterval), n = t = 0; t < e; t++, n += i.strides.source) i.counter >= i.sampInterval && (m.log(m.logLevel.IMPORTANT, u + l[n]), 
                i.counter = 0), i.counter++, o[t] = r = l[t];
                i.value = i.unscaledValue = r;
            }, f.init = function() {
                var e = f.options;
                f.model.label = e.label ? e.label + ": " : "", f.onInputChanged();
            }, f.init(), f;
        }, D.ugenDefaults("flock.ugen.print", {
            rate: "audio",
            inputs: {
                source: null,
                trigger: 0,
                freq: 1
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0,
                    counter: 0
                },
                strideInputs: [ "source" ]
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.ugen.distortion = function(e, t, n) {
            var f = D.ugen(e, t, n);
            return f.gen = function(e) {
                var t, n, r, a, o, i = f.model, u = f.output, s = f.inputs.source.output, l = i.strides.source, c = f.inputs.gain.output, d = i.strides.gain;
                for (r = a = o = 0; r < e; r++, a += l, o += d) n = 1.5 * (t = s[a] * c[o]) - .5 * t * t * t, 
                u[r] = n;
                i.unscaledValue = n, f.mulAdd(e), i.value = D.ugen.lastOutputValue(e, u);
            }, f.onInputChanged(), f;
        }, D.ugenDefaults("flock.ugen.distortion", {
            rate: "audio",
            inputs: {
                source: null,
                gain: 1
            },
            ugenOptions: {
                strideInputs: [ "source", "gain" ]
            }
        }), D.ugen.distortion.tanh = function(e, t, n) {
            var s = D.ugen(e, t, n);
            return s.gen = function(e) {
                var t, n, r, a = s.model, o = s.output, i = s.inputs.source.output, u = a.strides.source;
                for (n = r = 0; n < e; n++, r += u) t = Math.tanh(i[r]), o[n] = t;
                a.unscaledValue = t, s.mulAdd(e), a.value = D.ugen.lastOutputValue(e, o);
            }, s.onInputChanged(), s;
        }, D.ugenDefaults("flock.ugen.distortion.tanh", {
            rate: "audio",
            inputs: {
                source: null
            },
            ugenOptions: {
                strideInputs: [ "source" ]
            }
        }), D.ugen.distortion.deJong = function(e, t, n) {
            var m = D.ugen(e, t, n);
            return m.gen = function(e) {
                var t, n, r, a, o, i, u, s = m.model, l = m.output, c = m.inputs.source.output, d = s.strides.source, f = m.inputs.amount.output, p = s.strides.amount;
                for (o = i = u = 0; o < e; o++, i += d, u += p) t = c[i], n = f[u], a = t * ((r = Math.abs(t)) + n) / (t * t + (n - 1) * r + 1), 
                l[o] = a;
                s.unscaledValue = a, m.mulAdd(e), s.value = D.ugen.lastOutputValue(e, l);
            }, m.onInputChanged(), m;
        }, D.ugenDefaults("flock.ugen.distortion.deJong", {
            rate: "audio",
            inputs: {
                source: null,
                amount: 2
            },
            ugenOptions: {
                strideInputs: [ "source", "amount" ]
            }
        }), D.copyUGenDefinition("flock.ugen.distortion.deJong", "flock.ugen.distortion.deJonge"), 
        D.ugen.distortion.tarrabiaDeJong = function(e, t, n) {
            var m = D.ugen(e, t, n);
            return m.gen = function(e) {
                var t, n, r, a, o, i, u, s = m.model, l = m.output, c = m.inputs.source.output, d = s.strides.source, f = m.inputs.amount.output, p = s.strides.amount;
                for (a = o = i = 0; a < e; a++, o += d, i += p) t = c[o], 1 <= (n = f[i]) ? n = .9999999999999999 : n < -1 && (n = -1), 
                r = (1 + (u = 2 * n / (1 - n))) * t / (1 + u * Math.abs(t)), l[a] = r;
                s.unscaledValue = r, m.mulAdd(e), s.value = D.ugen.lastOutputValue(e, l);
            }, m.onInputChanged(), m;
        }, D.ugenDefaults("flock.ugen.distortion.tarrabiaDeJong", {
            rate: "audio",
            inputs: {
                source: null,
                amount: 1
            },
            ugenOptions: {
                strideInputs: [ "source", "amount" ]
            }
        }), D.copyUGenDefinition("flock.ugen.distortion.tarrabiaDeJong", "flock.ugen.distortion.tarrabiaDeJonge"), 
        D.ugen.distortion.gloubiBoulga = function(e, t, n) {
            var m = D.ugen(e, t, n);
            return m.gen = function(e) {
                var t, n, r, a, o, i, u, s = m.model, l = m.output, c = m.inputs.source.output, d = s.strides.source, f = m.inputs.gain.output, p = s.strides.gain;
                for (n = r = a = 0; n < e; n++, r += d, a += p) o = .686306 * (c[r] * f[a]), i = 1 + Math.exp(-.75 * Math.sqrt(Math.abs(o))), 
                t = ((u = Math.exp(o)) - Math.exp(-o * i)) / (u + Math.exp(-o)), l[n] = t;
                s.unscaledValue = t, m.mulAdd(e), s.value = D.ugen.lastOutputValue(e, l);
            }, m.onInputChanged(), m;
        }, D.ugenDefaults("flock.ugen.distortion.gloubiBoulga", {
            rate: "audio",
            inputs: {
                source: null,
                gain: 1
            },
            ugenOptions: {
                strideInputs: [ "source", "gain" ]
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.ugen.normalize = function(e, t, n) {
            var a = D.ugen(e, t, n);
            return a.gen = function() {
                var e = a.model, t = a.output, n = a.inputs.max.output[0], r = a.inputs.source.output;
                D.normalize(r, n, t), e.value = e.unscaledValue = t[t.length - 1];
            }, a.onInputChanged(), a;
        }, D.ugenDefaults("flock.ugen.normalize", {
            rate: "audio",
            inputs: {
                max: 1,
                source: null
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var o = m.registerNamespace("jQuery"), n = D.requireModule("webarraymath", "ArrayMath");
        D.envelope = {}, D.envelope.makeCreator = function(r, a) {
            return function(e) {
                var t = D.ugenDefaults(r), n = o.extend(!0, {}, t, e);
                return a(n);
            };
        }, D.envelope.registerCreators = function(e, t) {
            var n, r;
            for (var a in t) n = m.pathUtil.composePath(e, a), r = t[a], D.ugenDefaults(n, r.defaults), 
            m.setGlobalValue(n, D.envelope.makeCreator(n, r.transformer));
        }, D.envelope.creatorSpecs = {
            line: {
                transformer: function(e) {
                    return {
                        levels: [ e.start, e.end ],
                        times: [ e.duration ]
                    };
                },
                defaults: {
                    start: 0,
                    end: 1,
                    duration: 1
                }
            },
            linear: {
                transformer: function(e) {
                    return {
                        levels: [ 0, e.level, e.level, 0 ],
                        times: [ e.attack, e.sustain, e.release ]
                    };
                },
                defaults: {
                    level: 1,
                    attack: .01,
                    sustain: 1,
                    release: 1
                }
            },
            tri: {
                transformer: function(e) {
                    return {
                        levels: [ 0, e.level, 0 ],
                        times: [ e.duration, e.duration ]
                    };
                },
                defaults: {
                    level: 1,
                    duration: 1
                }
            },
            sin: {
                transformer: function(e) {
                    return {
                        levels: [ 0, e.level, 0 ],
                        times: [ e.duration, e.duration ],
                        curve: "sin"
                    };
                },
                defaults: {
                    level: 1,
                    duration: 1
                }
            },
            asr: {
                transformer: function(e) {
                    return {
                        levels: [ 0, e.sustain, 0 ],
                        times: [ e.attack, e.release ],
                        sustainPoint: 1,
                        curve: -4
                    };
                },
                defaults: {
                    sustain: 1,
                    attack: .01,
                    release: 1
                }
            },
            dadsr: {
                transformer: function(e) {
                    var t = [ 0, 0, e.peak, e.peak * e.sustain, 0 ];
                    return n.add(t, e.bias, t), {
                        levels: t,
                        times: [ e.delay, e.attack, e.decay, e.release ],
                        sustainPoint: 3,
                        curve: -4
                    };
                },
                defaults: {
                    delay: .1,
                    attack: .01,
                    decay: .3,
                    sustain: .5,
                    release: 1,
                    peak: 1,
                    bias: 0
                }
            },
            adsr: {
                transformer: function(e) {
                    var t = [ 0, e.peak, e.peak * e.sustain, 0 ];
                    return n.add(t, e.bias, t), {
                        levels: t,
                        times: [ e.attack, e.decay, e.release ],
                        sustainPoint: 2,
                        curve: -4
                    };
                },
                defaults: {
                    attack: .01,
                    decay: .3,
                    sustain: .5,
                    release: 1,
                    peak: 1,
                    bias: 0
                }
            }
        }, D.envelope.registerCreators("flock.envelope", D.envelope.creatorSpecs), D.envelope.validate = function(e, t) {
            var n = e.levels, r = {};
            if (e.times ? !n || n.length < 2 ? r.levels = "An array containing at least two levels must be specified." : (D.envelope.validate.times(e.times, n, r), 
            D.envelope.validate.levels(n, r), D.envelope.validate.curves(e.curve, n, r), D.envelope.validate.sustainPoint(e.sustainPoint, n, r)) : r.times = "An array containing at least one time value must be specified.", 
            !1 !== t) for (var a in r) D.fail(r[a]);
            return r;
        }, D.envelope.validate.times = function(e, t, n) {
            e.length !== t.length - 1 && (n.times = "The envelope specification should provide one fewer time value than the number of level values. times: " + e + " levels: " + t);
            for (var r = 0; r < e.length; r++) {
                var a = e[r];
                isNaN(a) && (n.times = "A NaN time value was specified at index " + r + ". times: " + e), 
                a < 0 && (n.times = "All times should be positive values. times: " + e);
            }
        }, D.envelope.validate.levels = function(e, t) {
            for (var n = 0; n < e.length; n++) isNaN(e[n]) && (t.levels = "A NaN level value was specified at index " + n + ". levels: " + e);
        }, D.envelope.validate.curves = function(t, e, n) {
            if (!t) return n;
            D.isIterable(t) && (t.length !== e.length - 1 && (n.curve = "When curve is specified as an array, there should be one fewer curve value than the number of level values. curve: " + t + " levels: " + e), 
            m.each(t, function(e) {
                D.lineGenerator(e) || (n.curve = "'" + e + "' is not a valid curve type. curve: " + t);
            })), D.lineGenerator(t) || (n.curve = "'" + t + "' is not a valid curve type.");
        }, D.envelope.validate.sustainPoint = function(e, t, n) {
            (e < 0 || e >= t.length) && (n.sustainPoint = "The specified sustainPoint index is out range for the levels array. sustainPoint: " + e + " levels: " + t);
        }, D.envelope.expand = function(e) {
            var t = "string" == typeof e ? m.invokeGlobalFunction(e) : e.type ? m.invokeGlobalFunction(e.type, [ e ]) : e;
            if (t.curves && !t.curve && (t.curve = t.curves), !D.isIterable(t.curve)) {
                var n = t.levels.length - 1;
                t.curve = D.fillBufferWithValue(new Array(n), t.curve);
            }
            return D.envelope.validate(t, !0), t;
        }, D.fillBufferWithLine = function(e, t, n, r, a, o) {
            a = void 0 === a ? 0 : a;
            var i = (o = void 0 === o ? t.length : o) - a, u = D.fillBufferWithLine.singletonModel;
            u.unscaledValue = n, u.destination = r, u.numSegmentSamps = i - 1, "number" == typeof e && (u.currentCurve = e, 
            e = "curve");
            var s = D.line[e];
            return s || D.fail("No line generator could be found for type " + e), s.init(u), 
            s.gen(i, a, t, u);
        }, D.fillBufferWithLine.singletonModel = {
            unscaledValue: 0,
            value: 0,
            destination: 1
        }, D.lineGenerator = function(e) {
            var t = typeof e;
            return "string" == t ? D.line[e] : "number" == t ? D.line.curve : D.line.linear;
        }, D.line = {
            constant: {
                init: function(e) {
                    e.stepSize = 0;
                },
                gen: function(e, t, n, r) {
                    for (var a = r.unscaledValue, o = t; o < e + t; o++) n[o] = a;
                    return n;
                }
            },
            step: {
                init: function(e) {
                    e.arrived = !1;
                },
                gen: function(e, t, n, r) {
                    for (var a = t; a < e + t; a++) n[a] = r.unscaledValue, r.arrived || (r.arrived = !0, 
                    r.unscaledValue = r.destination);
                    return n;
                }
            },
            linear: {
                init: function(e) {
                    e.stepSize = (e.destination - e.unscaledValue) / e.numSegmentSamps;
                },
                gen: function(e, t, n, r) {
                    for (var a = r.unscaledValue, o = r.stepSize, i = t; i < e + t; i++) n[i] = a, a += o;
                    return r.unscaledValue = a, n;
                }
            },
            exponential: {
                init: function(e) {
                    0 === e.unscaledValue && (e.unscaledValue = 1e-16), e.stepSize = 0 === e.numSegmentSamps ? 0 : Math.pow(e.destination / e.unscaledValue, 1 / e.numSegmentSamps);
                },
                gen: function(e, t, n, r) {
                    for (var a = r.unscaledValue, o = r.stepSize, i = t; i < e + t; i++) n[i] = a, a *= o;
                    return r.unscaledValue = a, r.stepSize = o, n;
                }
            },
            curve: {
                init: function(e) {
                    if (Math.abs(e.currentCurve) < .001) return D.line.linear.init(e);
                    var t = (e.destination - e.unscaledValue) / (1 - Math.exp(e.currentCurve));
                    e.a2 = e.unscaledValue + t, e.b1 = t, e.stepSize = Math.exp(e.currentCurve / e.numSegmentSamps);
                },
                gen: function(e, t, n, r) {
                    for (var a = r.unscaledValue, o = r.b1, i = t; i < e + t; i++) n[i] = a, o *= r.stepSize, 
                    a = r.a2 - o;
                    return r.unscaledValue = a, r.b1 = o, n;
                }
            },
            sin: {
                init: function(e) {
                    var t = Math.PI / e.numSegmentSamps;
                    e.a2 = .5 * (e.destination + e.unscaledValue), e.b1 = 2 * Math.cos(t), e.y1 = .5 * (e.destination - e.unscaledValue), 
                    e.y2 = e.y1 * Math.sin(D.HALFPI - t), e.unscaledValue = e.a2 - e.y1;
                },
                gen: function(e, t, n, r) {
                    for (var a, o = r.unscaledValue, i = r.y1, u = r.y2, s = t; s < e + t; s++) n[s] = o, 
                    a = r.b1 * i - u, o = r.a2 - a, u = i, i = a;
                    return r.unscaledValue = o, r.y1 = i, r.y2 = u, n;
                }
            },
            welsh: {
                init: function(e) {
                    var t = D.HALFPI / e.numSegmentSamps, n = Math.cos(t);
                    e.b1 = 2 * n, e.destination >= e.unscaledValue ? (e.a2 = e.unscaledValue, e.y1 = 0, 
                    e.y2 = -Math.sin(t) * (e.destination - e.unscaledValue)) : (e.a2 = e.destination, 
                    e.y1 = e.unscaledValue - e.destination, e.y2 = n * (e.unscaledValue - e.destination)), 
                    e.unscaledValue = e.a2 + e.y1;
                },
                gen: function(e, t, n, r) {
                    for (var a, o = r.unscaledValue, i = r.y1, u = r.y2, s = t; s < e + t; s++) n[s] = o, 
                    a = r.b1 * i - u, u = i, i = a, o = r.a2 + a;
                    return r.unscaledValue = o, r.y1 = i, r.y2 = u, n;
                }
            },
            squared: {
                init: function(e) {
                    e.y1 = Math.sqrt(e.unscaledValue), e.y2 = Math.sqrt(e.destination), e.stepSize = (e.y2 - e.y1) / e.numSegmentSamps;
                },
                gen: function(e, t, n, r) {
                    for (var a = r.unscaledValue, o = r.y1, i = t; i < e + t; i++) n[i] = a, a = (o += r.stepSize) * o;
                    return r.y1 = o, r.unscaledValue = a, n;
                }
            },
            cubed: {
                init: function(e) {
                    var t = .3333333333333333;
                    e.y1 = Math.pow(e.unscaledValue, t), e.y2 = Math.pow(e.destination, t), e.stepSize = (e.y2 - e.y1) / e.numSegmentSamps;
                },
                gen: function(e, t, n, r) {
                    for (var a = r.unscaledValue, o = r.y1, i = t; i < e + t; i++) n[i] = a, a = (o += r.stepSize) * o * o;
                    return r.y1 = o, r.unscaledValue = a, n;
                }
            }
        }, D.ugen.line = function(e, t, n) {
            var l = D.ugen(e, t, n);
            return l.gen = function(e) {
                var t, n = l.model, r = n.stepSize, a = n.numSteps, o = e <= a ? e : a, i = e - o, u = n.level, s = l.output;
                for (t = 0; t < o; t++) s[t] = u, a--, u += r;
                if (0 < i) for (t = 0; t < i; t++) s[t] = u;
                n.level = n.unscaledValue = u, n.numSteps = a, l.mulAdd(e), n.value = D.ugen.lastOutputValue(e, s);
            }, l.onInputChanged = function() {
                var e = l.model;
                e.start = l.inputs.start.output[0], e.end = l.inputs.end.output[0], e.numSteps = Math.round(l.inputs.duration.output[0] * e.sampleRate), 
                0 === e.numSteps ? (e.stepSize = 0, e.level = e.end) : (e.stepSize = (e.end - e.start) / e.numSteps, 
                e.level = e.start), D.onMulAddInputChanged(l);
            }, l.onInputChanged(), l;
        }, D.ugenDefaults("flock.ugen.line", {
            rate: "control",
            inputs: {
                start: 0,
                end: 1,
                duration: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    start: 0,
                    end: 1,
                    numSteps: 0,
                    stepSize: 0,
                    level: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), D.ugen.xLine = function(e, t, n) {
            var l = D.ugen(e, t, n);
            return l.gen = function(e) {
                var t, n = l.model, r = n.multiplier, a = n.numSteps, o = e <= a ? e : a, i = e - o, u = n.level, s = l.output;
                for (t = 0; t < o; t++) s[t] = u, a--, u *= r;
                if (0 < i) for (t = 0; t < i; t++) s[t] = u;
                n.level = n.unscaledValue = u, n.numSteps = a, l.mulAdd(e), n.value = D.ugen.lastOutputValue(e, s);
            }, l.onInputChanged = function() {
                var e = l.model;
                D.onMulAddInputChanged(l), e.start = l.inputs.start.output[0], 0 === e.start && (e.start = 1e-101), 
                e.end = l.inputs.end.output[0], e.numSteps = Math.round(l.inputs.duration.output[0] * e.sampleRate), 
                e.multiplier = Math.pow(e.end / e.start, 1 / e.numSteps), e.level = e.start;
            }, l.onInputChanged(), l;
        }, D.ugenDefaults("flock.ugen.xLine", {
            rate: "control",
            inputs: {
                start: 0,
                end: 1,
                duration: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    start: 0,
                    end: 1,
                    numSteps: 0,
                    multiplier: 0,
                    level: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), D.ugen.asr = function(e, t, n) {
            var m = D.ugen(e, t, n);
            return m.gen = function(e) {
                var t, n, r = m.model, a = m.output, o = r.previousGate, i = m.inputs.gate.output[0], u = r.level, s = r.stage, l = s.currentStep, c = s.stepInc, d = s.numSteps, f = r.targetLevel, p = !1;
                for (o <= 0 && 0 < i ? (f = m.inputs.sustain.output[0], t = m.inputs.attack.output[0], 
                p = !0) : 0 <= o && i <= 0 && d <= l && (f = m.inputs.start.output[0], t = m.inputs.release.output[0], 
                p = !0), p && (c = 0 < (d = Math.round(t * r.sampleRate)) ? (f - u) / d : 0, l = 0, 
                d < 1 && (u = f)), n = 0; n < e; n++) a[n] = u, u = ++l < d ? u + c : l === d ? f : u;
                r.level = r.unscaledValue = u, r.targetLevel = f, r.previousGate = i, s.currentStep = l, 
                s.stepInc = c, s.numSteps = d, m.mulAdd(e), r.value = D.ugen.lastOutputValue(e, a);
            }, m.init = function() {
                var e = m.model;
                e.level = e.unscaledValue = m.inputs.start.output[0], e.targetLevel = m.inputs.sustain.output[0], 
                m.onInputChanged();
            }, m.init(), m;
        }, D.ugenDefaults("flock.ugen.asr", {
            rate: "control",
            inputs: {
                start: 0,
                attack: .01,
                sustain: 1,
                release: 1,
                gate: 0,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    level: 0,
                    targetLevel: 0,
                    previousGate: 0,
                    unscaledValue: 0,
                    value: 0,
                    stage: {
                        currentStep: 0,
                        stepInc: 0,
                        numSteps: 0
                    }
                }
            }
        }), D.copyUGenDefinition("flock.ugen.asr", "flock.ugen.env.simpleASR"), D.ugen.envGen = function(e, t, n) {
            var s = D.ugen(e, t, n);
            return s.krGen = function(e) {
                var t, n = s.model, r = s.output, a = s.inputs, o = a.gate.output[0], i = a.timeScale.output[0], u = 0;
                for (D.ugen.envGen.checkGate(s, o, i); u < e; ) t = Math.min(e - u, n.numSegmentSamps), 
                s.lineGen.gen(t, u, r, n), u += t, n.numSegmentSamps -= t, n.numSegmentSamps <= 0 && D.ugen.envGen.nextStage(s, i);
                s.mulAdd(e), n.value = D.ugen.lastOutputValue(e, r);
            }, s.arGen = function(e) {
                var t, n = s.model, r = s.output, a = s.inputs, o = a.gate.output, i = a.timeScale.output[0];
                for (t = 0; t < e; t++) D.ugen.envGen.checkGate(s, o[t], i), s.lineGen.gen(1, t, r, n), 
                n.numSegmentSamps--, n.numSegmentSamps <= 0 && D.ugen.envGen.nextStage(s, i);
                s.mulAdd(e), n.value = D.ugen.lastOutputValue(e, r);
            }, s.onInputChanged = function(e) {
                e && "envelope" !== e || (s.envelope = D.ugen.envGen.initEnvelope(s, s.inputs.envelope)), 
                e && "gate" !== e || (s.gen = s.inputs.gate.rate === D.rates.AUDIO ? s.arGen : s.krGen), 
                D.onMulAddInputChanged(s);
            }, s.onInputChanged(), s;
        }, D.ugen.envGen.initEnvelope = function(e, t) {
            var n = e.model, r = D.envelope.expand(t);
            return n.stage = 0, n.numStages = r.times.length, e.lineGen = D.line.constant, D.ugen.envGen.lineGenForStage(e.inputs.timeScale.output[0], r, n), 
            n.unscaledValue = r.levels[n.stage], r;
        }, D.ugen.envGen.checkGate = function(e, t, n) {
            var r = e.model, a = e.envelope;
            t !== r.previousGate && (0 < t && r.previousGate <= 0 ? (r.stage = 1, e.lineGen = D.ugen.envGen.lineGenForStage(n, a, r)) : t <= 0 && 0 < r.previousGate && (r.stage = r.numStages, 
            e.lineGen = D.ugen.envGen.lineGenForStage(n, a, r))), r.previousGate = t;
        }, D.ugen.envGen.nextStage = function(e, t) {
            var n = e.model, r = e.envelope;
            n.stage === r.sustainPoint ? (e.lineGen = D.line.constant, n.numSegmentSamps = 1 / 0, 
            n.destination = n.unscaledValue) : (n.stage++, e.lineGen = D.ugen.envGen.lineGenForStage(t, r, n));
        }, D.ugen.envGen.setupStage = function(e, t, n) {
            var r, a, o = t.levels[n.stage];
            a = 0 === n.stage || n.stage > n.numStages ? 1 / 0 : (r = t.times[n.stage - 1] * e, 
            Math.max(1, Math.round(r * n.sampleRate))), n.numSegmentSamps = a, n.destination = o;
        }, D.ugen.envGen.lineGenForStage = function(e, t, n) {
            var r, a, o = t.curve;
            return r = 0 === n.stage || n.stage > n.numStages ? D.line.constant : (a = o[n.stage - 1], 
            n.currentCurve = a, D.lineGenerator(a)), D.ugen.envGen.setupStage(e, t, n), r.init(n), 
            r;
        }, D.ugenDefaults("flock.ugen.envGen", {
            rate: "audio",
            inputs: {
                envelope: "flock.envelope.adsr",
                gate: 0,
                timeScale: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    previousGate: 0,
                    stepSize: 0,
                    destination: 0,
                    numSegmentSamps: 1,
                    unscaledValue: 0,
                    value: 0,
                    stage: 0,
                    numStages: 0
                }
            }
        }), D.ugen.phasor = function(e, t, n) {
            var l = D.ugen(e, t, n);
            return l.gen = function(e) {
                var t, n, r, a = l.model, o = l.inputs, i = l.output, u = o.step.output, s = o.trigger.output;
                for (void 0 === a.unscaledValue && (a.unscaledValue = o.start.output[0]), r = n = t = 0; t < e; t++, 
                n += a.strides.trigger, r += a.strides.step) 0 < s[n] && a.prevTrig <= 0 && (a.unscaledValue = o.reset.output[0]), 
                a.prevTrig = s[n], a.unscaledValue >= o.end.output[0] && (a.unscaledValue = o.start.output[0]), 
                i[t] = a.unscaledValue, a.unscaledValue += u[r];
                l.mulAdd(e), a.value = D.ugen.lastOutputValue(e, i);
            }, l.onInputChanged(), l;
        }, D.ugenDefaults("flock.ugen.phasor", {
            rate: "control",
            inputs: {
                start: 0,
                end: 1,
                reset: 0,
                step: .1,
                trigger: 0,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    unscaledValue: void 0,
                    value: 0
                },
                strideInputs: [ "trigger", "step" ]
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var r = D.requireModule("webarraymath", "Filter");
        D.ugen.lag = function(e, t, n) {
            var f = D.ugen(e, t, n);
            return f.gen = function(e) {
                var t, n, r, a, o = f.model, i = f.output, u = f.inputs, s = u.time.output[0], l = u.source.output, c = o.prevSamp, d = o.lagCoef;
                for (s !== o.prevTime && (o.prevtime = s, d = o.lagCoef = 0 === s ? 0 : Math.exp(D.LOG001 / (s * o.sampleRate))), 
                t = n = 0; t < e; t++, n += o.strides.source) a = (r = l[n]) + d * (c - r), i[t] = c = a;
                o.prevSamp = c, f.mulAdd(e);
            }, f.onInputChanged(), f;
        }, D.ugenDefaults("flock.ugen.lag", {
            rate: "audio",
            inputs: {
                source: null,
                time: .1
            },
            ugenOptions: {
                strideInputs: [ "source" ],
                model: {
                    prevSamp: 0,
                    lagCoef: 0,
                    prevTime: 0
                }
            }
        }), D.ugen.filter = function(e, t, n) {
            var o = D.ugen(e, t, n);
            return o.gen = function() {
                var e = o.model, t = o.output, n = o.inputs, r = n.q.output[0], a = n.freq.output[0];
                e.prevFreq === a && e.prevQ === r || o.updateCoefficients(e, a, r), o.filterEngine.filter(t, o.inputs.source.output), 
                e.prevQ = r, e.prevFreq = a, e.value = e.unscaledValue = t[t.length - 1];
            }, o.init = function() {
                var e = o.options.recipe, t = "string" == typeof e ? D.get(e) : e;
                if (!t) throw new Error("Can't instantiate a flock.ugen.filter() without specifying a filter coefficient recipe.");
                o.filterEngine = new r(t.sizes.b, t.sizes.a), o.model.coeffs = {
                    a: o.filterEngine.a,
                    b: o.filterEngine.b
                }, o.updateCoefficients = D.get(t, o.options.type), o.onInputChanged();
            }, o.init(), o;
        }, D.ugenDefaults("flock.ugen.filter", {
            rate: "audio",
            inputs: {
                freq: 440,
                q: 1,
                source: null
            }
        }), D.ugen.filter.biquad = function(e, t, n) {
            var c = D.ugen(e, t, n);
            return c.gen = function(e) {
                var t, n, r = c.model, a = c.inputs, o = c.output, i = r.coeffs, u = a.freq.output[0], s = a.q.output[0], l = a.source.output;
                for (r.prevFreq === u && r.prevQ === s || c.updateCoefficients(r, u, s), t = 0; t < e; t++) n = l[t] - i.a[0] * r.d0 - i.a[1] * r.d1, 
                o[t] = i.b[0] * n + i.b[1] * r.d0 + i.b[2] * r.d1, r.d1 = r.d0, r.d0 = n;
                r.prevQ = s, r.prevFreq = u, r.value = r.unscaledValue = D.ugen.lastOutputValue(e, o);
            }, c.onInputChanged = function() {
                var e = c.options.type;
                c.updateCoefficients = "string" == typeof e ? D.get(e) : e;
            }, c.init = function() {
                c.model.d0 = 0, c.model.d1 = 0, c.model.coeffs = {
                    a: new Float32Array(2),
                    b: new Float32Array(3)
                }, c.onInputChanged();
            }, c.init(), c;
        }, D.ugenDefaults("flock.ugen.filter.biquad", {
            inputs: {
                freq: 440,
                q: 1,
                source: null
            }
        }), D.ugen.filter.biquad.types = {
            hp: {
                inputDefaults: {
                    freq: 440,
                    q: 1
                },
                options: {
                    type: "flock.coefficients.butterworth.highPass"
                }
            },
            rhp: {
                inputDefaults: {
                    freq: 440,
                    q: 1
                },
                options: {
                    type: "flock.coefficients.rbj.highPass"
                }
            },
            lp: {
                inputDefaults: {
                    freq: 440,
                    q: 1
                },
                options: {
                    type: "flock.coefficients.butterworth.lowPass"
                }
            },
            rlp: {
                inputDefaults: {
                    freq: 440,
                    q: 1
                },
                options: {
                    type: "flock.coefficients.rbj.lowPass"
                }
            },
            bp: {
                inputDefaults: {
                    freq: 440,
                    q: 4
                },
                options: {
                    type: "flock.coefficients.butterworth.bandPass"
                }
            },
            br: {
                inputDefaults: {
                    freq: 440,
                    q: 1
                },
                options: {
                    type: "flock.coefficients.butterworth.bandReject"
                }
            }
        }, D.aliasUGens("flock.ugen.filter.biquad", D.ugen.filter.biquad.types), D.coefficients = {
            butterworth: {
                sizes: {
                    a: 2,
                    b: 3
                },
                lowPass: function(e, t) {
                    var n = e.coeffs, r = 1 / Math.tan(Math.PI * t / e.sampleRate), a = r * r, o = D.ROOT2 * r, i = 1 / (1 + o + a);
                    n.b[0] = i, n.b[1] = 2 * i, n.b[2] = i, n.a[0] = 2 * (1 - a) * i, n.a[1] = (1 - o + a) * i;
                },
                highPass: function(e, t) {
                    var n = e.coeffs, r = Math.tan(Math.PI * t / e.sampleRate);
                    r === 1 / 0 && (r = 0);
                    var a = r * r, o = D.ROOT2 * r, i = 1 / (1 + o + a);
                    n.b[0] = i, n.b[1] = -2 * i, n.b[2] = i, n.a[0] = 2 * (a - 1) * i, n.a[1] = (1 - o + a) * i;
                },
                bandPass: function(e, t, n) {
                    var r = e.coeffs, a = t / n, o = 1 / Math.tan(Math.PI * a / e.sampleRate), i = 2 * Math.cos(D.TWOPI * t / e.sampleRate), u = 1 / (1 + o);
                    r.b[0] = u, r.b[1] = 0, r.b[2] = -u, r.a[0] = -o * i * u, r.a[1] = u * (o - 1);
                },
                bandReject: function(e, t, n) {
                    var r = e.coeffs, a = t / n, o = Math.tan(Math.PI * a / e.sampleRate), i = 1 / (1 + o), u = -(2 * Math.cos(D.TWOPI * t / e.sampleRate)) * i;
                    r.b[0] = i, r.b[1] = u, r.b[2] = i, r.a[0] = u, r.a[1] = (1 - o) * i;
                }
            },
            rbj: {
                sizes: {
                    a: 2,
                    b: 3
                },
                lowPass: function(e, t, n) {
                    var r = e.coeffs, a = D.TWOPI * t / e.sampleRate, o = Math.cos(a), i = Math.sin(a) / (2 * n), u = 1 - o, s = 1 + i, l = u / 2 / s;
                    r.b[0] = l, r.b[1] = u / s, r.b[2] = l, r.a[0] = -2 * o / s, r.a[1] = (1 - i) / s;
                },
                highPass: function(e, t, n) {
                    var r = e.coeffs, a = D.TWOPI * t / e.sampleRate, o = Math.cos(a), i = Math.sin(a) / (2 * n), u = 1 + o, s = 1 + i, l = u / 2 / s;
                    r.b[0] = l, r.b[1] = -u / s, r.b[2] = l, r.a[0] = -2 * o / s, r.a[1] = (1 - i) / s;
                },
                bandPass: function(e, t, n) {
                    var r = e.coeffs, a = D.TWOPI * t / e.sampleRate, o = Math.cos(a), i = Math.sin(a) / (2 * n), u = 1 + i, s = n * i;
                    r.b[0] = s / u, r.b[1] = 0, r.b[2] = -s / u, r.a[0] = -2 * o / u, r.a[1] = (1 - i) / u;
                },
                bandReject: function(e, t, n) {
                    var r = e.coeffs, a = D.TWOPI * t / e.sampleRate, o = Math.cos(a), i = Math.sin(a) / (2 * n), u = 1 + i, s = 1 / u, l = -2 * o / u;
                    r.b[0] = s, r.b[1] = l, r.b[2] = s, r.a[0] = l, r.a[1] = (1 - i) / u;
                }
            }
        }, D.ugen.filter.moog = function(e, t, n) {
            var C = D.ugen(e, t, n);
            return C.gen = function(e) {
                var t, n, r, a, o, i, u, s = C.model, l = C.inputs, c = C.output, d = l.source.output, f = s.strides.source, p = l.resonance.output, m = s.strides.resonance, g = l.cutoff.output, h = s.strides.cutoff, v = s.f, y = s.fSq, b = s.fSqSq, k = s.oneMinusF, S = s.fb;
                for (t = n = r = a = 0; t < e; t++, n += f, r += m, a += h) o = g[a], i = p[r], 
                o !== s.prevCutoff && (o > s.nyquistRate && (o = s.nyquistRate), v = s.f = o / s.nyquistRate * 1.16, 
                y = s.fSq = v * v, b = s.fSqSq = y * y, k = s.oneMinusF = 1 - v, s.prevRes = void 0), 
                i !== s.prevRes && (4 < i ? i = 4 : i < 0 && (i = 0), S = s.fb = i * (1 - .15 * y)), 
                u = d[n] - s.out4 * S, u *= .35013 * b, s.out1 = u + .3 * s.in1 + k * s.out1, s.in1 = u, 
                s.out2 = s.out1 + .3 * s.in2 + k * s.out2, s.in2 = s.out1, s.out3 = s.out2 + .3 * s.in3 + k * s.out3, 
                s.in3 = s.out2, s.out4 = s.out3 + .3 * s.in4 + k * s.out4, s.in4 = s.out3, c[t] = s.out4;
                s.unscaledValue = s.out4, C.mulAdd(e), s.value = D.ugen.lastOutputValue(e, c);
            }, C.onInputChanged(), C;
        }, D.ugenDefaults("flock.ugen.filter.moog", {
            rate: "audio",
            inputs: {
                cutoff: 3e3,
                resonance: 3.99,
                source: null
            },
            ugenOptions: {
                model: {
                    in1: 0,
                    in2: 0,
                    in3: 0,
                    in4: 0,
                    out1: 0,
                    out2: 0,
                    out3: 0,
                    out4: 0,
                    prevCutoff: void 0,
                    prevResonance: void 0,
                    f: void 0,
                    fSq: void 0,
                    fSqSq: void 0,
                    oneMinusF: void 0,
                    fb: void 0,
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "source", "cutoff", "resonance" ]
            }
        }), D.ugen.delay = function(e, t, n) {
            var l = D.ugen(e, t, n);
            return l.gen = function(e) {
                var t, n, r = l.model, a = l.inputs, o = l.output, i = a.source.output, u = a.time.output[0], s = l.delayBuffer;
                for (u !== r.time && (r.time = u, r.delaySamps = u * l.model.sampleRate), t = 0; t < e; t++) r.pos >= r.delaySamps && (r.pos = 0), 
                o[t] = n = s[r.pos], s[r.pos] = i[t], r.pos++;
                r.unscaledValue = n, l.mulAdd(e), r.value = D.ugen.lastOutputValue(e, o);
            }, l.onInputChanged = function(e) {
                if (D.onMulAddInputChanged(l), !e || "maxTime" === e) {
                    var t = l.model.sampleRate * l.inputs.maxTime.output[0];
                    l.delayBuffer = new Float32Array(t);
                }
            }, l.onInputChanged(), l;
        }, D.ugenDefaults("flock.ugen.delay", {
            rate: "audio",
            inputs: {
                maxTime: 1,
                time: 1,
                source: null
            },
            ugenOptions: {
                model: {
                    pos: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), D.ugen.delay1 = function(e, t, n) {
            var s = D.ugen(e, t, n);
            return s.gen = function(e) {
                var t, n, r = s.model, a = s.inputs, o = s.output, i = a.source.output, u = r.prevVal;
                for (t = 0; t < e; t++) o[t] = n = u, u = i[t];
                r.prevVal = u, r.unscaledValue = n, s.mulAdd(e), r.value = D.ugen.lastOutputValue(e, o);
            }, s.onInputChanged = function() {
                D.onMulAddInputChanged(s);
            }, s.onInputChanged(), s;
        }, D.ugenDefaults("flock.ugen.delay1", {
            rate: "audio",
            inputs: {
                source: null
            },
            ugenOptions: {
                model: {
                    prevVal: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), D.ugen.freeverb = function(e, t, n) {
            var y = D.ugen(e, t, n);
            return y.tunings = y.options.tunings, y.allpassTunings = y.options.allpassTunings, 
            y.gen = function(e) {
                var t, n, r, a = y.model, o = y.inputs, i = y.output, u = o.source.output, s = o.mix.output[0], l = 1 - s, c = .28 * o.room.output[0] + .7, d = .4 * o.damp.output[0], f = 1 - d;
                for (t = 0; t < e; t++) {
                    var p = u[t], m = .015 * p;
                    for (n = 0; n < y.buffers_a.length; n++) ++y.bufferindices_a[n] === y.allpassTunings[n] && (y.bufferindices_a[n] = 0), 
                    y.readsamp_a[n] = y.buffers_a[n][y.bufferindices_a[n]];
                    for (n = 0; n < y.buffers_c.length; n++) {
                        ++y.bufferindices_c[n] === y.tunings[n] && (y.bufferindices_c[n] = 0);
                        var g = y.bufferindices_c[n], h = y.buffers_c[n][g];
                        y.filterx_c[n] = f * y.filtery_c[n] + d * y.filterx_c[n], y.buffers_c[n][g] = m + c * y.filterx_c[n], 
                        y.filtery_c[n] = h;
                    }
                    var v = y.filtery_c[6] + y.filtery_c[7];
                    y.buffers_a[3][y.bufferindices_a[3]] = .5 * y.filterx_a[3] + y.filtery_c[0] + (y.filtery_c[1] + y.filtery_c[2]) + (y.filtery_c[3] + y.filtery_c[4] + (y.filtery_c[5] + v)), 
                    y.filterx_a[3] = y.readsamp_a[3], y.filtery_a[3] = y.filterx_a[3] - (y.filtery_c[0] + y.filtery_c[1] + (y.filtery_c[2] + y.filtery_c[3]) + (y.filtery_c[4] + y.filtery_c[5] + v)), 
                    y.buffers_a[2][y.bufferindices_a[2]] = .5 * y.filterx_a[2] + y.filtery_a[3], y.filterx_a[2] = y.readsamp_a[2], 
                    y.filtery_a[2] = y.filterx_a[2] - y.filtery_a[3], y.buffers_a[1][y.bufferindices_a[1]] = .5 * y.filterx_a[1] + y.filtery_a[2], 
                    y.filterx_a[1] = y.readsamp_a[1], y.filtery_a[1] = y.filterx_a[1] - y.filtery_a[2], 
                    y.buffers_a[0][y.bufferindices_a[0]] = .5 * y.filterx_a[0] + y.filtery_a[1], y.filterx_a[0] = y.readsamp_a[0], 
                    y.filtery_a[0] = y.filterx_a[0] - y.filtery_a[1], r = l * p + s * y.filtery_a[0], 
                    i[t] = r;
                }
                a.unscaledValue = r, y.mulAdd(e), a.value = D.ugen.lastOutputValue(e, i);
            }, y.initDelayLines = function() {
                y.buffers_c = new Array(8), y.bufferindices_c = new Int32Array(8), y.filterx_c = new Float32Array(8), 
                y.filtery_c = new Float32Array(8);
                var e, t, n = y.model.spread;
                for (e = 0; e < y.buffers_c.length; e++) for (y.buffers_c[e] = new Float32Array(y.tunings[e] + n), 
                y.bufferindices_c[e] = 0, y.filterx_c[e] = 0, t = y.filtery_c[e] = 0; t < y.tunings[e] + n; t++) y.buffers_c[e][t] = 0;
                for (y.buffers_a = new Array(4), y.bufferindices_a = new Int32Array(4), y.filterx_a = new Float32Array(4), 
                y.filtery_a = new Float32Array(4), y.readsamp_a = new Float32Array(4), e = 0; e < y.buffers_a.length; e++) {
                    for (y.bufferindices_a[e] = 0, y.filterx_a[e] = 0, y.filtery_a[e] = 0, t = y.readsamp_a[e] = 0; t < y.allpassTunings.length; t++) y.allpassTunings[t] += n;
                    for (y.buffers_a[e] = new Float32Array(y.allpassTunings[e]), t = 0; t < y.allpassTunings[e]; t++) y.buffers_a[e][t] = 0;
                }
            }, y.init = function() {
                y.initDelayLines(), y.onInputChanged();
            }, y.init(), y;
        }, D.ugenDefaults("flock.ugen.freeverb", {
            rate: "audio",
            inputs: {
                source: null,
                mix: .33,
                room: .5,
                damp: .5
            },
            ugenOptions: {
                model: {
                    spread: 0,
                    unscaledValue: 0,
                    value: 0
                },
                tunings: [ 1116, 1188, 1277, 1356, 1422, 1491, 1557, 1617 ],
                allpassTunings: [ 556, 441, 341, 225 ]
            }
        }), D.ugen.decay = function(e, t, n) {
            var s = D.ugen(e, t, n);
            return s.gen = function(e) {
                var t, n, r = s.model, a = s.inputs, o = s.output, i = a.source.output, u = a.time.output[0];
                if (u !== r.time && (r.time = u, r.coeff = 0 === u ? 0 : Math.exp(D.LOG001 / (u * s.model.sampleRate))), 
                0 === r.coeff) for (t = 0; t < e; t++) o[t] = n = i[t]; else for (t = 0; t < e; t++) r.lastSamp = i[t] + r.coeff * r.lastSamp, 
                o[t] = n = r.lastSamp;
                r.unscaledValue = n, s.mulAdd(e), r.value = D.ugen.lastOutputValue(e, o);
            }, s.onInputChanged(), s;
        }, D.ugenDefaults("flock.ugen.decay", {
            rate: "audio",
            inputs: {
                source: null,
                time: 1
            },
            ugenOptions: {
                model: {
                    time: 0,
                    lastSamp: 0,
                    coeff: 0,
                    value: 0
                }
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.ugen.gate = function(e, t, n) {
            var h = D.ugen(e, t, n);
            return h.gen = function(e) {
                var t, n, r, a, o = h.model, i = o.strides, u = h.output, s = h.inputs, l = s.source.output, c = s.sideChain.output, d = i.sideChain, f = s.threshold.output, p = i.threshold, m = h.options.holdLastValue, g = o.lastValue;
                for (t = n = r = 0; t < e; t++, n += d, r += p) c[n] >= f[r] ? u[t] = a = g = l[t] : u[t] = a = m ? g : 0;
                o.lastValue = g, o.unscaledValue = a, h.mulAdd(e), o.value = D.ugen.lastOutputValue(e, u);
            }, h.onInputChanged = function() {
                h.inputs.sideChain || (h.inputs.sideChain = h.inputs.source), D.onMulAddInputChanged(h), 
                h.calculateStrides();
            }, h.onInputChanged(), h;
        }, D.ugenDefaults("flock.ugen.gate", {
            rate: "audio",
            inputs: {
                source: null,
                sideChain: null,
                threshold: Number.MIN_VALUE,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0,
                    lastValue: 0
                },
                holdLastValue: !1,
                strideInputs: [ "sideChain", "threshold" ]
            }
        }), D.ugen.timedGate = function(e, t, n) {
            var l = D.ugen(e, t, n);
            return l.gen = function(e) {
                var t, n, r, a, o = l.model, i = l.output, u = l.inputs.trigger.output, s = l.inputs.duration.output[0];
                for (s !== o.duration && (o.duration = s, o.durationSamps = Math.floor(s * o.sampleRate)), 
                n = r = 0; n < e; n++, r += o.strides.trigger) 0 < (t = u[r]) && o.prevTrigger <= 0 ? (a = l.options.resetOnTrigger && 0 < o.sampsRemaining ? 0 : 1, 
                o.sampsRemaining = o.durationSamps) : a = 0 < o.sampsRemaining ? 1 : 0, i[n] = a, 
                o.sampsRemaining--, o.prevTrigger = t;
                o.unscaledValue = a, l.mulAdd(e), o.value = D.ugen.lastOutputValue(e, i);
            }, l.init = function() {
                l.onInputChanged();
            }, l.init(), l;
        }, D.ugenDefaults("flock.ugen.timedGate", {
            rate: "audio",
            inputs: {
                trigger: 0,
                duration: 1
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0,
                    prevTrigger: 0,
                    sampsRemaining: 0,
                    durationSamps: 0,
                    duration: 0
                },
                resetOnTrigger: !0,
                strideInputs: [ "trigger" ]
            }
        }), D.ugen.latch = function(e, t, n) {
            var d = D.ugen(e, t, n);
            return d.arGen = function(e) {
                var t, n, r, a, o = d.model, i = d.inputs, u = i.source.output, s = i.trigger, l = o.strides.source, c = d.output;
                for (void 0 === o.holdVal && (o.holdVal = u[0]), n = t = 0; t < e; t++, n += l) 0 < (r = s.output[t]) && o.prevTrig <= 0 && (o.holdVal = u[n]), 
                a = o.holdVal, c[t] = a, o.prevTrig = r;
                o.unscaledValue = a, d.mulAdd(e), o.value = D.ugen.lastOutputValue(e, c);
            }, d.krGen = function(e) {
                var t, n = d.model, r = d.output, a = d.inputs.trigger.output[0];
                for ((void 0 === n.holdVal || 0 < a && n.prevTrig <= 0) && (n.holdVal = d.inputs.source.output[0]), 
                n.prevTrig = a, t = 0; t < e; t++) r[t] = n.holdVal;
                n.unscaledValue = n.holdVal, d.mulAdd(e), n.value = D.ugen.lastOutputValue(e, r);
            }, d.onInputChanged = function() {
                d.calculateStrides(), d.gen = d.inputs.trigger.rate === D.rates.AUDIO ? d.arGen : d.krGen, 
                D.onMulAddInputChanged(d);
            }, d.onInputChanged(), d;
        }, D.ugenDefaults("flock.ugen.latch", {
            rate: "audio",
            inputs: {
                source: null,
                trigger: 0,
                mul: null,
                add: null
            },
            ugenOptions: {
                strideInputs: [ "source" ],
                model: {
                    prevTrig: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.ugen.triggerGrains = function(e, t, n) {
            var w = D.ugen(e, t, n);
            return w.gen = function(e) {
                var t, n, r, a, o, i, u, s = w.model, l = w.inputs, c = w.output, d = l.channel.output[0], f = w.buffer.data.channels[d], p = w.buffer.format.sampleRate, m = l.dur.output[0], g = l.amp.output, h = l.centerPos.output, v = l.trigger.output, y = l.speed.output, b = w.options.grainEnv, k = e - 1, S = 0, C = 0, x = 0, A = 0;
                for (t = 0; t < e; t++) {
                    if (0 < v[C] && s.prevTrigger <= 0 && s.activeGrains.length < s.maxNumGrains) {
                        for ((a = s.freeGrains.pop()).numSamps = s.sampleRate * m, a.centerIdx = a.numSamps / 2 * s.stepSize, 
                        a.envScale = w.options.grainEnv.length / a.numSamps, a.sampIdx = 0, a.amp = g[x], 
                        o = h[S] * p - a.centerIdx; o < 0; ) o += f.length;
                        a.readPos = o, a.writePos = t, a.speed = y[A], s.activeGrains.push(a);
                    }
                    s.prevTrigger = v[C], c[t] = 0, S += s.strides.centerPos, C += s.strides.trigger, 
                    x += s.strides.amp, A += s.strides.speed;
                }
                for (n = 0; n < s.activeGrains.length; ) {
                    for (r = (a = s.activeGrains[n]).writePos; r < Math.min(r + (a.numSamps - a.sampIdx), e); r++) i = w.interpolate(a.readPos, f), 
                    u = D.interpolate.linear(a.sampIdx * a.envScale, b), c[r] += i * u * a.amp, a.readPos = (a.readPos + s.stepSize * a.speed) % f.length, 
                    a.sampIdx++;
                    a.sampIdx >= a.numSamps ? (s.freeGrains.push(a), s.activeGrains.splice(n, 1)) : (n++, 
                    a.writePos = r % e);
                }
                s.unscaledValue = c[k], w.mulAdd(e), s.value = c[k];
            }, w.onBufferReady = function() {
                var e = w.model;
                e.stepSize = w.buffer.format.sampleRate / e.sampleRate;
            }, w.onInputChanged = function(e) {
                w.onBufferInputChanged(e), w.calculateStrides(), D.onMulAddInputChanged(w);
            }, w.allocateGrains = function(e) {
                e = e || w.model.maxNumGrains;
                for (var t = 0; t < e; t++) w.model.freeGrains.push({
                    numSamps: 0,
                    centerIdx: 0,
                    envScale: 0,
                    sampIdx: 0,
                    amp: 0,
                    readPos: 0,
                    writePos: 0,
                    speed: 0
                });
            }, w.init = function() {
                D.ugen.buffer(w), w.allocateGrains(), w.initBuffer(), w.onInputChanged();
            }, w.init(), w;
        }, D.ugenDefaults("flock.ugen.triggerGrains", {
            rate: "audio",
            inputs: {
                centerPos: 0,
                channel: 0,
                amp: 1,
                dur: .1,
                speed: 1,
                trigger: 0,
                buffer: null,
                mul: null,
                add: null
            },
            ugenOptions: {
                grainEnv: D.fillTable(8192, D.tableGenerators.hann),
                model: {
                    unscaledValue: 0,
                    value: 0,
                    maxNumGrains: 512,
                    activeGrains: [],
                    freeGrains: [],
                    env: null,
                    strides: {}
                },
                strideInputs: [ "centerPos", "trigger", "amp", "speed" ],
                interpolation: "cubic"
            }
        }), D.ugen.granulator = function(e, t, n) {
            var b = D.ugen(e, t, n);
            return b.gen = function(e) {
                var t, n, r, a, o, i, u, s = b.model, l = b.options, c = b.inputs, d = b.output, f = b.delayLine, p = c.grainDur.output[0], m = c.delayDur.output[0], g = c.numGrains.output[0], h = c.source.output, v = l.maxDelayDur, y = l.grainEnv;
                for (s.delayDur !== m && (v < (s.delayDur = m) && (m = v), s.delayLength = m * s.sampleRate | 0, 
                s.writePos = s.writePos % s.delayLength), s.grainDur !== p && (s.grainDur = p, s.grainLength = s.sampleRate * s.grainDur | 0, 
                s.envScale = y.length / s.grainLength), g = g > l.maxNumGrains ? l.maxNumGrains : Math.round(g), 
                t = 0; t < e; t++) {
                    for (f[s.writePos] = h[t], s.writePos = ++s.writePos % s.delayLength, n = r = 0; n < g; n++) a = s.grainIdx[n], 
                    o = s.delayLineIdx[n], a > s.grainLength && (a = 0, o = Math.random() * s.delayLength | 0), 
                    i = f[o], u = a * s.envScale, r += i * D.interpolate.linear(u, y), s.delayLineIdx[n] = ++o % s.delayLength, 
                    s.grainIdx[n] = ++a;
                    r /= g, d[t] = r;
                }
                s.unscaledValue = r, b.mulAdd(e), s.value = D.ugen.lastOutputValue(e, d);
            }, b.initGrains = function() {
                for (var e = b.model, t = 0; t < b.options.maxNumGrains; t++) e.grainIdx[t] = 0, 
                e.delayLineIdx[t] = Math.random() * e.delayLength;
            }, b.init = function() {
                var e = b.model, t = b.options, n = t.maxDelayDur * e.sampleRate | 0;
                b.delayLine = new Float32Array(n), e.delayLength = n, e.delayLineIdx = new Uint32Array(t.maxNumGrains), 
                e.grainIdx = new Uint32Array(t.maxNumGrains), b.initGrains(), b.onInputChanged();
            }, b.init(), b;
        }, D.ugenDefaults("flock.ugen.granulator", {
            rate: "audio",
            inputs: {
                source: null,
                grainDur: .1,
                delayDur: 1,
                numGrains: 5,
                mul: null,
                add: null
            },
            ugenOptions: {
                maxNumGrains: 512,
                maxDelayDur: 30,
                grainEnv: D.fillTable(8192, D.tableGenerators.sinWindow),
                model: {
                    unscaledValue: 0,
                    value: 0,
                    grainLength: 0,
                    writePos: 0
                }
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.ugen.amplitude = function(e, t, n) {
            var m = D.ugen(e, t, n);
            return m.gen = function(e) {
                var t, n, r, a = m.model, o = m.inputs.source.output, i = m.output, u = a.attackTime, s = m.inputs.attack.output[0], l = a.releaseTime, c = m.inputs.release.output[0], d = a.prevVal, f = a.attackCoef, p = a.releaseCoef;
                for (s !== u && (a.attackTime = s, f = a.attackCoef = 0 === s ? 0 : Math.exp(D.LOG01 / (s * a.sampleRate))), 
                c !== l && (a.releaseTime = c, p = a.releaseCoef = 0 === c ? 0 : Math.exp(D.LOG01 / (c * a.sampleRate))), 
                t = 0; t < e; t++) r = (n = Math.abs(o[t])) < d ? p : f, i[t] = d = n + (d - n) * r;
                a.unscaledValue = a.prevVal = d, m.mulAdd(e), a.value = D.ugen.lastOutputValue(e, i);
            }, m.onInputChanged(), m;
        }, D.ugenDefaults("flock.ugen.amplitude", {
            rate: "audio",
            inputs: {
                source: null,
                attack: .01,
                release: .01,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    prevVal: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var u = D.requireModule("webarraymath", "ArrayMath");
        D.ugen.math = function(e, t, n) {
            var i = D.ugen(e, t, n);
            return i.expandedRight = new Float32Array(i.options.audioSettings.blockSize), i.krSourceKrInputGen = function() {
                var e = i.model, t = i.activeInput, n = i.inputs[t], r = i.output, a = i.inputs.source.output[0], o = D.fillBufferWithValue(i.expandedRight, n.output[0]);
                u[t](r, a, o), e.value = e.unscaledValue = r[r.length - 1];
            }, i.krSourceArInputGen = function() {
                var e = i.model, t = i.activeInput, n = i.inputs[t], r = i.output, a = i.inputs.source.output[0], o = n.output;
                u[t](r, a, o), e.value = e.unscaledValue = r[r.length - 1];
            }, i.arSourceKrInputGen = function() {
                var e = i.model, t = i.activeInput, n = i.inputs[t], r = i.output, a = i.inputs.source.output, o = D.fillBufferWithValue(i.expandedRight, n.output[0]);
                u[t](r, a, o), e.value = e.unscaledValue = r[r.length - 1];
            }, i.arSourceArInputGen = function() {
                var e = i.model, t = i.activeInput, n = i.inputs[t], r = i.output, a = i.inputs.source.output, o = n.output;
                u[t](r, a, o), e.value = e.unscaledValue = r[r.length - 1];
            }, i.onInputChanged = function() {
                var e, t, n, r = Object.keys(i.inputs);
                for (e = 0; e < r.length; e++) if ("source" !== (t = r[e])) {
                    i.activeInput = t, n = "audio" === i.inputs[t].rate, i.gen = "audio" === i.inputs.source.rate ? n ? i.arSourceArInputGen : i.arSourceKrInputGen : n ? i.krSourceArInputGen : i.krSourceKrInputGen;
                    break;
                }
            }, i.init = function() {
                if (void 0 === u) throw new Error("ArrayMath is undefined. Please include webarraymath.js to use the flock.math unit generator.");
                i.onInputChanged();
            }, i.init(), i;
        }, D.ugenDefaults("flock.ugen.math", {
            rate: "audio",
            inputs: {
                source: null
            }
        }), D.ugen.sum = function(e, t, n) {
            var u = D.ugen(e, t, n);
            return u.copyGen = function(e) {
                var t, n, r = u.model, a = u.output, o = u.inputs.sources.output;
                for (t = 0; t < e; t++) n = o[t], a[t] = n;
                r.unscaledValue = n, u.mulAdd(e), r.value = D.ugen.lastOutputValue(e, a);
            }, u.sumGen = function(e) {
                var t, n, r, a = u.model, o = u.inputs.sources, i = u.output;
                for (D.clearBuffer(i), n = 0; n < o.length; n++) for (r = o[n].output, t = 0; t < e; t++) i[t] += r[t];
                a.unscaledValue = D.ugen.lastOutputValue(e, i), u.mulAdd(e), a.value = D.ugen.lastOutputValue(e, i);
            }, u.onInputChanged = function() {
                "number" == typeof u.inputs.sources.length ? u.gen = u.sumGen : u.gen = u.copyGen, 
                D.onMulAddInputChanged(u);
            }, u.onInputChanged(), u;
        }, D.ugenDefaults("flock.ugen.sum", {
            rate: "audio",
            inputs: {
                sources: null
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.ugen.midiFreq = function(e, t, n) {
            var d = D.ugen(e, t, n);
            return d.gen = function(e) {
                var t, n, r, a = d.model, o = a.a4, i = o.freq, u = o.noteNum, s = a.notesPerOctave, l = d.inputs.note.output, c = d.output;
                for (n = t = 0; t < e; t++, n += a.strides.note) c[t] = r = D.midiFreq(l[n], i, u, s);
                a.unscaledValue = r, d.mulAdd(e), a.value = D.ugen.lastOutputValue(e, c);
            }, d.init = function() {
                d.model.octaveScale = 1 / d.model.notesPerOctave, d.onInputChanged();
            }, d.init(), d;
        }, D.ugenDefaults("flock.ugen.midiFreq", {
            rate: "control",
            inputs: {
                note: 69
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0,
                    a4: {
                        noteNum: 69,
                        freq: 440
                    },
                    notesPerOctave: 12
                },
                strideInputs: [ "note" ]
            }
        }), D.ugen.midiAmp = function(e, t, n) {
            var u = D.ugen(e, t, n);
            return u.gen = function(e) {
                var t, n, r, a = u.model, o = u.inputs.velocity.output, i = u.output;
                for (n = t = 0; t < e; t++, n += a.strides.velocity) i[t] = r = o[n] / 127;
                a.unscaledValue = r, u.mulAdd(e), a.value = D.ugen.lastOutputValue(e, i);
            }, u.init = function() {
                u.onInputChanged();
            }, u.init(), u;
        }, D.ugenDefaults("flock.ugen.midiAmp", {
            rate: "control",
            inputs: {
                velocity: 0
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "velocity" ]
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.ugen.pan2 = function(e, t, n) {
            var p = D.ugen(e, t, n);
            return p.gen = function(e) {
                var t, n, r, a, o = p.model, i = p.output, u = i[0], s = i[1], l = p.inputs, c = l.source.output, d = l.pan.output;
                for (n = t = 0; t < e; t++, n += o.strides.pan) r = c[t], a = .5 * d[n] + .5, s[t] = r * Math.sin(a * D.HALFPI), 
                u[t] = r * Math.cos(a * D.HALFPI);
                var f = e - 1;
                o.value[0] = i[0][f], o.value[1] = i[1][f];
            }, p.init = function() {
                p.onInputChanged(), p.model.unscaledValue = p.model.value;
            }, p.init(), p;
        }, D.ugenDefaults("flock.ugen.pan2", {
            rate: "audio",
            inputs: {
                source: null,
                pan: 0
            },
            ugenOptions: {
                model: {
                    unscaledValue: [ 0, 0 ],
                    value: [ 0, 0 ]
                },
                tags: [ "flock.ugen.multiChannelOutput" ],
                strideInputs: [ "pan" ],
                numOutputs: 2
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.ugen.osc = function(e, t, n) {
            var h = D.ugen(e, t, n);
            return h.gen = function(e) {
                var t, n, r, a, o, i = h.model, u = h.inputs, s = u.freq.output, l = u.phase.output, c = u.table, d = i.tableLen, f = i.tableIncHz, p = i.tableIncRad, m = h.output, g = i.phase;
                for (r = n = t = 0; t < e; t++, n += i.strides.phase, r += i.strides.freq) d <= (a = g + l[n] * p) ? a -= d : a < 0 && (a += d), 
                m[t] = o = h.interpolate(a, c), d <= (g += s[r] * f) ? g -= d : g < 0 && (g += d);
                i.phase = g, i.unscaledValue = o, h.mulAdd(e), i.value = D.ugen.lastOutputValue(e, m);
            }, h.onInputChanged = function(e) {
                if (D.ugen.osc.onInputChanged(h), !e || "table" === e) {
                    var t = h.model, n = h.inputs.table;
                    n.length < 1 && (n = h.inputs.table = D.ugen.osc.emptyTable), t.tableLen = n.length, 
                    t.tableIncHz = t.tableLen / t.sampleRate, t.tableIncRad = t.tableLen / D.TWOPI;
                }
            }, h.onInputChanged(), h;
        }, D.ugen.osc.emptyTable = new Float32Array([ 0, 0, 0 ]), D.ugen.osc.onInputChanged = function(e) {
            e.calculateStrides(), D.onMulAddInputChanged(e);
        }, D.ugenDefaults("flock.ugen.osc", {
            rate: "audio",
            inputs: {
                freq: 440,
                phase: 0,
                table: [],
                mul: null,
                add: null
            },
            ugenOptions: {
                interpolation: "linear",
                model: {
                    phase: 0,
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "freq", "phase" ]
            },
            tableSize: 8192
        }), D.ugen.osc.define = function(e, o) {
            var t = e.lastIndexOf("."), n = e.substring(0, t), r = e.substring(t + 1);
            D.get(n)[r] = function(e, t, n) {
                var r = D.ugenDefaults("flock.ugen.osc"), a = m.merge(null, r, n).tableSize;
                return e.table = D.fillTable(a, o), D.ugen.osc(e, t, n);
            }, D.ugenDefaults(e, D.ugenDefaults("flock.ugen.osc"));
        }, D.ugen.osc.define("flock.ugen.sinOsc", D.tableGenerators.sin), D.ugen.osc.define("flock.ugen.triOsc", D.tableGenerators.tri), 
        D.ugen.osc.define("flock.ugen.sawOsc", D.tableGenerators.saw), D.ugen.osc.define("flock.ugen.squareOsc", D.tableGenerators.square), 
        D.ugen.sin = function(e, t, n) {
            var d = D.ugen(e, t, n);
            return d.gen = function(e) {
                var t, n, r, a, o = d.model, i = d.inputs.freq.output, u = d.inputs.phase.output, s = d.output, l = o.phase, c = o.sampleRate;
                for (r = n = t = 0; t < e; t++, n += o.strides.phase, r += o.strides.freq) s[t] = a = Math.sin(l + u[n]), 
                l += i[r] / c * D.TWOPI;
                o.phase = l, o.unscaledValue = a, d.mulAdd(e), o.value = D.ugen.lastOutputValue(e, s);
            }, d.onInputChanged = function() {
                D.ugen.osc.onInputChanged(d);
            }, d.onInputChanged(), d;
        }, D.ugenDefaults("flock.ugen.sin", {
            rate: "audio",
            inputs: {
                freq: 440,
                phase: 0,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: 0,
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "freq", "phase" ]
            }
        }), D.ugen.lfSaw = function(e, t, n) {
            var c = D.ugen(e, t, n);
            return c.gen = function(e) {
                var t, n, r, a = c.model, o = c.inputs.freq.output, i = c.output, u = a.scale, s = c.inputs.phase.output[0], l = a.phase;
                for (n = t = 0; t < e; t++, n += a.strides.freq) i[t] = r = l + s, 1 <= (l += o[n] * u) ? l -= 2 : l <= -1 && (l += 2);
                a.phase = l, a.unscaledValue = r, c.mulAdd(e), a.value = D.ugen.lastOutputValue(e, i);
            }, c.onInputChanged = function() {
                var e = c.model;
                e.freqInc = c.inputs.freq.rate === D.rates.AUDIO ? 1 : 0, e.phase = 0, c.calculateStrides(), 
                D.onMulAddInputChanged(c);
            }, c.init = function() {
                c.model.scale = 1 / c.options.sampleRate * 2, c.onInputChanged();
            }, c.init(), c;
        }, D.ugenDefaults("flock.ugen.lfSaw", {
            rate: "audio",
            inputs: {
                freq: 440,
                phase: 0,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: 0,
                    freqInc: 1,
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "freq" ]
            }
        }), D.ugen.lfPulse = function(e, t, n) {
            var f = D.ugen(e, t, n);
            return f.gen = function(e) {
                var t, n, r, a = f.inputs, o = f.model, i = a.freq.output, u = o.freqInc, s = a.width.output[0], l = f.output, c = o.scale, d = void 0 !== o.phase ? o.phase : a.phase.output[0];
                for (n = t = 0; t < e; t++, n += u) 1 <= d ? (d -= 1, l[t] = r = s < .5 ? 1 : -1) : l[t] = r = d < s ? 1 : -1, 
                d += i[n] * c;
                o.phase = d, o.unscaledValue = r, f.mulAdd(e), o.value = D.ugen.lastOutputValue(e, l);
            }, f.onInputChanged = function() {
                f.model.freqInc = f.inputs.freq.rate === D.rates.AUDIO ? 1 : 0, D.onMulAddInputChanged(f);
            }, f.init = function() {
                f.model.scale = 1 / f.options.sampleRate, f.onInputChanged();
            }, f.init(), f;
        }, D.ugenDefaults("flock.ugen.lfPulse", {
            rate: "audio",
            inputs: {
                freq: 440,
                phase: 0,
                width: .5,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: 0,
                    freqInc: 1,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), D.ugen.impulse = function(e, t, n) {
            var f = D.ugen(e, t, n);
            return f.gen = function(e) {
                var t, n, r, a = f.inputs, o = f.model, i = f.output, u = a.freq.output, s = o.strides.freq, l = a.phase.output[0], c = o.phase, d = o.scale;
                for (c += l, n = t = 0; t < e; t++, n += s) r = 1 <= c ? (c -= 1, 1) : 0, i[t] = r, 
                c += u[n] * d;
                o.phase = c - l, o.unscaledValue = r, f.mulAdd(e), o.value = D.ugen.lastOutputValue(e, i);
            }, f.onInputChanged = function() {
                f.calculateStrides(), D.onMulAddInputChanged(f);
            }, f.init = function() {
                f.model.scale = 1 / f.model.sampleRate, f.onInputChanged();
            }, f.init(), f;
        }, D.ugenDefaults("flock.ugen.impulse", {
            rate: "audio",
            inputs: {
                freq: 440,
                phase: 0,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    phase: 0,
                    scale: 0,
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "freq" ]
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var r = D.requireModule("Random");
        D.ugen.dust = function(l, e, t) {
            var c = D.ugen(l, e, t);
            return c.gen = function(e) {
                var t, n, r, a, o, i = c.model, u = c.output, s = l.density.output[0];
                for (n = s !== i.density ? (i.density = s, t = i.threshold = s * i.sampleDur, i.scale = 0 < t ? 1 / t : 0) : (t = i.threshold, 
                i.scale), o = 0; o < e; o++) a = (r = Math.random()) < t ? r * n : 0, u[o] = a;
                i.unscaledValue = a, c.mulAdd(e), i.value = D.ugen.lastOutputValue(e, u);
            }, c.onInputChanged(), c;
        }, D.ugenDefaults("flock.ugen.dust", {
            rate: "audio",
            inputs: {
                density: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    density: 0,
                    scale: 0,
                    threshold: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), D.ugen.whiteNoise = function(e, t, n) {
            var o = D.ugen(e, t, n);
            return o.gen = function(e) {
                var t, n, r = o.model, a = o.output;
                for (t = 0; t < e; t++) a[t] = n = D.randomAudioValue();
                r.unscaledValue = n, o.mulAdd(e), r.value = D.ugen.lastOutputValue(e, a);
            }, o.onInputChanged(), o;
        }, D.ugenDefaults("flock.ugen.whiteNoise", {
            rate: "audio",
            inputs: {
                mul: null,
                add: null
            }
        }), D.ugen.pinkNoise = function(e, t, n) {
            var d = D.ugen(e, t, n);
            return d.gen = function(e) {
                var t, n, r, a, o = d.model, i = o.state, u = d.a, s = d.p, l = o.offset, c = d.output;
                for (t = 0; t < e; t++) {
                    for (n = a = 0; n < i.length; n++) r = Math.random(), i[n] = s[n] * (i[n] - r) + r, 
                    a += u[n] * i[n];
                    a = 2 * a - l, c[t] = a;
                }
                o.unscaledValue = a, d.mulAdd(e), o.value = D.ugen.lastOutputValue(e, c);
            }, d.init = function() {
                d.a = new Float32Array(d.options.coeffs.a), d.p = new Float32Array(d.options.coeffs.p), 
                d.model.state = new Float32Array(d.a.length);
                for (var e = 0; e < d.a.length; e++) d.model.offset += d.a[e];
                d.onInputChanged();
            }, d.init(), d;
        }, D.ugenDefaults("flock.ugen.pinkNoise", {
            rate: "audio",
            inputs: {
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    state: 0,
                    unscaledValue: 0,
                    value: 0,
                    offset: 0
                },
                coeffs: {
                    a: [ .02109238, .07113478, .68873558 ],
                    p: [ .319, .7756, .9613 ]
                }
            }
        }), D.ugen.lfNoise = function(s, e, t) {
            var l = D.ugen(s, e, t);
            return l.gen = function(e) {
                var t, n, r = l.model, a = s.freq.output[0], o = e, i = l.output, u = 0;
                a = .001 < a ? a : .001;
                do {
                    for (r.counter <= 0 && (r.counter = r.sampleRate / a, r.counter = 1 < r.counter ? r.counter : 1, 
                    "linear" === l.options.interpolation ? (r.start = r.unscaledValue = r.end, r.end = Math.random(), 
                    r.ramp = r.ramp = (r.end - r.start) / r.counter) : (r.start = r.unscaledValue = Math.random(), 
                    r.ramp = 0)), o -= t = o < r.counter ? o : r.counter, r.counter -= t, n = 0; n < t; n++) i[u] = r.unscaledValue, 
                    r.unscaledValue += r.ramp, u++;
                } while (o);
                l.mulAdd(e), r.value = D.ugen.lastOutputValue(e, i);
            }, l.input = function() {
                l.model.end = Math.random(), l.onInputChanged();
            }, l.input(), l;
        }, D.ugenDefaults("flock.ugen.lfNoise", {
            rate: "audio",
            inputs: {
                freq: 440,
                mul: null,
                add: null
            },
            ugenOptions: {
                model: {
                    counter: 0,
                    level: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        }), D.ugen.random = function(e, t, n) {
            var i = D.ugen(e, t, n);
            return i.gen = function(e) {
                var t, n, r = i.model, a = i.generator, o = i.output;
                for (t = 0; t < e; t++) o[t] = n = a.uniform(-1, 1);
                r.unscaledValue = n, i.mulAdd(e), r.value = D.ugen.lastOutputValue(e, o);
            }, i.onInputChanged = function(e) {
                "seed" === e && i.initGenerator(), D.onMulAddInputChanged(i);
            }, i.initGenerator = function() {
                var e = i.inputs.seed;
                i.generator = e ? new r(e) : new r();
            }, i.init = function() {
                i.initGenerator(), i.calculateStrides(), i.onInputChanged();
            }, i.init(), i;
        }, D.ugenDefaults("flock.ugen.random", {
            rate: "audio",
            inputs: {
                seed: null,
                mul: null,
                add: null
            }
        }), D.ugen.random.exponential = function(e, t, n) {
            var l = D.ugen.random(e, t, n);
            return l.gen = function(e) {
                var t, n, r, a = l.model, o = l.generator, i = l.output, u = l.inputs.lambda.output, s = l.model.strides.lambda;
                for (t = n = 0; t < e; t++, n += s) i[t] = r = o.exponential(u[n]);
                a.unscaledValue = r, l.mulAdd(e), a.value = D.ugen.lastOutputValue(e, i);
            }, l;
        }, D.ugenDefaults("flock.ugen.random.exponential", {
            rate: "audio",
            inputs: {
                seed: null,
                lambda: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                strideInputs: [ "lambda" ]
            }
        }), D.ugen.random.gamma = function(e, t, n) {
            var p = D.ugen.random(e, t, n);
            return p.gen = function(e) {
                var t, n, r, a, o = p.model, i = p.inputs, u = p.generator, s = p.output, l = o.strides.alpha, c = i.alpha.output, d = o.strides.beta, f = i.beta.output;
                for (t = n = r = 0; t < e; t++, n += l, r += d) s[t] = a = u.gamma(c[n], f[r]);
                o.unscaledValue = a, p.mulAdd(e), o.value = D.ugen.lastOutputValue(e, s);
            }, p;
        }, D.ugenDefaults("flock.ugen.random.gamma", {
            rate: "audio",
            inputs: {
                seed: null,
                alpha: 1,
                beta: 2,
                mul: null,
                add: null
            },
            ugenOptions: {
                strideInputs: [ "alpha", "beta" ]
            }
        }), D.ugen.random.normal = function(e, t, n) {
            var p = D.ugen.random(e, t, n);
            return p.gen = function(e) {
                var t, n, r, a, o = p.model, i = p.output, u = p.inputs, s = p.generator, l = o.strides.mu, c = u.mu.output, d = o.strides.sigma, f = u.sigma.output;
                for (t = n = r = 0; t < e; t++, n += l, r += d) i[t] = a = s.normal(c[n], f[r]);
                o.unscaledValue = a, p.mulAdd(e), o.value = D.ugen.lastOutputValue(e, i);
            }, p;
        }, D.ugenDefaults("flock.ugen.random.normal", {
            rate: "audio",
            inputs: {
                seed: null,
                mu: 0,
                sigma: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                strideInputs: [ "mu", "sigma" ]
            }
        }), D.ugen.random.pareto = function(e, t, n) {
            var l = D.ugen.random(e, t, n);
            return l.gen = function(e) {
                var t, n, r, a = l.model, o = l.generator, i = l.output, u = l.model.strides.alpha, s = l.inputs.alpha.output;
                for (t = n = 0; t < e; t++, n += u) i[t] = r = o.pareto(s[n]);
                a.unscaledValue = r, l.mulAdd(e), a.value = D.ugen.lastOutputValue(e, i);
            }, l;
        }, D.ugenDefaults("flock.ugen.random.pareto", {
            rate: "audio",
            inputs: {
                seed: null,
                alpha: 5,
                mul: null,
                add: null
            },
            ugenOptions: {
                strideInputs: [ "alpha" ]
            }
        }), D.ugen.random.triangular = function(e, t, n) {
            var l = D.ugen.random(e, t, n);
            return l.gen = function(e) {
                var t, n, r, a = l.model, o = l.generator, i = l.output, u = l.model.strides.mode, s = l.inputs.mode.output;
                for (t = n = 0; t < e; t++, n += u) i[t] = r = o.triangular(-1, 1, s[n]);
                a.unscaledValue = r, l.mulAdd(e), a.value = D.ugen.lastOutputValue(e, i);
            }, l;
        }, D.ugenDefaults("flock.ugen.random.triangular", {
            rate: "audio",
            inputs: {
                seed: null,
                mode: .5,
                mul: null,
                add: null
            },
            ugenOptions: {
                strideInputs: [ "mode" ]
            }
        }), D.ugen.random.weibull = function(e, t, n) {
            var p = D.ugen.random(e, t, n);
            return p.gen = function(e) {
                var t, n, r, a, o = p.model, i = p.inputs, u = p.generator, s = p.output, l = o.strides.alpha, c = i.alpha.output, d = o.strides.beta, f = i.beta.output;
                for (t = n = r = 0; t < e; t++, n += l, r += d) s[t] = a = u.weibull(c[n], f[r]);
                o.unscaledValue = a, p.mulAdd(e), o.value = D.ugen.lastOutputValue(e, s);
            }, p;
        }, D.ugenDefaults("flock.ugen.random.weibull", {
            rate: "audio",
            inputs: {
                seed: null,
                alpha: 1,
                beta: 1,
                mul: null,
                add: null
            },
            ugenOptions: {
                strideInputs: [ "alpha", "beta" ]
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.ugen.change = function(e, t, n) {
            var p = D.ugen(e, t, n);
            return p.gen = function(e) {
                for (var t, n = p.model, r = p.inputs.initial.output, a = n.strides.initial, o = p.inputs.target.output, i = n.strides.target, u = p.output, s = n.samplesLeft, l = n.crossfadeLevel, c = 0, d = 0, f = 0; c < e; c++, 
                d += a, f += i) 0 < s ? (t = r[d], s--) : 0 < l ? (t = r[d] * l + o[f] * (1 - l), 
                l -= n.crossfadeStepSize) : t = o[f], u[c] = t;
                n.samplesLeft = s, n.crossfadeLevel = l, n.value = n.unscaledValue = t;
            }, p.onInputChanged = function(e) {
                var t = p.model, n = p.inputs;
                "time" !== e && e || (t.samplesLeft = Math.round(n.time.output[0] * t.sampleRate)), 
                "crossfade" !== e && e || (t.crossfadeStepSize = 1 / Math.round(n.crossfade.output[0] * t.sampleRate), 
                t.crossfadeLevel = 0 < n.crossfade.output[0] ? 1 : 0), p.calculateStrides();
            }, p.onInputChanged(), p;
        }, D.ugenDefaults("flock.ugen.change", {
            rate: "audio",
            inputs: {
                initial: 0,
                target: 0,
                time: 0,
                crossfade: 0
            },
            ugenOptions: {
                model: {
                    samplesLeft: 0,
                    crossfadeStepSize: 0,
                    crossfadeLevel: 0,
                    unscaledValue: 0,
                    value: 0
                },
                strideInputs: [ "initial", "target" ]
            }
        }), D.ugen.listItem = function(e, t, n) {
            var c = D.ugen(e, t, n);
            return c.gen = function(e) {
                var t, n, r, a, o = c.model, i = c.output, u = c.inputs.list, s = u.length - 1, l = c.inputs.index.output;
                for (r = t = 0; t < e; t++, r += o.strides.index) a = Math.round(l[r] * s), a = Math.max(0, a), 
                n = u[a = Math.min(a, s)], i[t] = n;
                o.unscaledValue = n, c.mulAdd(e), o.value = D.ugen.lastOutputValue(e, i);
            }, c.onInputChanged(), c;
        }, D.ugenDefaults("flock.ugen.listItem", {
            rate: "control",
            inputs: {
                index: 0,
                list: [ 0 ]
            },
            ugenOptions: {
                strideInputs: [ "index" ]
            }
        }), D.ugen.sequence = function(e, t, n) {
            var p = D.ugen(e, t, n);
            return p.gen = function(e) {
                var t, n, r, a = p.inputs.values, o = p.inputs, i = o.freq.output, u = o.loop.output[0], s = p.model, l = s.scale, c = p.output, d = o.start ? Math.round(o.start.output[0]) : 0, f = o.end ? Math.round(o.end.output[0]) : a.length;
                for (void 0 === s.unscaledValue && (t = a[d], s.unscaledValue = void 0 === t ? 0 : t), 
                void 0 === s.nextIdx && (s.nextIdx = d), r = n = 0; n < e; n++, r += s.strides.freq) {
                    if (s.nextIdx >= f) {
                        if (!(0 < u)) {
                            c[n] = s.unscaledValue;
                            continue;
                        }
                        s.nextIdx = d;
                    }
                    c[n] = s.unscaledValue = a[s.nextIdx], s.phase += i[r] * l, 1 <= s.phase && (s.phase = 0, 
                    s.nextIdx++);
                }
                p.mulAdd(e), s.value = D.ugen.lastOutputValue(e, c);
            }, p.onInputChanged = function() {
                p.model.scale = p.rate !== D.rates.DEMAND ? p.model.sampleDur : 1, p.inputs.values && 0 !== p.inputs.values.length || !p.inputs.list || (D.log.warn("The 'list' input to flock.ugen.sequence is deprecated. Use 'values' instead."), 
                p.inputs.values = p.inputs.list), p.inputs.values || (p.inputs.values = []), p.calculateStrides(), 
                D.onMulAddInputChanged(p);
            }, p.init = function() {
                p.onInputChanged();
            }, p.init(), p;
        }, D.ugenDefaults("flock.ugen.sequence", {
            rate: "control",
            inputs: {
                start: 0,
                freq: 1,
                loop: 0,
                values: []
            },
            ugenOptions: {
                model: {
                    unscaledValue: void 0,
                    value: 0,
                    phase: 0
                },
                strideInputs: [ "freq" ]
            }
        }), D.ugen.sequencer = function(e, t, n) {
            var c = D.ugen(e, t, n);
            return c.gen = function(e) {
                var t, n, r = c.model, a = c.options, o = a.resetOnNext, i = c.output, u = c.inputs.loop.output[0], s = c.inputs.durations, l = c.inputs.values;
                for (r.shouldValidateSequences && (r.shouldValidateSequences = !1, D.ugen.sequencer.validateSequences(s, l)), 
                t = 0; t < e; t++) 0 !== l.length && 0 !== s.length ? (r.samplesRemaining <= 0 ? n = r.idx < s.length - 1 ? (r.idx++, 
                D.ugen.sequencer.nextStage(s, l, o, r)) : 0 < u ? (r.idx = 0, D.ugen.sequencer.nextStage(s, l, o, r)) : a.holdLastValue ? r.unscaledValue : 0 : (n = l[r.idx], 
                r.samplesRemaining--), i[t] = n) : i[t] = n = 0;
                r.unscaledValue = n, c.mulAdd(e), r.value = D.ugen.lastOutputValue(e, i);
            }, c.onInputChanged = function(e) {
                var t = c.model, n = c.inputs;
                "durations" !== e && n.durations === t.prevDurations || (t.idx = 0, D.ugen.sequencer.calcDurationsSamps(n.durations, c.model), 
                D.ugen.sequencer.validateInput("durations", c), t.prevDurations = n.durations), 
                "values" !== e && n.values === t.prevValues || (t.idx = 0, D.ugen.sequencer.validateInput("values", c), 
                t.prevValues = n.values), c.model.shouldValidateSequences = !0, D.onMulAddInputChanged(c);
            }, c.init = function() {
                c.onInputChanged();
            }, c.init(), c;
        }, D.ugen.sequencer.validateInput = function(e, t) {
            var n = t.inputs[e];
            n && D.isIterable(n) || D.fail("No " + e + " array input was specified for flock.ugen.sequencer: " + m.prettyPrintJSON(t.options.ugenDef));
        }, D.ugen.sequencer.validateSequences = function(e, t) {
            e.length !== t.length && D.fail("Mismatched durations and values array lengths for flock.ugen.sequencer. Durations: " + m.prettyPrintJSON(e) + ", values: " + m.prettyPrintJSON(t));
        }, D.ugen.sequencer.calcDurationsSamps = function(e, t) {
            t.samplesRemaining = Math.floor(e[t.idx] * t.sampleRate);
        }, D.ugen.sequencer.nextStage = function(e, t, n, r) {
            return D.ugen.sequencer.calcDurationsSamps(e, r), r.samplesRemaining--, n ? 0 : t[r.idx];
        }, D.ugenDefaults("flock.ugen.sequencer", {
            rate: "audio",
            inputs: {
                durations: [],
                values: [],
                loop: 0
            },
            ugenOptions: {
                model: {
                    idx: 0,
                    samplesRemaining: 0,
                    unscaledValue: 0,
                    value: 0,
                    prevDurations: [],
                    prevValues: []
                },
                resetOnNext: !1,
                holdLastvalue: !1
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        D.ugen.valueChangeTrigger = function(e, t, n) {
            var u = D.ugen(e, t, n);
            return u.gen = function(e) {
                var t, n, r, a = u.model, o = u.inputs.source.output, i = u.output;
                for (n = t = 0; t < e; t++, n += a.strides.source) r = o[n], i[t] = r !== a.prevVal ? 1 : 0, 
                a.prevVal = r;
                a.value = a.unscaledValue = r;
            }, u.onInputChanged = function(e) {
                u.calculateStrides(), "source" === e && u.options.triggerOnSetSameValue && (u.model.prevVal = null);
            }, u.calculateStrides(), u;
        }, D.ugenDefaults("flock.ugen.valueChangeTrigger", {
            rate: "control",
            inputs: {
                source: 0
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0,
                    prevVal: 0
                },
                triggerOnSetSameValue: !0,
                strideInputs: [ "source" ]
            }
        }), D.ugen.inputChangeTrigger = function(e, t, n) {
            var p = D.ugen(e, t, n);
            return p.gen = function(e) {
                var t, n, r, a, o, i = p.model, u = p.inputs.source.output, s = i.strides.source, l = p.inputs.duration.output, c = i.strides.duration, d = i.prevDur, f = p.output;
                for (t = n = r = 0; t < e; t++, n += s, r += c) a = u[n], (o = l[r]) !== d && (i.prevDur = o, 
                i.remainingOpenSamples = 0 < a ? 0 < o ? i.sampleRate * o : 1 : 0), 0 < i.remainingOpenSamples ? (f[t] = a, 
                i.remainingOpenSamples--) : f[t] = 0;
                i.value = i.unscaledValue = D.ugen.lastOutputValue(e, f);
            }, p.onInputChanged = function(e) {
                p.calculateStrides(), "source" === e && (p.model.prevDur = null);
            }, p.calculateStrides(), p;
        }, D.ugenDefaults("flock.ugen.inputChangeTrigger", {
            rate: "control",
            inputs: {
                source: 0,
                duration: 0
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0,
                    prevDuration: 0,
                    remainingOpenSamples: 0
                },
                strideInputs: [ "source", "duration" ]
            }
        }), D.ugen.triggerCallback = function(e, t, n) {
            var k = D.ugen(e, t, n);
            return k.gen = function(e) {
                var t, n, r, a, o, i = k.model, u = k.options, s = k.output, l = k.inputs, c = i.strides.trigger, d = i.strides.source, f = l.trigger.output, p = l.source.output, m = u.callback, g = m.func, h = m.args, v = m.this, y = i.lastArgIdx, b = i.prevTrig;
                for (t = n = r = 0; t < e; t++, n += c, r += d) a = f[n], o = p[r], 0 < a && b <= 0 && g && (h[y] = o, 
                g.apply(v, h)), s[t] = o, b = a;
                i.prevTrig = b, i.value = i.unscaledValue = o;
            }, k.onInputChanged = function() {
                var e = k.options, t = k.model, n = e.callback, r = n.funcName;
                if (r) n.func = m.getGlobalValue(r); else if (n.this && n.method) {
                    if ("string" != typeof n.this) throw new Error("flock.ugen.triggerCallback doesn't support raw 'this' objects.Use a global key path instead.");
                    n.this = "string" == typeof n.this ? m.getGlobalValue(n.this) : n.this, n.func = m.get(n.this, n.method);
                }
                t.lastArgIdx = n.args.length, k.calculateStrides();
            }, k.onInputChanged(), k;
        }, D.ugenDefaults("flock.ugen.triggerCallback", {
            rate: "audio",
            inputs: {
                source: 0,
                trigger: 0
            },
            ugenOptions: {
                model: {
                    unscaledValue: 0,
                    value: 0,
                    funcName: void 0,
                    lastArgIdx: 0
                },
                callback: {
                    this: void 0,
                    method: void 0,
                    func: void 0,
                    args: []
                },
                strideInputs: [ "source", "trigger" ]
            }
        }), D.ugen.t2a = function(e, t, n) {
            var i = D.ugen(e, t, n);
            return i.gen = function() {
                for (var e, t = i.model, n = i.inputs.source.output[0], r = 0 | i.inputs.offset.output[0], a = i.output, o = 0; o < a.length; o++) a[o] = e = 0;
                0 < n && t.prevTrig <= 0 && (a[r] = e = n), t.prevTrig = n, t.value = t.unscaledValue = e;
            }, i;
        }, D.ugenDefaults("flock.ugen.t2a", {
            rate: "audio",
            inputs: {
                source: null,
                offset: 0
            },
            ugenOptions: {
                model: {
                    prevTrig: 0,
                    unscaledValue: 0,
                    value: 0
                }
            }
        });
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    !function() {
        "use strict";
        var a = m.registerNamespace("jQuery");
        m.registerNamespace("flock.view"), D.view.scope = function(e, t) {
            var c = {
                model: t || {
                    values: []
                },
                canvas: a(e)[0],
                refreshView: function() {
                    var e, t, n, r = c.ctx, a = c.model.height, o = c.model.halfHeight, i = c.model.width, u = c.model.values, s = u.length, l = c.model.scaleX * (i / s);
                    for (r.clearRect(0, 0, i, a), r.beginPath(), e = 0; e < s; e++) t = e * l, n = u[e] * c.model.scaleY * o + o, 
                    r.lineTo(t, n);
                    r.stroke();
                },
                init: function() {
                    c.ctx = c.canvas.getContext("2d"), c.ctx.fillStyle = c.model.fill || c.ctx.fillStyle, 
                    c.ctx.strokeStyle = c.model.strokeColor || c.ctx.strokeStyle, c.ctx.lineWidth = c.model.strokeWidth || c.ctx.lineWidth, 
                    c.model.min = c.model.min || -1, c.model.max = c.model.max || 1, c.model.height = c.canvas.height, 
                    c.model.halfHeight = c.model.height / 2, c.model.width = c.canvas.width, c.model.scaleX = c.model.scaleX || c.model.scale || 1, 
                    c.model.scaleY = c.model.scaleY || c.model.scale || 1, c.refreshView();
                }
            };
            return c.init(), c;
        }, D.view.drawBuffer = function(e, t) {
            (t = t || {}).height = t.height || 200, t.width = t.width || 1e3;
            var n = m.stringTemplate(D.view.drawBuffer.markupTemplate, t), r = a(n);
            return D.view.scope(r[0], {
                values: e
            }), r;
        }, D.view.drawBuffer.markupTemplate = "<canvas height='%height' width='%width'></canvas>";
    }();
    D = (m = m || require("infusion")).registerNamespace("flock");
    return function() {
        "use strict";
        var o = m.registerNamespace("jQuery");
        m.registerNamespace("flock.ugen"), D.ugen.scope = function(e, t, n) {
            var u = D.ugen(e, t, n);
            return u.gen = function(e) {
                var t, n = u.model, r = u.inputs.source.output, a = n.spf, o = n.bufIdx, i = n.scope.values;
                for (t = 0; t < e; t++) i[o] = r[t], o < a ? o += 1 : (o = 0, u.scopeView.refreshView());
                n.bufIdx = o, n.value = n.unscaledValue = D.ugen.lastOutputValue(e, r);
            }, u.onInputChanged = function() {
                u.output = u.inputs.source.output;
            }, u.init = function() {
                u.model.spf = Math.round(u.model.sampleRate / u.options.fps), u.model.bufIdx = 0, 
                u.model.scope = u.options.styles, u.model.scope.values = new Float32Array(u.model.spf), 
                u.scopeView = D.view.scope(u.options.canvas, u.model.scope), u.onInputChanged(), 
                u.scopeView.refreshView();
            }, u.init(), u;
        }, D.ugenDefaults("flock.ugen.scope", {
            rate: "audio",
            inputs: {
                source: null
            },
            ugenOptions: {
                fps: 60,
                styles: {
                    strokeColor: "#777777",
                    strokeWidth: 1
                }
            }
        }), D.ugen.mouse = {}, D.ugen.mouse.cursor = function(e, t, n) {
            var d = D.ugen(e, t, n);
            return d.exponentialGen = function(e) {
                var t, n, r = d.model, a = D.ugen.mouse.cursor.normalize(d.target, r), o = r.movingAvg, i = d.inputs.lag.output[0], u = d.inputs.add.output[0], s = d.inputs.mul.output[0], l = r.lagCoef, c = d.output;
                for (i !== l && (l = 0 === i ? 0 : Math.exp(D.LOG001 / (i * r.sampleRate)), r.lagCoef = l), 
                t = 0; t < e; t++) n = s + u, o = (a = Math.pow(n / u, a) * u) + l * (o - a), c[t] = o;
                r.movingAvg = o, r.value = r.unscaledValue = o;
            }, d.linearGen = function(e) {
                var t, n = d.model, r = D.ugen.mouse.cursor.normalize(d.target, n), a = n.movingAvg, o = d.inputs.lag.output[0], i = d.inputs.add.output[0], u = d.inputs.mul.output[0], s = n.lagCoef, l = d.output;
                for (o !== s && (s = 0 === o ? 0 : Math.exp(D.LOG001 / (o * n.sampleRate)), n.lagCoef = s), 
                t = 0; t < e; t++) a = r + s * (a - r), l[t] = a * u + i;
                n.movingAvg = n.unscaledValue = a, n.value = D.ugen.lastOutputValue(e, l);
            }, d.noInterpolationGen = function(e) {
                var t, n = d.model, r = d.output, a = D.ugen.mouse.cursor.normalize(d.target, n);
                for (t = 0; t < e; t++) r[t] = a * d.inputs.mul.output[0] + d.inputs.add.output[0];
                n.value = n.unscaledValue = D.ugen.lastOutputValue(e, r);
            }, d.moveListener = function(e) {
                var t = d.model;
                t.mousePosition = e[t.eventProp];
            }, d.overListener = function() {
                d.model.isWithinTarget = !0;
            }, d.outListener = function() {
                var e = d.model;
                e.isWithinTarget = !1, e.mousePosition = 0;
            }, d.downListener = function() {
                d.model.isMouseDown = !0;
            }, d.upListener = function() {
                var e = d.model;
                e.isMouseDown = !1, e.mousePosition = 0;
            }, d.moveWhileDownListener = function(e) {
                d.model.isMouseDown && d.moveListener(e);
            }, d.bindEvents = function() {
                var e = d.target, t = d.moveListener;
                d.options.onlyOnMouseDown && (e.mousedown(d.downListener), e.mouseup(d.upListener), 
                t = d.moveWhileDownListener), e.mouseover(d.overListener), e.mouseout(d.outListener), 
                e.mousemove(t);
            }, d.onInputChanged = function() {
                D.onMulAddInputChanged(d);
                var e = d.options.interpolation;
                d.gen = "none" === e ? d.noInterpolationGen : "exponential" === e ? d.exponentialGen : d.linearGen;
            }, d.init = function() {
                var e = d.model, t = d.options, n = t.axis, r = o(t.target || window);
                "x" === n || "width" === n || "horizontal" === n ? (e.eventProp = "clientX", e.offsetProp = "left", 
                e.dimension = "width") : (e.eventProp = "clientY", e.offsetProp = "top", e.dimension = "height"), 
                d.target = r, e.mousePosition = 0, e.movingAvg = 0, d.bindEvents(), d.onInputChanged();
            }, d.init(), d;
        }, D.ugen.mouse.cursor.normalize = function(e, t) {
            if (!t.isWithinTarget) return 0;
            var n = e.getClientRects ? e.offset() : void 0, r = t.mousePosition, a = e[t.dimension]();
            return n && (r -= n[t.offsetProp]), r / a;
        }, D.ugenDefaults("flock.ugen.mouse.cursor", {
            rate: "control",
            inputs: {
                lag: .5,
                add: 0,
                mul: 1
            },
            ugenOptions: {
                axis: "x",
                interpolation: "linear",
                model: {
                    mousePosition: 0,
                    movingAvg: 0,
                    value: 0
                }
            }
        }), D.ugen.mouse.click = function(e, t, n) {
            var a = D.ugen(e, t, n);
            return a.gen = function(e) {
                var t, n = a.output, r = a.model;
                for (t = 0; t < e; t++) n[t] = r.unscaledValue;
                a.mulAdd(e), r.value = D.ugen.lastOutputValue(e, n);
            }, a.mouseDownListener = function() {
                a.model.unscaledValue = 1;
            }, a.mouseUpListener = function() {
                a.model.unscaledValue = 0;
            }, a.init = function() {
                var e = a.model;
                e.target = a.options.target ? o(a.options.target) : o(window), e.target.mousedown(a.mouseDownListener), 
                e.target.mouseup(a.mouseUpListener), a.onInputChanged();
            }, a.onInputChanged = function() {
                D.onMulAddInputChanged(a);
            }, a.init(), a;
        }, D.ugenDefaults("flock.ugen.mouse.click", {
            rate: "control"
        }), D.ugen.mediaIn = function(e, t, n) {
            var i = D.ugen(e, t, n);
            return i.gen = function(e) {
                for (var t, n = i.model, r = i.output, a = i.bus, o = 0; o < e; o++) r[o] = t = a[o];
                n.unscaledValue = t, i.mulAdd(e), n.value = D.ugen.lastOutputValue(e, r);
            }, i.onInputChanged = function() {
                D.onMulAddInputChanged(i);
            }, i.init = function() {
                var e = i.enviro.audioSystem.nativeNodeManager, t = o(i.options.element), n = e.createMediaElementInput(t[0]);
                i.bus = i.options.buses[n], i.onInputChanged(), D.platform.browser.safari && D.platform.browser.majorVersionNumber < 601 ? D.log.warn("MediaElementSourceNode only works on Safari 9 or higher. For more information, see https://bugs.webkit.org/show_bug.cgi?id=84743 and https://bugs.webkit.org/show_bug.cgi?id=125031") : D.platform.isAndroid && D.log.warn("MediaElementSourceNode does not work on Android. For more information, see https://code.google.com/p/chromium/issues/detail?id=419446");
            }, i.init(), i;
        }, D.ugenDefaults("flock.ugen.mediaIn", {
            rate: "audio",
            inputs: {
                mul: null,
                add: null
            },
            ugenOptions: {
                element: "audio"
            }
        });
    }(), window.fluid = m, D;
});